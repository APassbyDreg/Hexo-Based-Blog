{"meta":{"title":"Blog of Martin Z He","subtitle":"","description":"a minimal blog","author":"Martin Z He","url":"https://blog.apassbydreg.work","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2021-11-23T06:01:48.267Z","updated":"2021-10-19T17:36:48.019Z","comments":false,"path":"/404.html","permalink":"https://blog.apassbydreg.work/404","excerpt":"","text":""},{"title":"书单","date":"2021-11-23T06:01:48.266Z","updated":"2021-10-19T17:36:48.024Z","comments":false,"path":"books/index.html","permalink":"https://blog.apassbydreg.work/books/","excerpt":"","text":""},{"title":"友情链接","date":"2021-11-23T06:01:48.266Z","updated":"2021-10-19T17:36:48.026Z","comments":true,"path":"links/index.html","permalink":"https://blog.apassbydreg.work/links/","excerpt":"","text":""},{"title":"分类","date":"2021-11-23T06:01:48.266Z","updated":"2021-10-19T17:36:48.025Z","comments":false,"path":"categories/index.html","permalink":"https://blog.apassbydreg.work/categories/","excerpt":"","text":""},{"title":"关于","date":"2021-11-23T06:01:48.244Z","updated":"2021-10-20T05:28:22.974Z","comments":false,"path":"about/index.html","permalink":"https://blog.apassbydreg.work/about/","excerpt":"","text":"21 世纪的第一批 00 后，本职 Coding ，偶尔做做视频。 个人主页： BiliBili GitHub"},{"title":"标签","date":"2021-11-23T06:01:48.243Z","updated":"2021-10-19T17:36:48.028Z","comments":false,"path":"tags/index.html","permalink":"https://blog.apassbydreg.work/tags/","excerpt":"","text":""},{"title":"Repositories","date":"2021-11-23T06:01:48.265Z","updated":"2021-10-19T17:36:48.027Z","comments":false,"path":"repository/index.html","permalink":"https://blog.apassbydreg.work/repository/","excerpt":"","text":""}],"posts":[{"title":"GTC2022 Talk - How CUDA Programming Works","slug":"GTC2022-How-CUDA-Programming-Works","date":"2022-05-07T02:03:12.000Z","updated":"2022-05-07T02:08:54.221Z","comments":true,"path":"2022/05/GTC2022-How-CUDA-Programming-Works/","link":"","permalink":"https://blog.apassbydreg.work/2022/05/GTC2022-How-CUDA-Programming-Works/","excerpt":"","text":"原始链接：How CUDA Programming Works | NVIDIA On-Demand 本次演讲以安培架构的 A100 GPU 核心为例，讲解了 CUDA 编程的核心原理和优化点。 显存带宽限制 对于一个典型的 Ampere GPU，其理论上能够处理的数据数量相比最高端的 HBM2 内存带来的带宽还要多上 6 倍之多，虽然其中包含了数据复用和缓存等机制，但这一差距仍然不容小觑。 另一方面，在显存读取数据时的流程带来了特殊的读取性质。在显存中，地址按照高位和低位被分为行和列。在读取数据时的流程如下： 首先将数据从给定的行读取到感知增幅器（Sense Amplifier）中，这一操作会将行中原有的数据破坏 接着从增幅器中读取给定的列，这一操作不会破坏数据 如果接下来的请求来自同一行，可以重复地读取当前增幅器中的数据值，或者同时读取多列的数据 当需要选择新的一行时，增幅器中的数据需要被写回显存中 在这一过程中，跨行读取数据的耗时是在同行内读取数据的约三倍。为晶体管充电、放电的速度受限于物理的 RC 常数。 也就是说，当进行跨行数据读取时，实际的显存带宽比起理论值会小非常多。下图展示了在 A100 上以不同间隔每次读取8B数据的实际带宽： 在紧凑读取时带宽最高，随后快速降低，在到达一次批量读取就能获得所有数据的阈值处稳定下来，接着在达到跨行读取时进一步降低。最低的带宽只有理论速度的约8%。 跨行读取的高延迟告诉我们需要尽量沿着数据排列的行主序方向进行读取。 计算资源限制 CUDA 的执行顺序 CUDA 使用 SIMT 执行框架，让统一指令在多个线程之上执行。 计算会被分分割为非常多的子任务，每个子任务会被 GPU 上的线程以固定数量为一组形成的 Thread Block 执行。每个 block 又可以被分为以 32 个线程为一组的 warp ，warp 是 GPU 的基础向量执行单元。 A100 的一个 SM 可以管理 64 个 warp ，它被分为 4 组不同的单元，各自拥有其对应的寄存器、指令缓存、分配器。由于 block 中的线程会共同读取数据，一个核心优化点在于让所有的线程按照线程 ID 访问相邻的内存，并尽可能地让线程数目满足读取的数据可以占满显存一行的倍数的大小。 GPU 的计算资源 一个 A100 GPU 的单个 SM 内的计算资源如图所示： 由于每个 SM 的显存带宽有限，GPU 会将工作优先分配到尽可能多的 SM 上。 为了实现计算速度的最大化，需要是的最大化并行的线程数量，但这一数量同时受限于共享内存的大小以及寄存器的大小。当共享内存或寄存器用尽时就无法申请新的 block 。另一个限制是单个 block 不能跨越多个 SM ，因为其中的线程需要通过共享内存等方法进行通信。 这里的优化点在于在设计算法时尽量优化其占用率（Occupancy），通过优化产生瓶颈的部分可以提高资源的利用率。 当一个 SM 被一类 block 充满但并非所有资源都被用尽时，它会尝试使用其他可并行的 block 填充剩余空间： 这些可并行的任务可以通过不同的 Stream 进行指定。 这里的优化点在于可以向 GPU 显示地指示互相独立的任务，以便 GPU 更好地并行它们，尽可能地填充可用资源。","categories":[{"name":"programming","slug":"programming","permalink":"https://blog.apassbydreg.work/categories/programming/"},{"name":"presentation notes","slug":"programming/presentation-notes","permalink":"https://blog.apassbydreg.work/categories/programming/presentation-notes/"}],"tags":[{"name":"GTC","slug":"GTC","permalink":"https://blog.apassbydreg.work/tags/GTC/"},{"name":"CUDA","slug":"CUDA","permalink":"https://blog.apassbydreg.work/tags/CUDA/"},{"name":"GPU Programming","slug":"GPU-Programming","permalink":"https://blog.apassbydreg.work/tags/GPU-Programming/"}]},{"title":"《游戏编程模式》笔记合集 | Notes Collection for Game Programming Patterns","slug":"GPP-Archive","date":"2022-04-18T16:25:38.000Z","updated":"2022-04-18T16:35:45.493Z","comments":true,"path":"2022/04/GPP-Archive/","link":"","permalink":"https://blog.apassbydreg.work/2022/04/GPP-Archive/","excerpt":"","text":"这是一本较为入门的有趣的设计模式书籍，其中简单生动地描述了游戏中常用的算法。在这里简单做个章节合集： 章节目录 第一章：重返设计模式（Design Patterns Revisited） 第二章：序列模式（Sequencing Patterns） 第三章：行为模式（Behavioral Patterns） 第四章：解耦模式（Decoupling Patterns） 第五章：优化模式（Optimization Patterns） 中文原文 WEB 版：https://gpp.tkchu.me/","categories":[{"name":"programming","slug":"programming","permalink":"https://blog.apassbydreg.work/categories/programming/"},{"name":"reading notes","slug":"programming/reading-notes","permalink":"https://blog.apassbydreg.work/categories/programming/reading-notes/"}],"tags":[{"name":"OOP","slug":"OOP","permalink":"https://blog.apassbydreg.work/tags/OOP/"},{"name":"Game Programming Patterns","slug":"Game-Programming-Patterns","permalink":"https://blog.apassbydreg.work/tags/Game-Programming-Patterns/"}]},{"title":"《游戏编程模式》第五章笔记 | Notes for Game Programming Patterns Chapter 05","slug":"GPP-ch05","date":"2022-04-18T16:22:12.000Z","updated":"2022-04-18T16:25:10.368Z","comments":true,"path":"2022/04/GPP-ch05/","link":"","permalink":"https://blog.apassbydreg.work/2022/04/GPP-ch05/","excerpt":"","text":"第五章：优化模式 优化游戏性能是一门高深的艺术，要接触到软件的各个层面。 底层程序员掌握硬件架构的种种特质。同时，算法研究者争先恐后地证明谁的过程是最有效率的。 本章描述了几个加速游戏的中间层模式。 数据局部性介绍了计算机的存储层次以及如何使用其以获得优势。 脏标识帮你避开不必要的计算。 对象池帮你避开不必要的内存分配。 空间分区加速了虚拟世界和其中元素的空间布局。 数据局部性 脏标识模式 对象池模式 空间分区","categories":[{"name":"programming","slug":"programming","permalink":"https://blog.apassbydreg.work/categories/programming/"},{"name":"reading notes","slug":"programming/reading-notes","permalink":"https://blog.apassbydreg.work/categories/programming/reading-notes/"}],"tags":[{"name":"OOP","slug":"OOP","permalink":"https://blog.apassbydreg.work/tags/OOP/"},{"name":"Game Programming Patterns","slug":"Game-Programming-Patterns","permalink":"https://blog.apassbydreg.work/tags/Game-Programming-Patterns/"}]},{"title":"《游戏编程模式》第四章笔记 | Notes for Game Programming Patterns Chapter 04","slug":"GPP-ch04","date":"2022-04-17T16:52:30.000Z","updated":"2022-04-17T16:55:18.765Z","comments":true,"path":"2022/04/GPP-ch04/","link":"","permalink":"https://blog.apassbydreg.work/2022/04/GPP-ch04/","excerpt":"","text":"第四章：解耦模式 本章的模式有助于解耦复杂系统中的各个部分，组件模式将一个实体拆成多个，解耦不同的领域。 事件序列解耦了两个互相通信的事物，稳定而且及时。 服务定位器让代码使用服务而无需绑定到提供服务的代码。 组件模式 事件队列 服务定位器","categories":[{"name":"programming","slug":"programming","permalink":"https://blog.apassbydreg.work/categories/programming/"},{"name":"reading notes","slug":"programming/reading-notes","permalink":"https://blog.apassbydreg.work/categories/programming/reading-notes/"}],"tags":[{"name":"OOP","slug":"OOP","permalink":"https://blog.apassbydreg.work/tags/OOP/"},{"name":"Game Programming Patterns","slug":"Game-Programming-Patterns","permalink":"https://blog.apassbydreg.work/tags/Game-Programming-Patterns/"}]},{"title":"Dynamic Diffuse Global Illumination - GDC 2018","slug":"DDGI","date":"2022-04-16T04:52:53.000Z","updated":"2022-04-16T05:07:39.850Z","comments":true,"path":"2022/04/DDGI/","link":"","permalink":"https://blog.apassbydreg.work/2022/04/DDGI/","excerpt":"","text":"本文源自 GDC 2018 中 NVIDIA 的分享：https://morgan3d.github.io/articles/2019-04-01-ddgi/index.html Glossy GI 环境贴图 Glossy GI 贡献了光滑表面上可辨识的反射，从 19 世纪 70 年代起，其就被使用环境贴图来近似。随着时间的演进，它的核心算法也被视差扰动和可变表面粗糙度的方法而改进。这一类算法一般被称为环境映射、环境探针、辐照度探针、光照探针等。 大部分在实时渲染中使用的光照探针都是预计算的，这使得动态的物体和光源都无法影响反射光照。虽然在很多游戏中使用了各自 tricks 来提供高效的全局光照，但它们都无法实现真正通用的实时 Glossy GI 。 光线追踪 最早出现于 CryEngine 3 的屏幕空间反射技术在近年来被广泛用于近距离物体的反射计算。这篇文章详细分析了这一算法。进一步地，为了处理不在屏幕空间内的表面的反射，需要进行真实几何的光线追踪。当前的许多游戏都使用了上述的一种或多种算法。 算法 在完美平滑表面的 Glossy GI 的实现相当直观，对于镜面而言光线击中的着色值就是对应的 GI 值。而对于模糊的粗糙反射则存在两种方法：要么使用随机光线采样，并模糊采样的结果；要么直接采样完美反射方向，并模糊其反射内容。 上图展示了这个流程： 在只有一半的垂直分辨率的 GBuffer 上进行光线追踪，每个像素追踪一个完美反射方向，然后使用常用的延迟渲染方法对光线追踪的结果位置进行着色，次级 Glossy GI 也可以使用类似的方法完成 使用 MIP map 模糊镜面反射结果的 buffer ，模糊时会使用特殊的双向滤波方法以保证其不会采样到无高光反射的黑色区域 使用主表面的粗糙度和出入射光线的距离计算 MIP map 的层级，进而采样上述贴图 这种方法相较于进行随机光线采样可以较为简单地减少高光走样，但并不那么物理准确。事实上，上述问题是 Glossy GI 中会遇到的主要问题。TAA 对此而言是一把双刃剑，它虽然可以减少走样，但需要十分复杂的对于反射物体和反射表面的 motion vector 处理。一种处理方法是禁用视差和法线映射，并在图像上使用 FXAA 。这相当于在反射 buffer 上使用 TAA 。 在较近的物体上使用 SSR ，并对非常远的物体使用环境探针可以通过缩短光线长度以减少约一半的消耗。使用棋盘渲染方法而非减半垂直采样数可以提升图像质量，但也有着出现横向走样的风险。减半分辨率渲染和 DLSS 也可以被整合入整个流程中以减少走样。 旧 Diffuse GI 动态的高光 GI 已经在数年前被基本解决了，剩余的问题包括更高效地解决屏幕外的物体，以及减少噪声和走样。但从来没有一种稳定、动态且高效的方法能够解决 Diffuse GI 的问题。下面列举了一些可以在特定情况下提供优秀结果的方法： Light maps Quake97 Mitchell06 Irradiance probes/voxels Greger98 Tatarchuk05 Ramamoorthi11 Gilabert12 Virtual point lights Keller97 Kaplanyan10 Ding14 Xu16 Sassone19 White19 Reflective shadow maps Dachsbacher05Kaplanyan10Ding14Malmros17Xu16White19 Light propagation volumes Kaplanyan09Kaplanyan10 Sparse voxel cone tracing Crassin11McLaren16 Denoised ray tracing Mara17Schied17Metro19Archard19 预计算的 Light maps 是 DX11 级别游戏的主流解决方案，并被大多数主流游戏引擎所支持。Enlighten 中间件可以使用简化的模型在运行时动态地更新光照贴图和探针，它已被用于非常多的游戏，并为 DDGI 提供了灵感来源。 除了上述列举的方法以外，RTR4 中还列举了一个完整的 survey 以记录所有实时全局光照方法。 为了更好地理解 DDGI 首先需要理解传统的 irradiance 探针方法，因为这是 DDGI 主要加速并改进的全局光照方法。这种方法的限制也可以很好地代表上述方法的限制。 经典的 Irradiance 探针 源于 1998 年 Greger98 的在稀疏空间储存 irradiance 场的想法发展至今，已经被许多引擎所采用。引擎会使用细小的探针测量并储存空间中的 Diffuse GI 信息，这种使用 cos⁡\\coscos 加权积分入射光线的 radiance 得到的在数学上即为对应空间位置的 irradiance 。每个探针都表示了一整个单位球面的方向，它们可以使用任意的球面映射方式储存。这些值通常会使用离线方法被预计算出来，部分引擎会在运行时通过在非常低 LOD 的场景中采样光线来更新这个值。 irradiance 光照探针的质量可以非常高，对于在探针附近的表面通常可以得到非常完美的表现，但它也拥有包括离线烘焙耗时大且打断工作流、难以计算实时探针和在探针密度不足的区域漏光的问题。 漏光 当光照由于某些场景几何而发生大幅变化时，irradiance 探针会因为采样不足而产生漏光的问题。 上图（来自 SIGGRAPH talk Hooker16 ）屋外的亮处向屋内贡献了不正确的阳光光照，而门的阴影则贡献了不正确的暗部。当前最有效的解决方法是让艺术家人工地放置遮挡几何体以区分内外侧，上图的来源详细地讨论了这个问题，但这一方法也无法解决动态光照的问题。 这些问题在所有的实时 Diffuse GI 中都有出现，是所有算法中共同潜藏的缺陷。 DDGI 升级探针 传统的 irradiance 探针由于其高效率、低噪声、适用广、无参数等特点广泛应用于各自引擎中。正如上文所描述的，这类算法的主要缺点就在于其漏光和难以动态更新的问题。DDGI 升级了传统的光照探针以解决此问题。 对于漏光问题，将可视性信息储存在探针中 对于动态问题，使用异步的 GPU 光线追踪以计算低分辨率的探针，并使用一个内存一致的收集混合策略以分摊消耗，避免闪烁 探针放置 下图展示了 DDGI 的探针放置情况。 在制作中，可以首先从一个均匀网格开始，这一般就可以获得一个可用的结果。再针对高频的细节位置增加探针数量，或者减少部分位置的探针以提高运行效率。 另一方面，由于这种探针的整体效果随着放置位置的影响不大，它可以直接支持动态场景，有效地减少了流程中对光照和几何体的调整对最终效果的影响。除此之外，任意的光照探针都可以在场景网格中任意移动，从而提供精细的调整。 层级结构 光照探针的放置和更新策略可以使用层次结构有效地进行管理，对于远处的探针，在减小更新的频率的同时还可以通过禁用可视性检测以进一步加快运行效率。 数据结构 下图展示了在上述场景的探针中单一层次的材质内存储存方式，上一排展示了使用 R11G11B10F 方式储存的 irradiance 信息，下图展示了二维的 RG16F 的可见性信息。 在这一场景中使用了 32*32*4 个探针，可以观察到每个材质包含了四个横向排列的矩形，这正对应了四个不同的纵向探针层级。黑色的部分表示了探针进入了墙壁中。 在每个大型矩形中有大量的小矩形以表示探针携带的值。球状的方向信息会被投影到八面体上，接着展开为一个 6*6 的 irradiance 矩形和一个 16*16 的可见性（储存了深度信息）矩形。 在这种储存方式下，每一层中的 irradiance 信息需要占用 590 KB的空间，可视性信息则占用了约 4MB 的空间。 算法 DDGI 和传统的 Glossy GI 算法类似，它主要包含了三个步骤：光线追踪、更新探针以及对可视位置进行着色。 光线追踪 这一步中会为每个探针生成约 100 - 300 根光线，生成对应的 GBuffer ，并使用标准的 deferred 方式对这些光线进行着色。 由于 Glossy GI 只使用了一半的屏幕高度，光线追踪的信息可以被放入其屏幕缓冲区的下半部分以在单 Pass 内完成两部分的着色。由于着色时使用的 Diffuse GI 信息是来自上一帧的内容，DDGI 通过增加反射数量以让其结果可以在场景变化后的几帧之内快速收敛到新的值上。 更新探针 使用新的着色数据更新探针。这一步会遍历所有探针的纹素，对每一个纹素收集所有的光线相交位置并利用时序和可视性信息混合新旧数据，每一次混合中旧有的值可以占到 90% ~ 99.5% 的比例。 采样探针 这一步的效率极高，并且可以轻松结合入 forward 和 deferred 管线中，甚至可以应用于体积渲染和 Glossy 光线渲染中。这一步中的主要性能开销是 16 次纹理查询，但由于数据结构封装的高效性它们可以拥有很高的缓存命中率。 DDGI 主要的性能开销在前两部分，但它们可以独立于帧率和屏幕分辨率更新，这使得其开销可以简单地分摊到应用整体上。在 RTX2080 上，这种独立性会带来约 100ms 的间接光照更新延迟，这在大部分情况下都是难以察觉的；而对于低端的显卡，间接光照会存在更多的延迟，但对于静态场景而言其质量仍然十分突出。 在结合了 Glossy GI 后，一个使用 DDGI 技术的高端 GPU 可以得到和离线渲染相近的视觉效果，并且对于未来的 GPU 在层次结构、探针密度上均有有效的可拓展性。而对于低端的平台则可以通过禁用动态更新以获得和烘焙光照无异的优秀效果。","categories":[{"name":"programming","slug":"programming","permalink":"https://blog.apassbydreg.work/categories/programming/"},{"name":"reading notes","slug":"programming/reading-notes","permalink":"https://blog.apassbydreg.work/categories/programming/reading-notes/"}],"tags":[{"name":"CG","slug":"CG","permalink":"https://blog.apassbydreg.work/tags/CG/"},{"name":"render","slug":"render","permalink":"https://blog.apassbydreg.work/tags/render/"},{"name":"GDC talks","slug":"GDC-talks","permalink":"https://blog.apassbydreg.work/tags/GDC-talks/"}]},{"title":"《GPU Gem3》第十三章笔记 - 使用后处理的体积光散射 | Notes for GPU Gems 3 Chapter 13 - Volumetric Light Scattering as a Post-Process","slug":"GPUGems3-ch13","date":"2022-04-06T11:36:31.000Z","updated":"2022-04-06T11:48:53.652Z","comments":true,"path":"2022/04/GPUGems3-ch13/","link":"","permalink":"https://blog.apassbydreg.work/2022/04/GPUGems3-ch13/","excerpt":"","text":"本章提出了一种使用后处理方法的体积光散射效果。 缝隙光 当空气中具有了足够浓度得到气溶胶后，遮光物会投影下体积阴影，看起来像是有光线从光源发出一样。对这种效果的渲染最开始在离线领域中可以使用修改过的 SV 方法实现，接着应用于实时渲染中，然而这些方法均会受到实际采样率的影响。另一种实时的方法是使用多边形体积和 FBO blending 和深度剔除，或者厚度累加等方法计算光线。本文中提出了一种不需要预处理的逐像素后处理方法以实现高细节的动态光线投影。 体积散射 为了计算体积散射的效果，我们需要计算光源到像素位置的散射以及该位置是否被遮挡。其中体积散射对于太阳光线的解析模型如下： L(s,θ)=L0e−βexs+1βexEsun βsc(θ)(1−e−βexs)L(s, \\theta)=L_{0} e^{-\\beta_{ex} s}+\\frac{1}{\\beta_{\\mathrm{ex}}} E_{\\text {sun }} \\beta_{\\mathrm{sc}}(\\theta)\\left(1-e^{-\\beta_{ex} s}\\right) L(s,θ)=L0​e−βex​s+βex​1​Esun ​βsc​(θ)(1−e−βex​s) 式中的 sss 为在介质中穿过的距离，θ\\thetaθ 是光线的夹角大小，EsunE_{sun}Esun​ 是灯光发出的能量，βex\\beta_{ex}βex​ 是介质的消光常数，表示了吸收和外散射的效果，βsc\\beta_{sc}βsc​ 是角散射项。其中第一项代表了来自实际视点的光线的消光后的能量，第二项则描述了从其它方向散射到本方向的能量。 接着考虑实际空间中的点 ϕ\\phiϕ ，此时可以通过引入一个遮蔽项 D(ϕ)D(\\phi)D(ϕ) 描述能量的传输比例。 L(s,θ,ϕ)=(1−D(ϕ))L(s,θ)L(s,\\theta,\\phi) = (1 - D(\\phi))L(s,\\theta) L(s,θ,ϕ)=(1−D(ϕ))L(s,θ) 这一近似在当光源远比遮挡物的出射光亮时较为有效。虽然在屏幕空间中我们无法得到遮蔽项的解析解，但可以通过沿着屏幕空间中的光路进行采样来得到其近似解。因此有： L(s,θ,ϕ)=∑i=0nL(si,θi)nL(s, \\theta, \\phi)=\\sum_{i=0}^{n} \\frac{L\\left(s_{i}, \\theta_{i}\\right)}{n} L(s,θ,ϕ)=i=0∑n​nL(si​,θi​)​ 进一步地，在上式中引入控制参数： L(s,θ,ϕ)= exposure ×∑i=0n decay i× weight ×L(si,θi)nL(s, \\theta, \\phi)=\\text { exposure } \\times \\sum_{i=0}^{n} \\text { decay }{ }^{i} \\times \\text { weight } \\times \\frac{L\\left(s_{i}, \\theta_{i}\\right)}{n} L(s,θ,ϕ)= exposure ×i=0∑n​ decay i× weight ×nL(si​,θi​)​ 其中的 exposure 参数用于大范围地控制全局的亮度，weight 参数则用于细调亮度，一个指数衰减参数 decay 让光线可以自然地衰减。由于样本是直接从场景中获取的，对透明物体的处理天然地存在于流程中而无需额外计算。而多光源的情况也可以通过叠加数次场景采样 pass 而实现。 对于每个光源 sss 和每个像素位置 ϕ\\phiϕ ，会在光路上放置固定个采样点，此时引入了另一个参数 density 用于控制采样的距离占总长度的比例。这一值可以被用于在控制采样数的同时得到足够不走样的图像。 我们可以通过降采样原图来减少采样的次数。 后处理 Pixel Shader 本方法的核心就是下述的 Pixel Shader 。给定一张原始图片，会在各个像素上根据 density 生成到光源的屏幕位置的采样，这些采样会被 decay 和 weight 参数进行缩放作为效果的参数。而最终结果会被 exposure 参数调整亮度。 123456789101112131415161718192021222324252627float4 main(float2 texCoord : TEXCOORD0) : COLOR0 &#123; // Calculate vector from pixel to light source in screen space. half2 deltaTexCoord = (texCoord - ScreenLightPos.xy); // Divide by number of samples and scale by control factor. deltaTexCoord *= 1.0f / NUM_SAMPLES * Density; // Store initial sample. half3 color = tex2D(frameSampler, texCoord); // Set up illumination decay factor. half illuminationDecay = 1.0f; // Evaluate summation from Equation 3 NUM_SAMPLES iterations. for (int i = 0; i &lt; NUM_SAMPLES; i++) &#123; // Step sample location along ray. texCoord -= deltaTexCoord; // Retrieve sample at new location. half3 sample = tex2D(frameSampler, texCoord); // Apply sample attenuation scale/decay factors. sample *= illuminationDecay * Weight; // Accumulate combined color. color += sample; // Update exponential decay factor. illuminationDecay *= Decay; &#125; // Output final color with a further scale control factor. return float4( color * Exposure, 1); &#125; 屏幕空间遮蔽方法 在屏幕空间进行采样会受到物体的表面材质的影响而出现错误的条纹。下文提出了一系列方法以解决这一问题： 遮蔽 Pre-Pass 方法 这一方法通过实现将遮蔽物渲染为黑色，并在这一 FBO 上采样光线，最后将结果叠加到原图上从而得到想要的效果。下图 a 是无预处理的方法的效果，bcd 则展示了预处理的流程和结果。这一步预处理可以通过其他常规 pass 得到。 遮蔽模板剔除法 模板测试或 alpha 缓冲同样可以被用于实现类似的效果，天空区域在渲染的同时会额外设置一个模板 bit ，而遮挡物则没有。在应用后处理时读取本缓存就可以剔除掉遮挡物样本的影响了。 遮蔽对比方法 这一问题还可以通过降低材质的对比度来解决 额外说明 虽然这一方法可以得到优秀的结果，但它也并非毫无问题，例如背景物体投下的光束会渲染在前景物体的前方，而事实上它应该因为被前景物体所遮挡而变暗。 另一个问题在于当遮蔽物和光源在图像边界之外的时候，采样的结果会因为样本的越界而产生闪烁问题。常用的解决方法是在边界外侧额外渲染一部分遮挡物以增加可选用的样本域。 最终，当观察方向和光线方向接近垂直时，光源位置会趋近于无穷大，从而导致非常大的采样间隔。解决方法包括了将光源的屏幕空间坐标限制在有限的区域内，或是根据光线的角度减弱效果直至消失等。 拓展 一种优化方法是可以通过缩小采样的分辨率而降低对材质带宽的要求，并可以使用随机的采样来减少各类 artifacts 。齐次，本文中实现的是一种单 pass 的方法，而实际上各个像素完全可以在多个 pass 中利用光路上其它像素的采样结果来进一步减少采样的次数。最终，控制光幕的亮度和避免过饱和问题需要大量对消光系数的调整，通过使用解析方法找到图像中的平均和最大最小亮度值，进而对图像应用一个自适应的颜色映射可以有效避免图像的过亮或过暗。","categories":[],"tags":[]},{"title":"《游戏编程模式》第三章笔记 | Notes for Game Programming Patterns Chapter 03","slug":"GPP-ch03","date":"2022-03-19T16:31:26.000Z","updated":"2022-03-19T16:34:37.980Z","comments":true,"path":"2022/03/GPP-ch03/","link":"","permalink":"https://blog.apassbydreg.work/2022/03/GPP-ch03/","excerpt":"","text":"第三章：行为模式 本章的模式有助于快速定义和完善大量的行为。 类型对象定义行为的类别而无需完成真正的类。 子类沙箱定义各种行为的安全原语。 最先进的是字节码，它将行为从代码中分离，放入数据文件中。 字节码 子类沙箱 类型对象","categories":[{"name":"programming","slug":"programming","permalink":"https://blog.apassbydreg.work/categories/programming/"},{"name":"reading notes","slug":"programming/reading-notes","permalink":"https://blog.apassbydreg.work/categories/programming/reading-notes/"}],"tags":[{"name":"OOP","slug":"OOP","permalink":"https://blog.apassbydreg.work/tags/OOP/"},{"name":"Game Programming Patterns","slug":"Game-Programming-Patterns","permalink":"https://blog.apassbydreg.work/tags/Game-Programming-Patterns/"}]},{"title":"《GPU Gem3》第十二章笔记 - AO | Notes for GPU Gems 3 Chapter 12 - High-Quality Ambient Occlusion","slug":"GPUGems3-ch12","date":"2022-03-16T12:47:02.000Z","updated":"2022-03-16T16:18:30.507Z","comments":true,"path":"2022/03/GPUGems3-ch12/","link":"","permalink":"https://blog.apassbydreg.work/2022/03/GPUGems3-ch12/","excerpt":"","text":"早期算法 最开始的 AO 技术在多边形的顶点上使用 disk 近似相邻的多边形，接着将顶点周围的各个 disk 贡献的阴影累积到顶点上以近似 AO 。但这一做法忽略了可见性：被其他 disk 遮挡的 disk 不应该贡献 AO 。其中一种解决方法是以顶点的 occlusion 近似 visibility ，并迭代多次以使结果收敛。 这种算法的最大问题在于它 O(n2)O(n^2)O(n2) 的时间复杂度在实践中很难实现。Bunnell 等[2005]根据远处的 disk 的贡献较小而可以使用一个聚合体近似的观察设计了 disk 的层次树状结构，从顶至下近似的精度越来越高。这有效地将复杂度降低至 O(nlog⁡n)O(n\\log n)O(nlogn) ，进而可以实时地完成对可变形物体的 AO 计算。但这种方法也并非没有问题。 这种原始的算法可以较好地应用于拥有平滑的顶点 AO 过渡的几何体，以便可以在三角形上插值 AO 的影响，但高质量的渲染需要更加细粒度且更加复杂、不连续的 AO 计算。它无法模拟高频的接触阴影，会造成插值错误，还可能引入更多的 artifacts : Disk - Shaped Artifacts 上图中的 bunny 背部出现了圆形的错误，这些错误被称为 Disk - Shaped Artifacts ，它会导致画面上出现明显的圆形的亮暗分界线。这主要是在遍历树状结构时的离散估计操作导致的。 高频的挤压 Artifacts 上图右侧的模型上出现了很多高频的挤压阴影。当估计 disk 距离着色位置很近时，其贡献的阴影权重会大幅上升，导致其效果过大而产生此类阴影。 一种鲁棒的算法 本节中介绍了一种鲁棒的解决方法，它在基础算法结构之上做出了几个关键改变以提高效果。 平滑不连续位置 由于无法保证对父节点的影响一定等效于对子节点计算影响而引入的不连续分界面可以通过强制平滑转换而解决。通过在分界面边缘引入一段过渡区域，在区域内同时计算父子节点的影响，并使用距离插值从而获得平滑的边界过渡，其代码如下： 1234567891011121314151617181920// Compute shadow contribution from the current disk. float contribution = . . . // Stop or descend? if(d2 &lt; tooClose * (1.0 + r)) &#123; // Remember the parent&#x27;s contribution. parentContribution = contribution; // Remember the parent&#x27;s area. parentArea = area; // Compute parent&#x27;s weight: a simple linear blend. parentWeight = (d2 – (1.0 – r) * tooClose)/(2.0 * r * tooClose); // Traverse deeper into hierarchy. . . . &#125; else &#123; // Compute the children&#x27;s weight. childrenWeight = 1.0 – parentWeight; // Blend contribution: // Parent&#x27;s contribution is modulated by the ratio of the child&#x27;s area to its own. occlusion += childrenWeight * contribution; occlusion += parentWeight * parentContribution * (area/parentArea); &#125; 去除挤压并增加细节 原始的算法使用 disk 表示顶点附近的几何结构，但这一做法在顶点周围的误差会非常大，而对于大曲率的位置，其结果就是巨大的阴影值了。为了解决这一问题，可以将 disk 的位置移动到面片的中点，同时在计算最细粒度的结构时直接使用解析解而避免这一情况。 传统的全局光照技术早已对求解遮挡率的解析解有了研究：一个未被遮挡的几何体 AAA 对于法线为 nnn 的点 ppp 的遮挡率为： FpA=12π∑in⋅ei×vi∣ei×vi∣F_{pA} = {1 \\over 2\\pi}\\sum_i n\\cdot{e_i \\times v_i \\over |e_i \\times v_i|} FpA​=2π1​i∑​n⋅∣ei​×vi​∣ei​×vi​​ 在实际使用时，还需要使用由目标点和法线构成的切平面裁剪出可视的部分进行计算，最终的结果往往是一个 quad ： 123456789101112131415161718192021222324252627282930313233343536373839void visibleQuad(float3 p, float3 n, float3 v0, float3 v1, float3 v2, out float3 q0, out float3 q1, out float3 q2, out float3 q3) &#123; const float epsilon = 1e-6; float d = dot(n, p); // Compute the signed distances from the vertices to the plane. float sd[3]; sd[0] = dot(n, v0) – d; if(abs(sd[0]) &lt;= epsilon) sd[0] = 0.0; sd[1] = dot(n, v1) – d; if(abs(sd[1]) &lt;= epsilon) sd[1] = 0.0; sd[2] = dot(n, v2) – d; if(abs(sd[2]) &lt;= epsilon) sd[2] = 0.0; // Determine case. if(sd[0] &gt; 0.0) &#123; if(sd[1] &gt; 0.0) &#123; if(sd[2] &lt; 0.0) &#123; // v0, v1 above, v2 under q0 = v0; q1 = v1; // Evaluate ray-plane equations: q2 = v1 + (sd[1]/(sd[1] - sd[2])) * (v2 - v1); q3 = v0 + (sd[0]/(sd[0] - sd[2])) * (v2 - v0); &#125; else &#123; // v0, v1, v2 all above q0 = v0; q1 = v1; q2 = v2; q3 = q3; &#125; &#125; &#125; // Other cases similarly . . .&#125; 结果对比 渲染结果 可以看出，对于密集且平滑的 bunny 模型，旧有方法表现尚可，但对于具有很大的细节差异的汽车模型而言结果就不那么好了。 性能表现 上述两个场景的参数如下： n_triangles n_fragments n_disks bunny 69,451 381,046 138,901 car 29,304 395,613 58,607 性能如下： 在每个像素上使用鲁棒性算法的效率和在顶点上使用原有算法的性能相近，约比在像素上使用原有算法慢一倍出头。 注意事项 由于本算法本身仍然是一个近似算法，且无法完全地去除所有的不连续性，本文提出了数种方法辅助得到需要的艺术效果。 强制收敛 这种算法在估计 disk 的贡献时会使用一种迭代式的方法，但它在实践中并不一定会收敛，例如建筑场景往往会在两种过亮和过暗的场景之间反复切换。为了解决这一问题，本算法会在前数次迭代后将 AO 值限制为使用前两次迭代中较小的那个，或者在其中之间进行插值。代码和效果如下： 123456float o0 = texture2DRect(occlusion0, diskLocation).x; float o1 = texture2DRect(occlusion1, diskLocation).x; float m = min(o0, o1); float M = max(o0, o1); // weighted blend occlusion = minScale * m + maxScale * M; 可调参数 我们注意到，本算法常常倾向于过度估计 AO 的程度。我们需要一个函数以控制 AO 在不同距离处的衰减，让近处的投影物可以造成高对比度的影响，而远处的投影物又不至于完全遮蔽光源。此处引入了两个可调参数： 距离衰减 这个参数控制了随距离变化各类 disk 对 AO 贡献值大小的衰减： 1234// Compute the occlusion contribution from an element contribution = solidAngle(. . .); // Attenuate by distance contribution /= (1.0 + distanceAttenuation * e2); 三角形衰减 这个参数控制了在最细粒度下附近的三角形带来的遮蔽衰减： 123456// Get the triangle&#x27;s occlusion. float elementOcclusion = . . . // Compute the point-to-triangle form factor. contribution = computeFormFactor(. . .); // Modulate by its occlusion raised to a power. contribution *= pow(elementOcclusion, triangleAttenuation); 更小的参数可以强化细节三角形的影响，而更大的参数则会减弱大型三角形的影响，以防它们实际上被遮挡住了。 Future Work 本节提出了一种稳定的 GPU 加速算法以计算高质量的环境光遮蔽效果。更进一步地，这种算法并不只能用于环境光遮蔽的计算中，实际上他可以被用于计算间接光照，如次表面散射可以使用同样的层次结构加速计算。简单地修改代码和 disk 中储存的值即可得到计算多次散射的间接光照的方法： 1234567891011121314float3 multipleScattering(float d2, float3 zr, // Scattering parameters float3 zv, // defined in float3 sig_tr) // Jensen and Buhler 2002 &#123; float3 r2 = float3(d2, d2, d2); float3 dr1 = rsqrt(r2 + (zr * zr)); float3 dv1 = rsqrt(r2 + (zv * zv)); float3 C1 = zr * (sig_tr + dr1); float3 C2 = zv * (sig_tr + dv1); float3 dL = C1 * exp(-sig_tr/dr1) * dr1 * dr1; dL += C2 * exp(-sig_tr/dv1) * dv1 * dv1; return dL; &#125;","categories":[{"name":"programming","slug":"programming","permalink":"https://blog.apassbydreg.work/categories/programming/"},{"name":"reading notes","slug":"programming/reading-notes","permalink":"https://blog.apassbydreg.work/categories/programming/reading-notes/"}],"tags":[{"name":"CG","slug":"CG","permalink":"https://blog.apassbydreg.work/tags/CG/"},{"name":"render","slug":"render","permalink":"https://blog.apassbydreg.work/tags/render/"},{"name":"GPU Gems 3","slug":"GPU-Gems-3","permalink":"https://blog.apassbydreg.work/tags/GPU-Gems-3/"}]},{"title":"《游戏编程模式》第二章笔记 | Notes for Game Programming Patterns Chapter 02","slug":"GPP-ch02","date":"2022-03-15T12:46:55.000Z","updated":"2022-03-16T16:19:57.818Z","comments":true,"path":"2022/03/GPP-ch02/","link":"","permalink":"https://blog.apassbydreg.work/2022/03/GPP-ch02/","excerpt":"","text":"第二章：序列模式 大多数游戏世界都有的特性是时间——虚构世界以其特定的节奏运行。 作为世界的架构师，我们必须发明时间，制造推动游戏时间运作的齿轮。 本篇的模式是建构这些的工具。 游戏循环是时钟的中心轴。 对象通过更新方法来聆听时钟的滴答声。 我们可以用双缓冲模式存储快照来隐藏计算机的顺序执行，这样看起来世界可以进行同步更新。 双缓冲模式 游戏循环 更新方法","categories":[{"name":"programming","slug":"programming","permalink":"https://blog.apassbydreg.work/categories/programming/"},{"name":"reading notes","slug":"programming/reading-notes","permalink":"https://blog.apassbydreg.work/categories/programming/reading-notes/"}],"tags":[{"name":"OOP","slug":"OOP","permalink":"https://blog.apassbydreg.work/tags/OOP/"},{"name":"Game Programming Patterns","slug":"Game-Programming-Patterns","permalink":"https://blog.apassbydreg.work/tags/Game-Programming-Patterns/"}]},{"title":"《GPU Gem3》第十一章笔记 - Robust Shadow Volumes | Notes for GPU Gems 3 Chapter 11 - Efficient and Robust Shadow Volumes Using Hierarchical Occlusion Culling and Geometry Shaders","slug":"GPUGems3-ch11","date":"2022-03-10T12:46:38.000Z","updated":"2022-03-16T16:24:35.497Z","comments":true,"path":"2022/03/GPUGems3-ch11/","link":"","permalink":"https://blog.apassbydreg.work/2022/03/GPUGems3-ch11/","excerpt":"","text":"Shadow Map 和 Shadow Volume 是两种主流的阴影渲染方法。SM 可以很容易地用于实现软阴影，但会遇到走样的问题，SV 则可以以像素级别的精度渲染阴影，但无法很好地处理理想点光源和平行光以外的光源。 Shadow Volumes SV 的主要思想如下图所示，任何处在绿色区域的受光体均不应该被照亮，因此可以以不被照亮的形式渲染所有 SV 中的几何体，SV 外的几何体则需要计算光照。对于一根从视点出射的光线，每次当其进入 SV 时减一，离开时则加一，这样可以有效地找到 SV 内的像素。 Z-Pass 和 Z-Fail 为了得到这一值，我们不必进行光线追踪，而是可以利用现代 GPU 的模板测试功能。流程如下： 重置模板缓存为零 将 SV 的边界渲染到模板缓冲中，对于正向的几何体加一，对反向的几何体减一 这一 pass 最终可以得到一个包含了相交计数的模板缓存。非零值的部分即为阴影区域。在现代 GPU 上，体渲染通常可以使用双侧模板写入的方法在单个 pass 内实现。需要注意的是，在绘制 SV 前需要先把 zbuffer 填充为场景的深度，因为这一操作迟早会被渲染，因此这样做基本不会带来负担。这一操作又被称为 z-pass 。 与之相对的 z-fail 操作被提出以解决相机恰好处在 SV 内部的情况，它交换了加减的位置并允许模板缓冲在深度测试失败时被写入以解决这一问题。与 z-pass 不同的是，这一方法需要 SV 拥有闭合的背部从而在深度测试失败时也可以正常写入模板缓冲。 生成 Volume 下列描述了一种简单的 SV 生成方法，它不支持有洞、裂缝或自遮挡的几何体，对更复杂模式的介绍见下一节。 基本步骤 生成的过程主要分为三步： 渲染正面（即物体本身面对光源的面片） 渲染后面（即 SV 的远处面） 渲染投影物的拉伸剪影（即 SV 的侧面） 其中远处面使用一个投影到无限大的方法渲染和正面同样的面片，而拉伸剪影则将所有受光边缘投影到无限远从而形成一组组的 quad 而实现渲染。寿光边缘可以通过比较该条边两侧的三角形对光源的朝向得到。 在无限位置渲染 在 OpenGL 中，一个被投影到了无穷远处的顶点可以通过传入一个方向而不是坐标表示，方向和坐标可以使用齐次空间坐标的最后一个维度区分，方向的最后一个维度一般是 0 而坐标是 1 。在 SV 的情况下，这个方向是光源和顶点连线的方向。但这可能导致深度值的溢出，从而在渲染中被忽略。解决这一方法可以利用 NV_depth_clamp 扩展提供的功能，或将顶点按方向投影到远平面上解决。 性能优化 对于复杂的场景，渲染 SV 本身可能造成大量的性能损失。其中一个优化在于尽量使用 z-pass 而只在必要时切换到 z-fail 上。这是因为 z-pass 通常由于无需渲染前后侧和较小的填充面积而比 z-fail 快。这两种处理方式甚至可以在同一 pass 中被同时使用。填充面积通常是 SV 的最大性能瓶颈，因此进行体剔除、使用剪切测试或深度边界限制 SV 大小等方法同样可以提供性能优化。 来自 Mental Images 的实现 本节描述了来自 Mental Images 的 RealityServer 平台中稳定的模板阴影的实现方法。 稳定的低质量 Mesh 阴影 传统上的 SV 通常被用于游戏中，在这种情况下艺术家拥有对几何体的完全控制，从而可以保证几何体的有效性。但 RealityServer 平台通常需要处理低质量的 mesh ，如不闭合、自相交等问题都可能出现。 一种修改过的阴影体生成法 在这一实现中，为了支持非闭合或者存在自相交情况的 mesh ，算法需要在以下几个方面被进一步拓展： 挤压没有相邻几何体的受光的边缘，这使得单面的物体同样可以投影 对每个 SV 边界的边缘投影两次 这种方法等效于将所有三角形分为面向光源的和背向光源的两组，接着对两组几何体分别生成 SV 性能影响 这一操作会导致前后盖和边缘的渲染需求翻倍，虽然由于场景中需要使用 z-fail 的投影物体不多因此几乎不用考虑前后盖的问题，但翻倍的边缘仍然是一个大问题。为了避免在不必要的情况使用这种生成方式，在预处理阶段将会判断几何体是否需要被这种方法特殊处理。 除此之外，还有一些本方法没有覆盖到的特殊情况，如多个几何形状共用同一条边的情况。这些特例同样会在预处理阶段被转换为可以处理的形式。 使用 GS 动态生成 SV 计算边缘点是非常复杂且需要每帧更新的过程，利用 Geometry Shader 将其移动到 GPU 端计算是有必要的。在前盖上的 GS 只需要简单地输出其接收到的输入三角形即可，而在生成边界时则需要获取相邻的三角形信息，这需要在 glBegin 中设置为 GL_TRIANGLES_ADJACENCY_EXT 模式。此时输入的三角形序列如下图所示： 接收到上述的信息后，每组输入最多会抛出 3 + 3 + 4 * 3 个顶点作为输出。以下的代码输入在摄像机 eye space 的坐标下的顶点，输出对应的 SV 面片： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#version 120 #extension GL_EXT_geometry_shader4: enable uniform vec4 l_pos; // Light position (eye space) uniform int robust; // Robust generation needed? uniform int zpass; // Is it safe to do z-pass? void main() &#123; vec3 ns[3]; // Normals vec3 d[3]; // Directions toward light vec4 v[4]; // Temporary vertices vec4 or_pos[3] = &#123; // Triangle oriented toward light source gl_PositionIn[0], gl_PositionIn[2], gl_PositionIn[4] &#125;; // Compute normal at each vertex. ns[0] = cross( gl_PositionIn[2].xyz - gl_PositionIn[0].xyz, gl_PositionIn[4].xyz - gl_PositionIn[0].xyz ); ns[1] = cross( gl_PositionIn[4].xyz - gl_PositionIn[2].xyz, gl_PositionIn[0].xyz - gl_PositionIn[2].xyz ); ns[2] = cross( gl_PositionIn[0].xyz - gl_PositionIn[4].xyz, gl_PositionIn[2].xyz - gl_PositionIn[4].xyz ); // Compute direction from vertices to light. d[0] = l_pos.xyz-l_pos.w*gl_PositionIn[0].xyz; d[1] = l_pos.xyz-l_pos.w*gl_PositionIn[2].xyz; d[2] = l_pos.xyz-l_pos.w*gl_PositionIn[4].xyz; // Check if the main triangle faces the light. bool faces_light = true; if ( !(dot(ns[0],d[0])&gt;0 || dot(ns[1],d[1])&gt;0 || dot(ns[2],d[2])&gt;0) ) &#123; // Not facing the light and not robust, ignore. if ( robust == 0 ) return; // Flip vertex winding order in or_pos. or_pos[1] = gl_PositionIn[4]; or_pos[2] = gl_PositionIn[2]; faces_light = false; &#125; // Render caps. This is only needed for z-fail. if ( zpass == 0 ) &#123; // Near cap: simply render triangle. gl_Position = gl_ProjectionMatrix*or_pos[0]; EmitVertex(); gl_Position = gl_ProjectionMatrix*or_pos[1]; EmitVertex(); gl_Position = gl_ProjectionMatrix*or_pos[2]; EmitVertex(); EndPrimitive(); // Far cap: extrude positions to infinity. v[0] =vec4(l_pos.w*or_pos[0].xyz-l_pos.xyz,0); v[1] =vec4(l_pos.w*or_pos[2].xyz-l_pos.xyz,0); v[2] =vec4(l_pos.w*or_pos[1].xyz-l_pos.xyz,0); gl_Position = gl_ProjectionMatrix*v[0]; EmitVertex(); gl_Position = gl_ProjectionMatrix*v[1]; EmitVertex(); gl_Position = gl_ProjectionMatrix*v[2]; EmitVertex(); EndPrimitive(); &#125; // Loop over all edges and extrude if needed. for ( int i=0; i&lt;3; i++ ) &#123; // Compute indices of neighbor triangle. int v0 = i*2; int nb = (i*2+1); int v1 = (i*2+2) % 6; // Compute normals at vertices, the *exact* same way as done above! ns[0] = cross( gl_PositionIn[nb].xyz-gl_PositionIn[v0].xyz, gl_PositionIn[v1].xyz-gl_PositionIn[v0].xyz ); ns[1] = cross( gl_PositionIn[v1].xyz-gl_PositionIn[nb].xyz, gl_PositionIn[v0].xyz-gl_PositionIn[nb].xyz ); ns[2] = cross( gl_PositionIn[v0].xyz-gl_PositionIn[v1].xyz, gl_PositionIn[nb].xyz-gl_PositionIn[v1].xyz ); // Compute direction to light, again as above. d[0] =l_pos.xyz-l_pos.w*gl_PositionIn[v0].xyz; d[1] =l_pos.xyz-l_pos.w*gl_PositionIn[nb].xyz; d[2] =l_pos.xyz-l_pos.w*gl_PositionIn[v1].xyz; // Extrude the edge if it does not have a neighbor, or if it&#x27;s a possible silhouette. if ( gl_PositionIn[nb].w &lt; 1e-3 || (faces_light != (dot(ns[0],d[0])&gt;0 || dot(ns[1],d[1])&gt;0 || dot(ns[2],d[2])&gt;0) ) ) &#123; // Make sure sides are oriented correctly. int i0 = faces_light ? v0 : v1; int i1 = faces_light ? v1 : v0; v[0] = gl_PositionIn[i0]; v[1] = vec4(l_pos.w*gl_PositionIn[i0].xyz - l_pos.xyz, 0); v[2] = gl_PositionIn[i1]; v[3] = vec4(l_pos.w*gl_PositionIn[i1].xyz - l_pos.xyz, 0); // Emit a quad as a triangle strip. gl_Position = gl_ProjectionMatrix*v[0]; EmitVertex(); gl_Position = gl_ProjectionMatrix*v[1]; EmitVertex(); gl_Position = gl_ProjectionMatrix*v[2]; EmitVertex(); gl_Position = gl_ProjectionMatrix*v[3]; EmitVertex(); EndPrimitive(); &#125; &#125; &#125; 需要注意的是，为了使得退化的三角形在处理中被正确地剔除，上述的代码中会计算所有顶点位置处的法线以避免由于顶点选择次序造成的不一致。 使用层次遮挡剔除（Hierarchical Occlusion Culling）提高效率 对于大场景而言，将所有物体组织在一个层次加速结构中进行剔除可以有效提高效率，其中最简单快速的方法是 BVH 。实现 BVH 节点和视椎体的求交并不复杂，只需要使用视椎体对应的变换矩阵「渲染」一遍节点的 AABB 即可。 对 BVH 结构的遍历需要引入异步操作和时间同步的方法以减少开销。由于需要从 GPU 进行查询，会引入额外的通信时间，通常需要异步地同时查询多个节点以减少时间浪费在等待上。一般而言，上一帧中的遮挡信息可以提供一个有效的查询指引。 这种剔除方式的作用如下图所示： 由于第二个投影物的 SV 被前者本身完全遮挡了，后方的投影物无法投下任何可视的阴影，从而可以被安全地剔除出 SV 计算中。这实际上是在对投影物的 AABB 做简单的投影以进行剔除操作。 最终，当加速结构遍历到了一个叶子节点时，节点中的几何体将会被用于投影下完整的 SV 。 上述提到的裁剪方式无法在所有情况下都提供性能提升。对于较为简单的场景而言，使用这一方法甚至会导致性能的下降。一般而言，这种方法对于越大的场景效果就能越好。","categories":[{"name":"programming","slug":"programming","permalink":"https://blog.apassbydreg.work/categories/programming/"},{"name":"reading notes","slug":"programming/reading-notes","permalink":"https://blog.apassbydreg.work/categories/programming/reading-notes/"}],"tags":[{"name":"CG","slug":"CG","permalink":"https://blog.apassbydreg.work/tags/CG/"},{"name":"render","slug":"render","permalink":"https://blog.apassbydreg.work/tags/render/"},{"name":"GPU Gems 3","slug":"GPU-Gems-3","permalink":"https://blog.apassbydreg.work/tags/GPU-Gems-3/"}]},{"title":"《GPU Gem3》第十章笔记 - PSSM | Notes for GPU Gems 3 Chapter 10 - Parallel-Split Shadow Maps on Programmable GPUs","slug":"GPUGems3-ch10","date":"2022-03-09T13:25:47.000Z","updated":"2022-04-06T11:45:02.290Z","comments":true,"path":"2022/03/GPUGems3-ch10/","link":"","permalink":"https://blog.apassbydreg.work/2022/03/GPUGems3-ch10/","excerpt":"","text":"在这一技术中，视椎体被按照深度被平行于视平面的平面分割为多个深度层，每个深度层都会独立生成各自的 shadow map 。这一技术主要是为了提升 shadow map 在 view space 的采样频率，并与深度带来的采样频率变化所匹配。 PSSM 中的两个核心问题是： 如何选择分割的位置 如何平衡多pass和渲染阴影带来的性能损失 算法描述 PSSM 算法主要分为四步： 使用切割平面将视椎体分割为 m 份 为这些部分计算光源的 VP 矩阵 为这些部分以相同的分辨率 res 生成 PSSM 将阴影应用到场景中 第一步：分割视椎体 虽然可以让用户自定义分割方式，但此处使用的是论文中使用的 practical split scheme 方法。 Shadow Map 的走样 SM 上的单位纹素 ds 投影到视平面上的面积为 dp ，可以定义走样的误差： error=dpds=1tan⁡ϕ⋅dzzds⋅cos⁡ϕcos⁡θerror = {\\mathrm{d}p \\over \\mathrm{d}s} = {1 \\over \\tan\\phi}\\cdot{\\mathrm{d}z \\over z\\mathrm{d}s}\\cdot{\\cos\\phi\\over\\cos\\theta} error=dsdp​=tanϕ1​⋅zdsdz​⋅cosθcosϕ​ 这一公式可以被分解为透视走样 dzzds{\\mathrm{d}z \\over z\\mathrm{d}s}zdsdz​ 和投影走样 cos⁡ϕtan⁡ϕcos⁡θ{\\cos\\phi \\over \\tan\\phi\\cos\\theta}tanϕcosθcosϕ​ 两部分，其中后半部分对于任意固定的场景和投影矩阵而言可以被视为一个常数。为了减少走样的程度，通常会选择前者入手。 Practical Split Scheme 在这一分割方法中，分隔位置定义为： Ci=λCilog⁡+(1−λ)CiuniC_i = \\lambda C_i^{\\log} + (1 - \\lambda)C_i^{\\mathrm{uni}} Ci​=λCilog​+(1−λ)Ciuni​ 其中的 Clog,CuniC^{\\mathrm{log}}, C^{\\mathrm{uni}}Clog,Cuni 分别是基于对数和基于均匀分割方法的分割位置，这一方法使用了一个参数 λ\\lambdaλ 对这两种方法进行插值。 为了达到最优的透视走样分布，我们需要 dzzds{\\mathrm{d}z \\over z\\mathrm{d}s}zdsdz​ 项在整个深度区域内尽量为一个常值，即 dzzds=ρ\\frac{d z}{z d s}=\\rhozdsdz​=ρ 。此时 SM 的纹素长度 sss 到深度 zzz 的映射有： s(z)=∫0sds=1ρ∫nz1zdz=1ρln⁡(zn)s(z)=\\int_{0}^{s} d s=\\frac{1}{\\rho} \\int_{n}^{z} \\frac{1}{z} d z=\\frac{1}{\\rho} \\ln \\left(\\frac{z}{n}\\right) s(z)=∫0s​ds=ρ1​∫nz​z1​dz=ρ1​ln(nz​) 由于 s(f)=1s(f) = 1s(f)=1 ，易得 ρ=ln⁡(f/n)\\rho = \\ln(f / n)ρ=ln(f/n) 。我们会尽量让每个 SM 所对应的 sss 范围大小相同，因此对于一组 mmm 个分割平面有： si=s(Cilog⁡)=1ln⁡(f/n)ln⁡(Cilog⁡n)=imCilog=n(fn)i/ms_{i}=s\\left(C_{i}^{\\log }\\right)=\\frac{1}{\\ln (f / n)} \\ln \\left(\\frac{C_{i}^{\\log }}{n}\\right) = {i \\over m}\\\\ C_i^{\\mathrm{log}} = n\\left({f \\over n}\\right)^{i / m} si​=s(Cilog​)=ln(f/n)1​ln(nCilog​​)=mi​Cilog​=n(nf​)i/m 虽然基于对数的分割方法可以提供理论上最优的分割结果，但是在实践中靠近近平面的分割平面会非常接近彼此，从而在近平面附近产生过采样。 另一方面，均匀分割则直接按照深度均匀地放置分割平面： Ciuni=n+(f−n)imC_i^{\\mathrm{uni}} = n + (f - n) {i \\over m} Ciuni​=n+(f−n)mi​ 但这带来的走样实际上和同样分辨率下标准的 SM 并无差距。这一分割方法会在近平面附近造成欠采样，而在较远的部分造成过采样。 由于这两种分割方法均无法给出有效的分割，实际的实现中会用一个参数 λ\\lambdaλ 对这两者进行插值以权衡各自的优劣。 预处理 在分割视椎体之前，应该动态地调整摄像机的视椎体至恰好包含所有可视物体的设置，从而可以避免在近平面或远平面浪费采样。 第二步：计算光源的变换矩阵 和常规的 SM 相似，PSSM 也需要计算光源的 VP 矩阵以生成 SM 。由于我们将视椎体分为了多个子区域，我们需要对每一个子区域计算 VP 矩阵。主要的计算方法有两种： 和场景无关的方法直接取完整包含分割块的部分作为 VP 矩阵 通过引入场景信息，可以只包含可能向视椎体中投影的所有物体即可 与场景无关的投影 为了得到对应的投影矩阵，我们需要计算分割的视椎体 ViV_iVi​ 在光源裁剪空间内的 AABB 。需要注意的是，裁剪空间的 z 值会被设为 0 从而保证任何光源和视椎体之间的物体可以正常投影。样例代码如下： 1234567891011121314151617181920212223242526// Build a matrix for cropping light&#x27;s projection // Given vectors are in light&#x27;s clip space Matrix Light::CalculateCropMatrix(Frustum splitFrustum) &#123; Matrix lightViewProjMatrix = viewMatrix * projMatrix; // Find boundaries in light&#x27;s clip space BoundingBox cropBB = CreateAABB(splitFrustum.AABB, lightViewProjMatrix); // Use default near-plane value cropBB.min.z = 0.0f; // Create the crop matrix float scaleX, scaleY, scaleZ; float offsetX, offsetY, offsetZ; scaleX = 2.0f / (cropBB.max.x - cropBB.min.x); scaleY = 2.0f / (cropBB.max.y - cropBB.min.y); offsetX = -0.5f * (cropBB.max.x + cropBB.min.x) * scaleX; offsetY = -0.5f * (cropBB.max.y + cropBB.min.y) * scaleY; scaleZ = 1.0f / (cropBB.max.z - cropBB.min.z); offsetZ = -cropBB.min.z * scaleZ; return Matrix( scaleX, 0.0f, 0.0f, 0.0f, 0.0f, scaleY, 0.0f, 0.0f, 0.0f, 0.0f, scaleZ, 0.0f, offsetX, offsetY, offsetZ, 1.0f); &#125; 得到了裁剪矩阵后，对应的 VP 矩阵可以简单地写为：VP = lightViewMatrix * lightProjMatrix * cropMatrix 除了在裁剪空间计算切割矩阵以外，其实还可以在其它的空间中计算这一矩阵。但由于裁剪空间中所有的光线方向都统一为沿 z 轴，使得这种实现具有良好的统一性和直观性。 与场景相关的投影 将场景的几何条件加入考量可以进一步减少样本的浪费。在这一实现中，近平面被移动至恰好包含 ViV_iVi​ 或任意投影物体的位置，远平面可以被移动至恰好包含所有被投影物体的位置。xy 边界也同样可以根据投影和被投影物体而调整。样例代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546Matrix Light::CalculateCropMatrix(ObjectList casters, ObjectList receivers, Frustum frustum) &#123; // Bounding boxes BoundingBox receiverBB, casterBB, splitBB; Matrix lightViewProjMatrix = viewMatrix * projMatrix; // Merge all bounding boxes of casters into a bigger &quot;casterBB&quot;. for(int i = 0; i &lt; casters.size(); i++)&#123; BoundingBox bb = CreateAABB(casters[i]-&gt;AABB, lightViewProjMatrix); casterBB.Union(bb); &#125; // Merge all bounding boxes of receivers into a bigger &quot;receiverBB&quot;. for(int i = 0; i &lt; receivers.size(); i++)&#123; bb = CreateAABB(receivers[i]-&gt;AABB, lightViewProjMatrix); receiverBB.Union(bb); &#125; // Find the bounding box of the current split in the light&#x27;s clip space. splitBB = CreateAABB(splitFrustum.AABB, lightViewProjMatrix); // Scene-dependent bounding volume BoundingBox cropBB; cropBB.min.x = Max(Max(casterBB.min.x, receiverBB.min.x), splitBB.min.x); cropBB.max.x = Min(Min(casterBB.max.x, receiverBB.max.x), splitBB.max.x); cropBB.min.y = Max(Max(casterBB.min.y, receiverBB.min.y), splitBB.min.y); cropBB.max.y = Min(Min(casterBB.max.y, receiverBB.max.y), splitBB.max.y); cropBB.min.z = Min(casterBB.min.z, splitBB.min.z); cropBB.max.z = Min(receiverBB.max.z, splitBB.max.z); // Create the crop matrix. float scaleX, scaleY, scaleZ; float offsetX, offsetY, offsetZ; scaleX = 2.0f / (cropBB.max.x - cropBB.min.x); scaleY = 2.0f / (cropBB.max.y - cropBB.min.y); offsetX = -0.5f * (cropBB.max.x + cropBB.min.x) * scaleX; offsetY = -0.5f * (cropBB.max.y + cropBB.min.y) * scaleY; scaleZ = 1.0f / (cropBB.max.z – cropBB.min.z); offsetZ = -cropBB.min.z * scaleZ; return Matrix( scaleX, 0.0f, 0.0f, 0.0f, 0.0f, scaleY, 0.0f, 0.0f, 0.0f, 0.0f, scaleZ, 0.0f, offsetX, offsetY, offsetZ, 1.0f); &#125; 第三、四步：生成 PSSM 并合成阴影 根据硬件系统的不同，后两部分的实现可能各不相同。由于本算法使用了多个 SM ，在运行时需要更多的 pass 以生成它们。为了减小这一情况对渲染的压力，我们可以使用一种基于硬件的方法。主要的实现方法包括以下三种： 多 pass 方法：这种方法是最通用的，但也由于没有利用硬件的加速从而效率较低 利用 DX9 级别的硬件进行部分加速：这一方法可以去除生成阴影时需要的多 pass 利用 DX10 级别的硬件进行完全加速：利用 geometry shader 的 cloning 和 instancing 进一步加速 基于硬件的实现方法 上述三种主要的实现方法的渲染流程如下图所示： 第一个方法过于古老了不予讨论。 第二个方法属于常规的实现思路。 第三个方法通过引入 geometry shader 进一步加速 SM 的生成。GS 在 VS 后运行，对于每个几何体，输入其中的顶点并输出一系列新的几何体。DX10 同样支持了 Render Target Array ，这使得程序可以在 GS 输出的时候指定输出的目标 RT 。这些方法使得几何体可以被复制以用于多个 PSSM 中。 准备阶段 我们首先需要准备 m 个 SM 作为一个数组，每个 SM 均需要有对应的材质绑定。特别地，当 SM 访问超出边界时，需要设置一个常值作为边界颜色。创建的过程如下： 12345678910D3D10_TEXTURE2D_DESC DescTex = &#123;&#125;; DescTex.Width = shadowMapSize; DescTex.Height = shadowMapSize; DescTex.ArraySize = numSplits; DescTex.Format = DXGI_FORMAT_R32_TYPELESS; DescTex.Usage = D3D10_USAGE_DEFAULT; DescTex.BindFlags = D3D10_BIND_DEPTH_STENCIL | D3D10_BIND_SHADER_RESOURCE; DescTex.MipLevels = 1; DescTex.SampleDesc.Count = 1; device-&gt;CreateTexture2D(...)； 使用 DX10 中新引入的 Resource View 解释内容： 123456789101112D3D10_SHADER_RESOURCE_VIEW_DESC DescSRV = &#123;&#125;; DescSRV.Format = DXGI_FORMAT_R32_FLOAT; DescSRV.ViewDimension = D3D10_SRV_DIMENSION_TEXTURE2DARRAY; DescSRV.Texture2DArray.ArraySize = numSplits; DescSRV.Texture2DArray.MipLevels = 1; device-&gt;CreateShaderResourceView(...)D3D10_DEPTH_STENCIL_VIEW_DESC DescDSV = &#123;&#125;; DescDSV.Format = DXGI_FORMAT_D32_FLOAT; DescDSV.ViewDimension = D3D10_DSV_DIMENSION_TEXTURE2DARRAY; DescDSV.Texture2DArray.ArraySize = numSplits; device-&gt;CreateDepthStencilView(...); 就可以得到一组用于采样的 SM 了。我们不必创建 RT ，因为在此处我们唯一关心的只有深度值。下面的代码负责设置视口和 RT ： 123456789D3D10_VIEWPORT vp; vp.Width = shadowMapSize; vp.Height = shadowMapSize; vp.MinDepth = 0; vp.MaxDepth = 1; vp.TopLeftX = 0; vp.TopLeftY = 0; device-&gt;RSSetViewports(1, &amp;vp); device-&gt;OMSetRenderTargets(0, NULL, pDSV); 在找到了可能的投影物体之后，需要跟踪其 firstSplit 和 lastSplit 两个变量，这会用于确定该物体渲染的 SM 序列。我们同样需要保存裁剪矩阵的数组以在同一个 pass 中生成所有 SM 。 生成 Shadow Map 对于每一个投影物，需要遍历其占据的所有分割部分生成 SM 。下面给出了两种不同的方法以复制同一物体： 使用 GS 的 Cloning 技术 在这种方法中，可以使用 GS 将几何体的三角形提交到不同的 RT 中。 在这种方法下，VS 只需要负责将每个顶点转换到光源的裁剪空间内，这一步骤对于所有投影物都是一样的。接下来使用 GS 将三角形复制到具体的 RT 上并应用对应的裁剪变换。样例代码如下： 1234567891011121314151617181920212223// Geometry shader output structure struct GS_OUT &#123; float4 pos : SV_POSITION; uint RTIndex : SV_RenderTargetArrayIndex; &#125;; // Geometry shader [maxvertexcount(NUMSPLITS * 3)] void GS_RenderShadowMap(triangle VS_OUT In[3], inout TriangleStream&lt;GS_OUT&gt; triStream) &#123; // For each split to render for(int split = firstSplit; split &lt;= lastSplit; split++) &#123; GS_OUT Out; // Set render target index. Out.RTIndex = split; // For each vertex of triangle for(int vertex = 0; vertex &lt; 3; vertex++) &#123; // Transform vertex with split-specific crop matrix. Out.pos = mul(In[vertex].pos, cropMatrix[split]); // Append vertex to stream triStream.Append(Out); &#125; // Mark end of triangle triStream.RestartStrip(); &#125; &#125; 使用 Instancing 在支持 Instancing 的 DX10 中，VS 可以从 SV_InstanceID 获取当前的实例编号以应用不同的裁剪矩阵。在 CPU 侧只需要在 DrawIndexedInstanced() 设置实例数量即可。 其代码如下： 12345678910111213141516171819202122232425262728293031struct VS_IN &#123; float4 pos : POSITION; uint instance : SV_InstanceID; &#125;; struct VS_OUT &#123; float4 pos : POSITION; uint split : TEXTURE0; &#125;; VS_OUT VS_RenderShadowMap(VS_IN In) &#123; VS_OUT Out; // Transform with world/view/projection. Out.pos = mul(In.pos, ...); // Determine split index from instance ID. Out.split = firstSplit + In.instance; // Transform with split-specific crop matrix. Out.pos = mul(Out.pos, cropMatrix[Out.split]); return Out; &#125; [maxvertexcount(3)]void GS_RenderShadowMap(triangle VS_OUT In[3], inout TriangleStream&lt;GS_OUT&gt; triStream) &#123; GS_OUT Out; // Set render target index. Out.RTIndex = In[0].split; // Pass triangle through. Out.pos = In[0].pos; triStream.Append(Out); Out.pos = In[1].pos; triStream.Append(Out); Out.pos = In[2].pos; triStream.Append(Out); triStream.RestartStrip();&#125; 这一方法同样可以降低 API 开销，但其需要的计算次数其实是一样的。但这一方法可能可以因为不需要在 GS 中扩展大量数据而得到较高的效率。 上述两种方法甚至可以被同时使用，每种方法都用于处理一部分投影物。 合成阴影 这里的阴影判定和 DX9 的几乎一样，主要的区别在于采样材质数组的操作不同。最简单的方法是直接使用 SampleLevel() 从数组中采样材质。其中传入的第三个维度代表了材质位置。 虽然这种方法可以正常地得到需要的信息，但当需要做进一步的 PCF 处理时就不那么好用了，使用 HLSL4 提供的 SampleCmpLevelZero() 可以同时进行采样和比较。利用一个线性比较滤波器就可以得到 PCF 的结果。 不幸的是，这一函数无法应用于材质列表上。它实际上是用于 Cube Map 上的。我们可以通过使用 6 个分割平面创建一个 Cube Map 以绕过这个限制。需要的配置修改如下： 1234567// When creating the texture array DescTex.ArraySize = 6; DescTex.MiscFlags = D3D10_RESOURCE_MISC_TEXTURECUBE; . . . // When creating the shader resource view DescSRV.ViewDimension = D3D10_SRV_DIMENSION_TEXTURECUBE; DescSRV.TextureCube.MipLevels = 1; 下面的代码将采样材质的坐标转换为 Cube Map 坐标： 1234567float3 cubeCoord; if(split == 0) cubeCoord = float3(0.5, 0.5 - pos.y, 0.5 - pos.x); else if(split == 1) cubeCoord = float3(-0.5, 0.5 - pos.y, pos.x - 0.5); else if(split == 2) cubeCoord = float3(pos.x - 0.5, 0.5, pos.y - 0.5); else if(split == 3) cubeCoord = float3(pos.x - 0.5, -0.5, 0.5 - pos.y); else if(split == 4) cubeCoord = float3(pos.x - 0.5, 0.5 - pos.y, 0.5); else if(split == 5) cubeCoord = float3(0.5 - pos.x, 0.5 - pos.y, -0.5)； 下面的 PS 负责合成阴影： 123456789101112131415161718192021222324252627282930313233343536373839404142434445static const float3 offset[6] = &#123; float3(0.5, 0.5, 0.5), float3(-0.5, 0.5, -0.5), float3(-0.5, 0.5, -0.5), float3(-0.5, -0.5, 0.5), float3(-0.5, 0.5, 0.5), float3(0.5, 0.5, -0.5)&#125;; static const float3 mulX[6] = &#123; float3(0, 0, -1), float3(0, 0, 1), float3(1, 0, 0), float3(1, 0, 0), float3(1, 0, 0), float3(-1, 0, 0)&#125;; static const float3 mulY[6] = &#123; float3(0, -1, 0), float3(0, -1, 0), float3(0, 0, 1), float3(0, 0, -1), float3(0, -1, 0), float3(0, -1, 0)&#125;; SamplerComparisonState shadowMapSampler &#123; ComparisonFunc = Less; Filter = COMPARISON_MIN_MAG_LINEAR_MIP_POINT; &#125;; float4 PS_RenderShadows(PS_INPUT In) : SV_Target &#123; float light = 1.0f; for(int split = 0; split &lt; numSplits; split++) &#123; if(In.distance &gt; splitEnd[split]) &#123; float4 texpos = In.texturePos[split]; texpos.xyz /= texpos.w; // Cube map vector lookup float3 cubeCoord = offset[split] + mulX[split] * texpos.x + mulY[split] * texpos.y; // Don&#x27;t sample outside the border. if(min(pos.x, pos.y) &gt; 0 &amp;&amp; max(pos.x, pos.y) &lt; 1) &#123; light = shadowMapCube.SampleCmpLevelZero(shadowMapSampler, cubeCoord, texpos.z); &#125; break; &#125; &#125; return light; &#125; 考虑了处理额外边界条件的情况，这一方法比起采样材质序列减少了 25 条指令，但这会导致分割数目恒为 6 ，这在很多情况下都会浪费内存。 更多的优化 为了提高 PSSM 的阴影质量，还可以使用以下的方法： 滤波技术：使用 PCF，VSM 等方法对 SM 进行滤波以减少走样 打包材质：在材质采样器数量较少时，可以将不同的 SM 打包到一个材质内 结合不同的算法使用：一种有趣的分割算法的用途是在不同的分割内使用不同的 SM 方法，如 PSM，LiSPSM，TSM 等 可变的材质分辨率：在不同的分割内使用不同的分辨率以减少材质生成和储存的花费 在线性空间处理深度","categories":[{"name":"programming","slug":"programming","permalink":"https://blog.apassbydreg.work/categories/programming/"},{"name":"reading notes","slug":"programming/reading-notes","permalink":"https://blog.apassbydreg.work/categories/programming/reading-notes/"}],"tags":[{"name":"CG","slug":"CG","permalink":"https://blog.apassbydreg.work/tags/CG/"},{"name":"render","slug":"render","permalink":"https://blog.apassbydreg.work/tags/render/"},{"name":"GPU Gems 3","slug":"GPU-Gems-3","permalink":"https://blog.apassbydreg.work/tags/GPU-Gems-3/"}]},{"title":"《游戏编程模式》第一章笔记 | Notes for Game Programming Patterns Chapter 01","slug":"GPP-ch01","date":"2022-03-01T14:56:12.000Z","updated":"2022-03-01T15:03:40.116Z","comments":true,"path":"2022/03/GPP-ch01/","link":"","permalink":"https://blog.apassbydreg.work/2022/03/GPP-ch01/","excerpt":"","text":"第一章：重访设计模式 这一部分重新审视了《设计模式：可复用面向对象软件的基础》一书，从部分设计模式中提取出有趣的部分进行讲解： 命令模式 享元模式 观察者模式 原型模式 单例模式 状态模式","categories":[{"name":"programming","slug":"programming","permalink":"https://blog.apassbydreg.work/categories/programming/"},{"name":"reading notes","slug":"programming/reading-notes","permalink":"https://blog.apassbydreg.work/categories/programming/reading-notes/"}],"tags":[{"name":"OOP","slug":"OOP","permalink":"https://blog.apassbydreg.work/tags/OOP/"},{"name":"Game Programming Patterns","slug":"Game-Programming-Patterns","permalink":"https://blog.apassbydreg.work/tags/Game-Programming-Patterns/"}]},{"title":"《Physically Based Rendering 3rd ED》笔记合集 | Notes Collection for Physically Based Rendering 3rd ED","slug":"PBRT-Archive","date":"2022-02-18T10:46:37.000Z","updated":"2022-02-18T13:42:35.636Z","comments":true,"path":"2022/02/PBRT-Archive/","link":"","permalink":"https://blog.apassbydreg.work/2022/02/PBRT-Archive/","excerpt":"","text":"值此 Physically Based Rendering 第四版出版前夕，终于完成了对第三版的阅读，属实获益匪浅，同样这里做个笔记合集方便跳转： 章节目录 01 - Introduction 02 - Geometry and Transforms 03 - Shapes 04 - Primitives and Intersection Acceleration 05 - Color and Radiometry 06 - Camera Models 07 - Sampling and Reconstruction 08 - Reflection Models 09 - Materials 10 - Textures 11 - Volume Scattering 12 - Light Sources 13 - Monte Carlo Integration 14 - Light Transport I &gt; Surface Reflection 15 - Light Transport II &gt; Volume Rendering 16 - Light Transport III &gt; Bidirectional Methods 17 - Retrospective and The Future 相关资源 源码 书籍内容","categories":[{"name":"programming","slug":"programming","permalink":"https://blog.apassbydreg.work/categories/programming/"},{"name":"reading notes","slug":"programming/reading-notes","permalink":"https://blog.apassbydreg.work/categories/programming/reading-notes/"}],"tags":[{"name":"CG","slug":"CG","permalink":"https://blog.apassbydreg.work/tags/CG/"},{"name":"render","slug":"render","permalink":"https://blog.apassbydreg.work/tags/render/"},{"name":"PBRT","slug":"PBRT","permalink":"https://blog.apassbydreg.work/tags/PBRT/"}]},{"title":"PBRT 第十七章笔记 | Notes for PBRT Chapter 17 - Retrospective and The Future","slug":"PBRT-ch17","date":"2022-02-18T10:43:39.000Z","updated":"2022-02-18T10:47:52.204Z","comments":true,"path":"2022/02/PBRT-ch17/","link":"","permalink":"https://blog.apassbydreg.work/2022/02/PBRT-ch17/","excerpt":"","text":"17.1 Design Retrospective PBRT 在设计上的一个基础的假设在于：支持复杂和多样的场景、形状、材质、光源和采样算法具有非常高的重要性，且为了得到这样的效果，付出计算开销是值得的。这种假设的一个后果在于 PBRT 在简单场景的渲染效率上表现不佳。 一个例子是，在 PBRT 里确定表面的 BSDF 的过程比那些不需要对材质滤波或是计算光线微分的渲染流程而言更为费时。我们假设了这一做法可以在复杂场景和材质下有效地减少对相机光线的需求量，但对于简单场景而言抗锯齿通常并不是很严重的问题。另一方面，PBRT 中的很多采样算法假设了每个像素都要至少采样成百上千次以得到高品质的全局光照，在这种情况下，因为本来就已经采样了很多相机光线，对材质进行抗锯齿的操作带来的提升也有限。 另一方面，系统中的一些简化的接口也造成了不必要的重复工作。例如 Sampler 无论是否需要都会提供镜片位置和光线时间给相机，而相机无法告知采样器以避免这些开销。同样的，Integrator 也常常会抛弃没有被使用的采样序列。这主要是为了让读者能够更好地了解整个系统而设计的。 书中的练习中包括了一些重要的设计替代，即使你不打算实际上手实现它们，也应该至少读一读。 扎心了，大部分我都没看 17.1.1 Triangles Only 对不同几何体的支持给 PBRT 带来了不小的性能开销，它虽然看上去十分优雅，但在大部分实践的情况下都是不必要的。大部分实际使用的模型都是由三角形建模，或者用复杂的，难以实现光线相交算法的样条线等数学工具生成的，后者在渲染时常常会被转化为三角形表示。 只使用一种底层形状表示方法的好处有很多，包括了： 渲染器可以依赖于三角形顶点可以直接转换到世界坐标下，而无需进行到物体坐标系的转换 加速结构可以更加的专一化，让其中的节点直接储存对应的三角形而非整个几何体，这可以提高内存局部性，并避免多层虚函数的调用 displacement mapping 在这种情况下更容易实现 这些优势可以带来巨大的性能提升和复杂度降低，在生产用渲染器中是非常值得考虑的一点。 17.1.2 Increased Scene Complexity 给定一个构建好的加速结构，光线追踪的一个好处在于光线 - 物体相交的复杂度随场景复杂度的增长较为缓慢，这使得内存表现相对计算能力而言更容易影响渲染器的效率。由于光线会经过大量不同的区域，它并不是一个对虚拟内存或缓存的结构。 一种解决方案是减少内存的占用量，这需要对系统中的内存使用非常的小心。减少内存占用的方式包括了更紧凑的三角形表示、几何体和颜色压缩等等。 另一种更复杂的方法则是几何体缓存和光线优化。通过对几何体进行缓存并优化采样的顺序，也可以有效地提升效率。 17.1.3 Production Rendering 渲染用于电影的高品质图像也引入了一系列挑战，如极其复杂的场景和材质。大部分生产用的渲染器都具有对几何体和材质的延迟加载和缓存机制。可编程的表面着色器对于复杂材质的实现同样十分必要。 另一个时间上的挑战在于结合交互性的建模和着色工具。让艺术家可以快速地看到他们对场景的修改非常重要，这需要工具之间的的深度结合。 17.1.4 Specialized Compilation 2010 年提出的 OptiX 光线追踪渲染系统具有非常有趣的设计，它在内置的功能基础上可以被用户提供的代码进行拓展。很多近年的渲染器都允许经过插件等方法提供一定的用户拓展性，但 OptiX 特别在于它可以构建于一个运行时编译系统之上。由于编译器拥有对于整个系统的信息，产生的自定义渲染器可以快速且自动地专一应用于一系列内容中。 17.2 Alternative Hardware Architectures 本书主要以传统的多核 CPU 作为系统的目标架构，且并没有使用其中的 SIMD 功能。虽然其它更专一化的设备如 GPU 可以带来更多的性能提升，这些设备的特性会经常改变，且其编程语言和模型也较为小众。PBRT 3ed 并没有利用这些特性，但它们值得讨论。 早期的光线追踪主要关注于多处理器和渲染集群的工作，而最近计算性能的提升让关注的重点改变到 CPU 的 SIMD 和 GPU 上。 CPU 一种被设计为一个注重串行性能的处理器，随着可编程图像处理器的出现，流处理器在现代计算系统中正在变得越来越重要。这类处理器并不特别关注单线程的效率，而是注重多个并行线程的表现。这种特性让流处理器对缓存、分支预测的需求变低，从而可以在同样的芯片面积上提供更多的 ALU 用于计算。 SIMD 是流处理器的关键机制，现代 CPU 和 GPU 都有在其核心内拥有 SIMD 向量单元，而其中的核心和并行数量也正在随着时间迅速增长。 17.2.1 GPU Ray Tracing 在 GPU 上实现光线追踪面临着一系列挑战，包括加速结构的构建、计算的分散性和有限的局部内存。GPU 对数据局部性的要求很高，而加速结构常常通过一系列链接在内存中四处分散查找；且每条光线之间的计算内容也天差地别，并需要不小的内存以储存中间信息。 一种有趣的实现方法是使用一个光栅化渲染器和平行投影以跟踪光线，从而得到在一个方向上的可视化测试结果。虽然这种方法并不能提供有效的采样信息，但其性能提高可以在一定程度上弥补这一损失，但这一方法长远来看似乎不那么有可拓展性。 17.2.2 Packet Tracing 对于并行数据更少的情况，如 CPU 上的 SIMD ，可以通过机会主义地使用 SIMD 设备以提升一定的性能。如对 Spectrum 类型使用 SIMD 并行计算各个通道。这些优化有时可以通过编译器完成。 想要充分利用 SIMD 的向量单元需要整个计算过程被表示为并行的数据形式，相同的操作被应用于一系列数据上。光线追踪渲染器实现中的一种基础的实现数据并行的方法是称为 Packet Tracing ，它让设备同时跟踪 nnn 条光线。虽然 SIMD 使用率会很高，但这无法解决不同的光线需要不同的数据和计算的问题。 这种解决方案可以成功地实现高性能的 CPU 光线追踪渲染器，摄像机会同时生成一组 nnn 条光线，接着作为整体一起处理。加速结构被修改为如果任意光线与其相交都会测试其子几何体。这一方法被证明可以提供不小的性能提升，但其效果严重受限于光线之间的相关性。 Packet Tracing 在 CPU 上通常被显式地实现。相交函数会接受光线数量作为输入。与之相对的，对于流处理器的向量化操作通常是隐式的。代表通常被写做和接受单一数据输入，并被底层的编译器和硬件并行执行。 Reshetov 等人在 2005 年发表的论文中拓展了 Packet Tracing 方法，其中使用了锥体完成加速结构的遍历以提供高效的光线追踪。而后被 Reshetov 和 Benthin 与 Wald 等人进一步发展到剔除和阴影光线上。 虽然 Packet Tracing 对于一致性较好，即相交顺序相近的光线组合而言可以提供不错的效率，但对于全局光照中更常见的非一致性光线而言则不那么有效。一种解决方案是将 SIMD 应用于加速多个包围盒的相交计算中。另一种方法则是重新规划光线组以将具有一定相似性的光线放入一组后再进行计算。 Embree System 是一个同时支持高效单射线遍历和 Packet Tracing 的开源渲染系统，于 2014 年被 Wald 等人在论文中提出。 事实上，当一个渲染器可以同时提供大量需要相交测试的光线时，还可以使用很多其它高效的算法。Keller, Wächter 和 Mora 在 2011 年提出了一种可以对大量光线和无加速结构的场景进行高效相交的算法。这种算法同时对光线和几何体进行空间划分，直到子空间内只存在一小部分光线和几何体为止再执行相交测试。 17.2.3 Ray-Tracing Hardware 基于已经十分成功应用于光栅化的图形处理器，长久以来对光线追踪专用的计算硬件的关注一直不减。光线追踪本身具有大量的可定制的阶段可以被专用硬件加速。 早期的工作包括 Woop 等人 2005 年提出的 ray processing unit (RPU) 设计，更近一点地，Aila 和 Karras 于 2010 年提出了一种通用的架构以解决全局光照算法中不一致的光线。而后 Nah 、Lee 和 Doyle 等人还发表了一系列有关光线追踪的论文，其中描述了大量有关移动设备的光线追踪、结构遍历、光线生成、相交计算、光线排序、加速结构生成等等问题。 17.2.4 The Future 近年来，有关高性能图形架构的创新可能会越来越多。随着 CPU 逐渐增加其 SIMD 的宽度并加入更多处理核心，它们会变得越来越像流处理器，而流处理器则可能加入更多对任务并行和非一致性任务的支持。未来计算机系统会是由多种专一处理器构成还是说由一个通用处理器构成这一点仍然是一个开放的问题。 另一方面，专用图形硬件可能在未来变得更加重要，它们相比可编程的核心而言更加的高效、节能。随着计算流程的逐渐固化，固定功能的专用硬件可能会更加普遍。 17.3 Conclusion 这章作为结语就不记笔记了","categories":[{"name":"programming","slug":"programming","permalink":"https://blog.apassbydreg.work/categories/programming/"},{"name":"reading notes","slug":"programming/reading-notes","permalink":"https://blog.apassbydreg.work/categories/programming/reading-notes/"}],"tags":[{"name":"CG","slug":"CG","permalink":"https://blog.apassbydreg.work/tags/CG/"},{"name":"render","slug":"render","permalink":"https://blog.apassbydreg.work/tags/render/"},{"name":"PBRT","slug":"PBRT","permalink":"https://blog.apassbydreg.work/tags/PBRT/"}]},{"title":"PBRT 第十六章笔记 | Notes for PBRT Chapter 16 - Light Transport III > Bidirectional Methods","slug":"PBRT-ch16","date":"2022-02-15T09:29:46.000Z","updated":"2022-02-18T10:46:54.490Z","comments":true,"path":"2022/02/PBRT-ch16/","link":"","permalink":"https://blog.apassbydreg.work/2022/02/PBRT-ch16/","excerpt":"","text":"在之前所提到的渲染方法中，均只考虑了从摄像机出发的光线，并仅在路径的终点处尝试寻找光源。本章则要讨论从光源和摄像机双向同时采样路径的方法。这些采样方法可以比单向的算法更高效地收敛。 从光源和从摄像机出发的光线，基于光路的可逆性，在散射过程中的物理和数学表示有极高的一致性。另一方面，他们之间又存在微妙但重要的不同。本章会首先探讨这一基础，接着介绍光子映射算法、双向路径追踪算法，并最终利用 Metropolis 采样方法进一步加速采样。 16.1 The Path-Space Measurement Equation measurement equation（测量方程）描述了一种由积分一系列带有辐照度的光线得到的抽象的度量。例如在最简单的，最简化的成像模型中计算图像中的像素 jjj 的情况下，我们可以把该像素的值写成在图像平面上积分的如下形式： Ij=∫Afilm ∫S2We(j)(pfilm ,ω)Li(pfilm ,ω)∣cos⁡θ∣dωdA(pfilm )=∫Afilm ∫AWe(j)(p0→p1)L(p1→p0)G(p0↔p1)dA(p1)dA(p0)\\begin{aligned}I_{j} &amp;=\\int_{A_{\\text {film }}} \\int_{\\mathrm{S}^{2}} W_{\\mathrm{e}}^{(j)}\\left(\\mathrm{p}_{\\text {film }}, \\omega\\right) L_{\\mathrm{i}}\\left(\\mathrm{p}_{\\text {film }}, \\omega\\right)|\\cos \\theta| \\mathrm{d} \\omega \\mathrm{d} A\\left(\\mathrm{p}_{\\text {film }}\\right) \\\\&amp;=\\int_{A_{\\text {film }}} \\int_{A} W_{\\mathrm{e}}^{(j)}\\left(\\mathrm{p}_{0} \\rightarrow \\mathrm{p}_{1}\\right) L\\left(\\mathrm{p}_{1} \\rightarrow \\mathrm{p}_{0}\\right) G\\left(\\mathrm{p}_{0} \\leftrightarrow \\mathrm{p}_{1}\\right) \\mathrm{d} A\\left(\\mathrm{p}_{1}\\right) \\mathrm{d} A\\left(\\mathrm{p}_{0}\\right)\\end{aligned} Ij​​=∫Afilm ​​∫S2​We(j)​(pfilm ​,ω)Li​(pfilm ​,ω)∣cosθ∣dωdA(pfilm ​)=∫Afilm ​​∫A​We(j)​(p0​→p1​)L(p1​→p0​)G(p0​↔p1​)dA(p1​)dA(p0​)​ 其中 p0p_0p0​ 是胶片上的一点，We(j)(p0→p1)W_e^{(j)}(p_0 \\to p_1)We(j)​(p0​→p1​) 项则表示了像素的滤波函数和用于选择出射位置的函数的乘积（在此情况下，出射位置遵循 delta 分布）： We(j)(p0→p1)=fj(p0)δ(t(p0,ωcamera (p1))−p1)W_{\\mathrm{e}}^{(j)}\\left(\\mathrm{p}_{0} \\rightarrow \\mathrm{p}_{1}\\right)=f_{j}\\left(\\mathrm{p}_{0}\\right) \\delta\\left(t\\left(\\mathrm{p}_{0}, \\omega_{\\text {camera }}\\left(\\mathrm{p}_{1}\\right)\\right)-\\mathrm{p}_{1}\\right) We(j)​(p0​→p1​)=fj​(p0​)δ(t(p0​,ωcamera ​(p1​))−p1​) 接着展开光线传输的 LLL 项，有： Ij=∫Afilm∫AWe(j)(p0→p1)L(p1→p0)G(p0↔p1)dA(p1)dA(p0)=∑i∫A∫AWe(j)(p0→p1)P(p‾i)G(p0↔p1)dA(p1)dA(p0)=∑i∫A⋯∫A⏟i+1 times We(j)(p0→p1)T(p‾i)Le(pi+1→pi)G(p0↔p1)dA(pi+1)⋯dA(p0)\\begin{aligned}I_{j} &amp;=\\int_{A_{\\mathrm{film}}} &amp;\\int_{A} W_{\\mathrm{e}}^{(j)}\\left(\\mathrm{p}_{0} \\rightarrow \\mathrm{p}_{1}\\right) L\\left(\\mathrm{p}_{1} \\rightarrow \\mathrm{p}_{0}\\right) G\\left(\\mathrm{p}_{0} \\leftrightarrow \\mathrm{p}_{1}\\right) \\mathrm{d} A\\left(\\mathrm{p}_{1}\\right) \\mathrm{d} A\\left(\\mathrm{p}_{0}\\right) \\\\&amp;=\\sum_{i} &amp;\\int_{A} \\int_{A} W_{\\mathrm{e}}^{(j)}\\left(\\mathrm{p}_{0} \\rightarrow \\mathrm{p}_{1}\\right) P\\left(\\overline{\\mathrm{p}}_{i}\\right) G\\left(\\mathrm{p}_{0} \\leftrightarrow \\mathrm{p}_{1}\\right) \\mathrm{d} A\\left(\\mathrm{p}_{1}\\right) \\mathrm{d} A\\left(\\mathrm{p}_{0}\\right) \\\\&amp;=\\sum_{i} &amp;\\underbrace{\\int_{A} \\cdots \\int_{A}}_{i+1 \\text { times }} W_{\\mathrm{e}}^{(j)}\\left(\\mathrm{p}_{0} \\rightarrow \\mathrm{p}_{1}\\right) T\\left(\\overline{\\mathrm{p}}_{i}\\right) L_{\\mathrm{e}}\\left(\\mathrm{p}_{\\mathrm{i}+1} \\rightarrow \\mathrm{p}_{\\mathrm{i}}\\right) G\\left(\\mathrm{p}_{0} \\leftrightarrow \\mathrm{p}_{1}\\right) \\\\&amp;&amp;\\mathrm{d} A\\left(\\mathrm{p}_{\\mathrm{i}+1}\\right) \\cdots \\mathrm{d} A\\left(\\mathrm{p}_{0}\\right) \\end{aligned} Ij​​=∫Afilm​​=i∑​=i∑​​∫A​We(j)​(p0​→p1​)L(p1​→p0​)G(p0​↔p1​)dA(p1​)dA(p0​)∫A​∫A​We(j)​(p0​→p1​)P(p​i​)G(p0​↔p1​)dA(p1​)dA(p0​)i+1 times ∫A​⋯∫A​​​We(j)​(p0​→p1​)T(p​i​)Le​(pi+1​→pi​)G(p0​↔p1​)dA(pi+1​)⋯dA(p0​)​ 注意到此处的光线出射函数 LeL_eLe​ 和相机权重函数 WeW_eWe​ 同时出现在了同一个方程的乘积中，它们均不需要任何的特殊处理，也因此我们意识到这两者在数学上是可交换的。这意味着我们可以从两种不同的视角看待渲染过程：光线可以从光源出发，经过散射最终到底传感器，并使用 WeW_eWe​ 描述其贡献；或者也可以从摄像机出发，经过散射后到达光源位置，使用 LeL_eLe​ 描述其贡献。 简单地交换相机和光源的位置，我们就能得到一种称为 particle tracing （粒子跟踪）的方法。它从光源发射粒子，并递归地在场景中散射，计算到达传感器的量。虽然作为一种渲染方法而言它并不实用，但却是各类双向方法的重要组成部分。 式中的 WeW_eWe​ 描述了末段是 p1→p0p_1 \\to p_0p1​→p0​ 的光线对测量方程的重要性。包括图像生成在内的大部分测量方程都可以通过调整这一项得到对应的公式。 16.1.1 采样相机光线 双向光线传输算法需要可以在环境中任意点进行评估的重要性函数 WeW_eWe​ ，函数 Spectrum We(const Ray &amp;ray, Point2f *pRaster2) 函数通过传入一个光线以计算这一函数。第二个参数（如果提供了）则用于返回光栅位置。这一函数的默认实现会抛出一个错误，它仅在 PerspectiveCamera 类中有一个有效的重载。在这一函数中，会依次完成以下任务： 计算光线和摄像机朝向的夹角，检查光线是否和摄像机朝向一致 计算光栅位置，并按需写入参数指定的地址 对于采样区域外的位置，返回零值 计算重要性的函数值 PerspectiveCamera 类在定义上为了防止出现物理中的小孔成像的暗角问题，在 PDF 设计上加入了光线方向的影响。对于面积为 AAA 的成像平面，其 PDF 定义为： p(ω)=d2Acos⁡3θ, if ω is within frustum, else 0p(\\omega) = {d^2 \\over A\\cos^3\\theta} ,\\ \\mathrm{if \\ \\omega \\ is \\ within \\ frustum, \\ else \\ 0} p(ω)=Acos3θd2​, if ω is within frustum, else 0 更一般地，如果使用了非小孔的光圈，在 PDF 上还需要加上光圈上的采样位置的分布： p(ω)=d2Aπr2cos⁡4θ, if ω is within frustum, else 0p(\\omega) = {d^2 \\over A\\pi r^2\\cos^4\\theta} ,\\ \\mathrm{if \\ \\omega \\ is \\ within \\ frustum, \\ else \\ 0} p(ω)=Aπr2cos4θd2​, if ω is within frustum, else 0 当我们得到了这一分布函数后，对于 Camera::GenerateRay 函数就可以被改写为对应的重要性采样了。为此，一个计算方向和镜头光圈位置 PDF 的函数 Pdf_We 需要单独抽象出来。其计算过程和之前的重要性计算大同小异。最后一个统一的采样函数 Sample_Wi 和光源的 Sample_Li 相对应，它会根据给定的起始点，从镜头上采样一点以形成新的，并返回对应的 PDF 。 16.1.2 采样光源光线 对于双向光线传输而言，和 Camera::GenerateRay 类似地，还需要实现一个 Sample_Le 方法以完成对光源出射的射线的采样。该函数接收四个随机数，并返回采样光线、采样点的法线以及固体角和位置 PDF 。我们可以使用多重重要性采样的方法对它进行采样。除此之外，也有对应的返回两种 PDF 的 Pdf_Le 函数。 点光源 对点光源而言，直接均匀采样单位球面即可，其位置 PDF 为恒值 1 ，方向 PDF 同球面 PDF 。而给定光线计算 PDF 时，由于其 Delta 分布的特性，位置 PDF 为恒值 0。 聚光灯 和点光源类似，对于聚光灯而言只需要将均匀的球面采样替换为锥采样，并增加光线是否在锥内的判断即可。 面光源 由于 PBRT 中只考虑了漫反射的面光源，对这类光源进行采样的过程也相对简单。只需要先调用底层 Shape 的采样函数，接着对采样点的法线半球进行均匀采样即可。 方向光 回顾计算方向光的功率时的近似方法，对于方向光的采样，我们可以在场景的包围球的切面上均匀采样一点，并按光源方向生成光线。 环境光（Infinite Area Lights） 和方向光类似的，我们可以在场景的包围球上均匀（或重要性）采样一个方向，并发出光线。 16.1.3 非对称散射 在一些特殊的场景设置下，光线在部分材料上的散射行为是非对称的，如果不对这些情况进行特殊处理，双向光线传输算法就无法得到一致的结果。本节将简单地分析一系列可能导致非对称性的情况，并提出一些解决方案。 回顾 LTE 中的传输率项： T(p‾n)=∏i=1n−1f(pi+1→pi→pi−1)G(pi+1↔pi)T\\left(\\overline{\\mathrm{p}}_{n}\\right)=\\prod_{i=1}^{n-1} f\\left(\\mathrm{p}_{i+1} \\rightarrow \\mathrm{p}_{i} \\rightarrow \\mathrm{p}_{i-1}\\right) G\\left(\\mathrm{p}_{i+1} \\leftrightarrow \\mathrm{p}_{i}\\right) T(p​n​)=i=1∏n−1​f(pi+1​→pi​→pi−1​)G(pi+1​↔pi​) 此时我们引入伴随 BSDF ：f∗(p,ωo,ωi)=f(p,ωi,ωo)f^*(p, \\omega_o, \\omega_i) = f(p, \\omega_i, \\omega_o)f∗(p,ωo​,ωi​)=f(p,ωi​,ωo​)在 在 PBRT 中，大部分的 BSDF 均是对称的，即：f=f∗f = f^*f=f∗ 。但有关着色法线以及折射的过程需要额外的注意。枚举类 TransportMode 记录了当前的光线属性，它为表面提供了有关当前光线源头的信息，以便表面可以处理不同的情况。Importance 表示当前传输的是从光源发射的光线（接收 importance），Radiance 表示传输的是从相机发射的光线（接收 radiance ） 折射带来的非对称性 当光线从低 IOR 介质进入高 IOR 介质时，其能量会被压缩至更小的角度内。为此，光线的 radiance 会按比例增加： Li=ηi2ηt2LtL_i = \\frac{\\eta_i^2}{\\eta_t^2}L_t Li​=ηt2​ηi2​​Lt​ 我们因此有： f∗(p,ωo,ωi)=f(p,ωi,ωo)=ηt2ηi2f(p,ωo,ωi)f^{*}\\left(\\mathrm{p}, \\omega_{\\mathrm{o}}, \\omega_{\\mathrm{i}}\\right)=f\\left(\\mathrm{p}, \\omega_{\\mathrm{i}}, \\omega_{\\mathrm{o}}\\right)=\\frac{\\eta_{\\mathrm{t}}^{2}}{\\eta_{\\mathrm{i}}^{2}} f\\left(\\mathrm{p}, \\omega_{\\mathrm{o}}, \\omega_{\\mathrm{i}}\\right) f∗(p,ωo​,ωi​)=f(p,ωi​,ωo​)=ηi2​ηt2​​f(p,ωo​,ωi​) 因此，当我们追踪来自光源的光线时，需要额外地乘以对应系数。这一点在 SpecularTransmission 、FourierBSDF 和 SeperableBSSRFD 中均需要额外处理。 着色法线带来的非对称性 着色法线用另一个法线覆盖了几何体本身的法线，以提供更加平滑、细节的表面效果。这种改变会导致底层着色模型的改变，常常在会产生一个非对称的 BSDF ，最终造成一系列包括不连续的表面着色等问题。考虑原始的 LTE ： Lo(p,ωo)=Le(p,ωo)+∫S2f(p,ωo,ωi)Li(p,ωi)∣ng⋅ωi∣dωiL_{\\mathrm{o}}\\left(\\mathrm{p}, \\omega_{\\mathrm{o}}\\right)=L_{\\mathrm{e}}\\left(\\mathrm{p}, \\omega_{\\mathrm{o}}\\right)+\\int_{\\mathrm{S}^{2}} f\\left(\\mathrm{p}, \\omega_{\\mathrm{o}}, \\omega_{\\mathrm{i}}\\right) L_{\\mathrm{i}}\\left(\\mathrm{p}, \\omega_{\\mathrm{i}}\\right)\\left|\\mathbf{n}_{\\mathrm{g}} \\cdot \\omega_{\\mathrm{i}}\\right| \\mathrm{d} \\omega_{\\mathrm{i}} Lo​(p,ωo​)=Le​(p,ωo​)+∫S2​f(p,ωo​,ωi​)Li​(p,ωi​)∣ng​⋅ωi​∣dωi​ 其中的 cos⁡\\coscos 项以点乘的形式给出。为了加入表面法线的影响，我们将该项单独取出并入一个新的 BSDF ： fshade(p,ωo,ωi)=∣ns⋅ωi∣∣ng⋅ωi∣f(p,ωo,ωi)fshade∗(p,ωo,ωi)=∣ns⋅ωo∣∣ng⋅ωo∣f∗(p,ωo,ωi)f_{shade}(p, \\omega_o, \\omega_i) = {|\\mathbf{n}_s \\cdot \\omega_i| \\over |\\mathbf{n}_g \\cdot \\omega_i|} f(p, \\omega_o, \\omega_i)\\\\ f_{shade}^*(p, \\omega_o, \\omega_i) = {|\\mathbf{n}_s \\cdot \\omega_o| \\over |\\mathbf{n}_g \\cdot \\omega_o|} f^*(p, \\omega_o, \\omega_i) fshade​(p,ωo​,ωi​)=∣ng​⋅ωi​∣∣ns​⋅ωi​∣​f(p,ωo​,ωi​)fshade∗​(p,ωo​,ωi​)=∣ng​⋅ωo​∣∣ns​⋅ωo​∣​f∗(p,ωo​,ωi​) 结合二者的差距有： f∗(p,ωo,ωi)=∣ns⋅ωo∣∣ng⋅ωi∣∣ng⋅ωo∣∣ns⋅ωi∣f(p,ωo,ωi),while transporting importancef^*(p, \\omega_o, \\omega_i) = {|\\mathbf{n}_s \\cdot \\omega_o||\\mathbf{n}_g \\cdot \\omega_i| \\over |\\mathbf{n}_g \\cdot \\omega_o||\\mathbf{n}_s \\cdot \\omega_i|}f(p, \\omega_o, \\omega_i), \\mathrm{while \\ transporting \\ importance} f∗(p,ωo​,ωi​)=∣ng​⋅ωo​∣∣ns​⋅ωi​∣∣ns​⋅ωo​∣∣ng​⋅ωi​∣​f(p,ωo​,ωi​),while transporting importance 16.2 Stochastic Progressive Photon Mapping (SPPM) 光子映射是 particle tracing 算法中的一种，它从光源开始构建光路，并最终连接相机和路径中的顶点以计算最终的 radiance 。 16.2.1 理论基础 一个 particle tracing 算法会在场景中生成一组 NNN 个光照样本 (pj,ωj,βj)(p_j, \\omega_j, \\beta_j)(pj​,ωj​,βj​) 每个样本记录了来自方向 ωj\\omega_jωj​ 入射 pjp_jpj​ 的光线的传输率 βj\\beta_jβj​ 。 给定任意一个重要性函数 We(p,ω)W_e(p, \\omega)We​(p,ω) ，我们希望上述样本的传输量参数 β\\betaβ 满足： E[1N∑j=1NβjWe(pj,ωj)]=∫A∫S2We(p,ω)Li(p,ω)∣cos⁡θ∣dA dωE\\left[\\frac{1}{N} \\sum_{j=1}^{N} \\beta_{j} W_{\\mathrm{e}}\\left(\\mathrm{p}_{\\mathrm{j}}, \\omega_{\\mathrm{j}}\\right)\\right]=\\int_{A} \\int_{\\mathrm{S}^{2}} W_{\\mathrm{e}}(\\mathrm{p}, \\omega) L_{\\mathrm{i}}(\\mathrm{p}, \\omega)|\\cos \\theta| \\mathrm{d} A \\mathrm{~d} \\omega E[N1​j=1∑N​βj​We​(pj​,ωj​)]=∫A​∫S2​We​(p,ω)Li​(p,ω)∣cosθ∣dA dω 使用 p(pi,j)p(p_{i,j})p(pi,j​) 表示选取某点在面积上的概率，使用蒙特卡洛方法展开右式如下： E[1N∑i=1NWe(pi,0→pi,1){L(pi,1→pi,0)G(pi,0↔pi,1)p(pi,0)p(pi,1)}]E\\left[\\frac{1}{N} \\sum_{i=1}^{N} W_{\\mathrm{e}}\\left(\\mathrm{p}_{\\mathrm{i}, 0} \\rightarrow \\mathrm{p}_{\\mathrm{i}, 1}\\right)\\left\\{\\frac{L\\left(\\mathrm{p}_{\\mathrm{i}, 1} \\rightarrow \\mathrm{p}_{\\mathrm{i}, 0}\\right) G\\left(\\mathrm{p}_{\\mathrm{i}, 0} \\leftrightarrow \\mathrm{p}_{\\mathrm{i}, 1}\\right)}{p\\left(\\mathrm{p}_{\\mathrm{i}, 0}\\right) p\\left(\\mathrm{p}_{\\mathrm{i}, 1}\\right)}\\right\\}\\right] E[N1​i=1∑N​We​(pi,0​→pi,1​){p(pi,0​)p(pi,1​)L(pi,1​→pi,0​)G(pi,0​↔pi,1​)​}] 又因为 E[ab]=E[aE[b]]E[ab] = E[aE[b]]E[ab]=E[aE[b]] ，我们继续将右侧部分展开为长度为 nin_ini​ 的路径，并计入 Russian Roulette 终止概率 qi,jq_{i,j}qi,j​ 的影响，最后有： βi,j=Le(pi,ni→pi,ni−1)p(pi,ni)∏j=1ni−111−qi,jf(pi,j+1→pi,j→pi,j−1)G(pi,j+1↔pi,j)p(pi,j)\\beta_{i, j}=\\frac{L_{\\mathrm{e}}\\left(\\mathrm{p}_{\\mathrm{i}, \\mathrm{n}_{\\mathrm{i}}} \\rightarrow \\mathrm{p}_{\\mathrm{i}, \\mathrm{n}_{\\mathrm{i}}-1}\\right)}{p\\left(\\mathrm{p}_{\\mathrm{i}, \\mathrm{n}_{\\mathrm{i}}}\\right)} \\prod_{j=1}^{n_{i}-1} \\frac{1}{1-q_{i, j}} \\frac{f\\left(\\mathrm{p}_{\\mathrm{i}, \\mathrm{j}+1} \\rightarrow \\mathrm{p}_{\\mathrm{i}, \\mathrm{j}} \\rightarrow \\mathrm{p}_{\\mathrm{i}, \\mathrm{j}-1}\\right) G\\left(\\mathrm{p}_{\\mathrm{i}, \\mathrm{j}+1} \\leftrightarrow \\mathrm{p}_{\\mathrm{i}, \\mathrm{j}}\\right)}{p\\left(\\mathrm{p}_{\\mathrm{i}, \\mathrm{j}}\\right)} βi,j​=p(pi,ni​​)Le​(pi,ni​​→pi,ni​−1​)​j=1∏ni​−1​1−qi,j​1​p(pi,j​)f(pi,j+1​→pi,j​→pi,j−1​)G(pi,j+1​↔pi,j​)​ 虽然 particle tracing 允许我们以任何方法生成一系列的采样，但最常用的方式还是从光源出发跟随表面散射的规律跟踪并记录沿途的状态。特别地，如果我们只需要评估一种已知的重要性测量函数，我们完全可以更加智能地进行采样，这是因为在默认情况下我们常常会生成大量无效的样本。另一方面，如果我们需要同时计算多种测量函数，那 particle tracing 的优势就在于可以只生成一次样本并在各种情况下复用即可。 16.2.2 光子映射（Photon Mapping） 光子映射算法的基础在于追踪进入场景的粒子，并使用模糊后的贡献值以近似它们在着色点的光照。我们一般称这种算法出射的粒子是光子。 为了计算沿某个位置出射的 radiance ，我们有： ∫S2Li(p,ωi)f(p,ωo,ωi)∣cos⁡θi∣dωi=∫A∫S2δ(p−p′)Li(p′,ωi)f(p′,ω0,ωi)∣cos⁡θi∣dωidA(p′)\\begin{aligned}\\int_{\\mathrm{S}^{2}} &amp; L_{\\mathrm{i}}\\left(\\mathrm{p}, \\omega_{\\mathrm{i}}\\right) f\\left(\\mathrm{p}, \\omega_{\\mathrm{o}}, \\omega_{\\mathrm{i}}\\right)\\left|\\cos \\theta_{\\mathrm{i}}\\right| \\mathrm{d} \\omega_{\\mathrm{i}} \\\\&amp;=\\int_{A} \\int_{\\mathrm{S}^{2}} \\delta\\left(\\mathrm{p}-\\mathrm{p}^{\\prime}\\right) L_{\\mathrm{i}}\\left(\\mathrm{p}^{\\prime}, \\omega_{\\mathrm{i}}\\right) f\\left(\\mathrm{p}^{\\prime}, \\omega_{0}, \\omega_{\\mathrm{i}}\\right)\\left|\\cos \\theta_{\\mathrm{i}}\\right| \\mathrm{d} \\omega_{\\mathrm{i}} \\mathrm{d} A\\left(\\mathrm{p}^{\\prime}\\right)\\end{aligned} ∫S2​​Li​(p,ωi​)f(p,ωo​,ωi​)∣cosθi​∣dωi​=∫A​∫S2​δ(p−p′)Li​(p′,ωi​)f(p′,ω0​,ωi​)∣cosθi​∣dωi​dA(p′)​ 即： We(p′,ω)=δ(p′−p)f(p,ωo,ω)W_e(p&#x27;, \\omega) = \\delta(p&#x27; - p)f(p, \\omega_o, \\omega) We​(p′,ω)=δ(p′−p)f(p,ωo​,ω) 由于其中含有一个 delta 分布函数，在概率上任何记录的粒子位置对该方程的贡献应该均为零。这时我们需要引入一点的 bias 以得到一个有用的关于着色点光照情况的近似。由于临近位置的光照和着色点处的光照常常具有相似性，光子映射方法会使用周围最近的光子，使用滤波函数进行插值以近似着色点的光照信息。这种方法允许同一个光子在不同位置贡献信息，这也是光子映射方法效率的来源。这种方法同样可以用于得到一些难以通过增量的路径重建算法得到的光路。一个无法使用路径追踪 / 双向路径追踪方法采样的例子如下： 考虑使用小孔相机拍摄使用点光源照亮的由一层折射介质和一层漫反射材质组成的场景。由于介质的存在，路径追踪无法从该场景中得到任何关于漫反射表面的直接光照，而因为光源和玻璃的折射都是 delta 分布的关系，任何玻璃上的出射方向也无法得到光照。即使使用了面光源，该场景的 variance 仍然会十分高。 有了光子映射，我们可以从光源发出光子，让它们穿过介质落在漫反射表面上，接着从摄像机发出光线，在击中表面时收集光子以得到良好的结果。 统计学中的密度估计课题为光子映射提供了评估光子贡献的方法。使用一个核函数 ∫−∞∞k(x)dx=1\\int_{-\\infty}^{\\infty}k(x)\\mathrm{d}x = 1∫−∞∞​k(x)dx=1 ，我们可以估计采样点 xix_ixi​ 周围的 NNN 个样本： p^(x)=1Nh∑i=1Nk(x−xih)\\hat{p}(x) = {1 \\over Nh}\\sum_{i=1}^N k({x - x_i \\over h}) p^​(x)=Nh1​i=1∑N​k(hx−xi​​) 其中的 h 称为窗口宽度，它是一个可调参数，用于控制分布估计的平滑程度。一个密度估计的例子如下：蓝点为采样点，经过虚线表示的核函数 k(t)=max⁡(0,0.75∗(1−0.25t2)/5)k(t) = \\max(0, 0.75 * (1-0.25t^2) / \\sqrt{5})k(t)=max(0,0.75∗(1−0.25t2)/5​) 卷积后得到如图所示的估计。 这里的一个关键问题是 hhh 的取值。过大或过小的 hhh 都可能造成不同的问题。一种常用的方法是使用第 NNN 个最近的相邻样本的距离适应性地选择 hhh 的值，这样可以保证核函数的归一范围内永远有 NNN 个样本。即： p^(x)=1NdN(x)∑i=1Nk(x−xidN(x))\\hat{p}(x) = {1 \\over Nd_N(x)}\\sum_{i=1}^N k({x - x_i \\over d_N(x)}) p^​(x)=NdN​(x)1​i=1∑N​k(dN​(x)x−xi​​) 扩展到高维情况下： p^(x)=1N(dN(x))d∑i=1Nk(x−xidN(x))\\hat{p}(x) = {1 \\over N(d_N(x))^d}\\sum_{i=1}^N k({x - x_i \\over d_N(x)}) p^​(x)=N(dN​(x))d1​i=1∑N​k(dN​(x)x−xi​​) 使用这一近似方法带入出射辐照度的公式，既有： Lo(p,ωo)≈1NpdN(p)2∑jNpk(p−pjdN(p))βjf(p,ωo,ωj)L_{\\mathrm{o}}\\left(\\mathrm{p}, \\omega_{\\mathrm{o}}\\right) \\approx \\frac{1}{N_{\\mathrm{p}} d_{N}(\\mathrm{p})^{2}} \\sum_{j}^{N_{\\mathrm{p}}} k\\left(\\frac{\\mathrm{p}-\\mathrm{p}_{j}}{d_{N}(\\mathrm{p})}\\right) \\beta_{j} f\\left(\\mathrm{p}, \\omega_{\\mathrm{o}}, \\omega_{j}\\right) Lo​(p,ωo​)≈Np​dN​(p)21​j∑Np​​k(dN​(p)p−pj​​)βj​f(p,ωo​,ωj​) 这一方法引入的误差非常难以计算。一般而言，增加光子的数量通常都可以降低误差。具体到固定的位置，其误差往往和它附近光照变换的剧烈程度正相关。如果光子映射方法只用于间接光照，其带来的误差通常是可以接受的，因为间接光照大多都是低频的。 原始的光子映射算法基于两个步骤。光子首先被发射、跟踪、并记录在场景的表面上，储存在一个空间结构中（通常是 kd-tree ）；接着的第二个流程跟踪来自相机的光线，在路径上的每个位置统计周围的光子以得到简介光照。虽然这一方法是有效的，但它所能使用的光子数量受限于可用的内存。这是因为在第一个流程中的每一个光子都需要被储存下来，而与之相对的路径追踪在增加采样数时并不会增加任何空间开销。 Progressive Photon Mapping PPM 算法重构了光子映射的流程以解决这一问题：首先进行的相机 pass 向场景中追踪相机射线，在每个像素中储存所有非镜面的表面信息，这些信息被称为可视点（visible points）。接着的第二个 pass 则负责从光源跟踪光子，在每个光子与表面的作用位置向周围的可视点贡献照明。观察展开后的 LTE ： L(p,ωo)=Le(p,ωo)+∫S2f(p,ωo,ωi)L(p,ωi)∣cos⁡θi∣dωi=Le(p,ωo)+∫S2f(p,ωo,ωi)Ld(p,ωi)∣cos⁡θi∣dωi+∫S2f(p,ωo,ωi)Li(p,ωi)∣cos⁡θi∣dωi\\begin{aligned}L\\left(\\mathrm{p}, \\omega_{\\mathrm{o}}\\right) &amp;=L_{\\mathrm{e}}\\left(\\mathrm{p}, \\omega_{\\mathrm{o}}\\right)+\\int_{\\mathrm{S}^{2}} f\\left(\\mathrm{p}, \\omega_{\\mathrm{o}}, \\omega_{\\mathrm{i}}\\right) L\\left(\\mathrm{p}, \\omega_{\\mathrm{i}}\\right)\\left|\\cos \\theta_{\\mathrm{i}}\\right| \\mathrm{d} \\omega_{\\mathrm{i}} \\\\&amp;=L_{\\mathrm{e}}\\left(\\mathrm{p}, \\omega_{\\mathrm{o}}\\right)+\\int_{\\mathrm{S}^{2}} f\\left(\\mathrm{p}, \\omega_{\\mathrm{o}}, \\omega_{\\mathrm{i}}\\right) L_{\\mathrm{d}}\\left(\\mathrm{p}, \\omega_{\\mathrm{i}}\\right)\\left|\\cos \\theta_{\\mathrm{i}}\\right| \\mathrm{d} \\omega_{\\mathrm{i}} \\\\&amp;+\\int_{\\mathrm{S}^{2}} f\\left(\\mathrm{p}, \\omega_{\\mathrm{o}}, \\omega_{\\mathrm{i}}\\right) L_{\\mathrm{i}}\\left(\\mathrm{p}, \\omega_{\\mathrm{i}}\\right)\\left|\\cos \\theta_{\\mathrm{i}}\\right| \\mathrm{d} \\omega_{\\mathrm{i}}\\end{aligned} L(p,ωo​)​=Le​(p,ωo​)+∫S2​f(p,ωo​,ωi​)L(p,ωi​)∣cosθi​∣dωi​=Le​(p,ωo​)+∫S2​f(p,ωo​,ωi​)Ld​(p,ωi​)∣cosθi​∣dωi​+∫S2​f(p,ωo​,ωi​)Li​(p,ωi​)∣cosθi​∣dωi​​ 其中的 Le,LdL_e, L_dLe​,Ld​ 部分都比较任意获得，而简介光照部分则有两种不同的处理方法：要么和路径追踪一样发射一条新的光线递归地计算，要么利用周围的光子信息近似简介光照。对于完美镜面和高度光滑的表面，一般会选择继续进行光线追踪，而对于漫反射表面而言则一般会使用光子信息。但也有算法会选择额外进行一次漫反射弹射，这样虽然会需要更多的摄像机光线，但可以有效消除光子映射带来的视觉影响。这些方法一般被称为 final gathering 。 使用 PPM 可以消除光子的存储消耗，将储存负担放到了可视点的存储上，而可以不设限制地发射光子。但在图像分辨率较高或者需要引入运动模糊的情况下仍然可能受到内存的限制。 Stochastic Progressive Photon Mapping SPPM 在 PPM 的基础上作出了改进，使得光子映射算法不必受到相机光线采样的内存性能影响。和 PPM 一样，它会生成一系列的可视点记录，但不同的是每次生成的记录采样率都比较低，接着发射光子，记录数值，接着丢弃所有的现有采样点，重复这一步骤。 SPPM 对光子近似函数进行了两个修改，首先，它使用了一个固定的圆盘状核函数： Lo(p,ωo)≈1Npπr2∑jNpβjf(p,ωo,ωj)L_o(p,\\omega_o) \\approx {1 \\over N_p\\pi r^2}\\sum_j^{N_p}\\beta_j f(p,\\omega_o,\\omega_j) Lo​(p,ωo​)≈Np​πr21​j∑Np​​βj​f(p,ωo​,ωj​) 第二个改动会在各个迭代之间通过计算得到的光子数量调整每个像素对应的可视点的核函数的半径。当一个可视点接收到的光子数量足够多时，我们有理由相信该位置可以接收到足够的光子以支持更加细节的采样。更改核函数的半径需要修改 radiance 的计算过程，对每个像素维护一系列状态量，其更新的方式如下： Ni+1=Ni+γMiri+1=riNi+1Ni+Miτi+1=(τi+Φi)ri+12ri2\\begin{aligned}N_{i+1} &amp;=N_{i}+\\gamma M_{i} \\\\r_{i+1} &amp;=r_{i} \\sqrt{\\frac{N_{i+1}}{N_{i}+M_{i}}} \\\\\\tau_{i+1} &amp;=\\left(\\tau_{i}+\\Phi_{i}\\right) \\frac{r_{i+1}^{2}}{r_{i}^{2}}\\end{aligned} Ni+1​ri+1​τi+1​​=Ni​+γMi​=ri​Ni​+Mi​Ni+1​​​=(τi​+Φi​)ri2​ri+12​​​ 其中 NiN_iNi​ 是 iii 轮次后总的接收到的光子数量，MiM_iMi​ 是 iii 轮次中着色点接收到的光子数量，rir_iri​ 是 iii 轮次中使用的半径，τi\\tau_iτi​ 保存了光子的贡献值之和，并使用半径的平方缩放，Φi=∑jMiβjf(p,ωo,ωj)\\Phi_i = \\sum_j^{M_i}\\beta_jf(p,\\omega_o,\\omega_j)Φi​=∑jMi​​βj​f(p,ωo​,ωj​) 保存了该轮中的所有光子信息和 BSDF 的乘积之和。γ\\gammaγ 用于调整半径响应的速度，通常取 2/32/32/3 左右。 16.2.3 SPPMIntegrator SPPMIntegrator 不是一个 SamplerIntegrator ，因此它实现了自己的 Render() 方法。它会在初始化一系列相关变量后运行多次 SPPM 迭代。 SPPM 的像素数据储存在结构体 SPPMPixel 中，其中除了估计结果外还包含了一系列运行时变量和可视点的信息： 12345678910111213141516171819struct SPPMPixel &#123; Float radius = 0; Spectrum Ld; struct VisiblePoint &#123; // VisiblePoint Public Methods VisiblePoint() &#123;&#125; VisiblePoint(const Point3f &amp;p, const Vector3f &amp;wo, const BSDF *bsdf, const Spectrum &amp;beta) : p(p), wo(wo), bsdf(bsdf), beta(beta) &#123;&#125; Point3f p; Vector3f wo; const BSDF *bsdf = nullptr; Spectrum beta; &#125; vp; AtomicFloat Phi[Spectrum::nSamples]; std::atomic&lt;int&gt; M; Float N = 0; Spectrum tau;&#125;; 虽然我们可以通过生成带有不同权重的光子以加速收敛，但这在实现上较为复杂，且可能带来较为严重的视觉错误，因此一般的实现方法是生成空间上有一定分布的，权重相同的光子。我们一般会从更亮的光源发出更多的光子，更具体一点，会根据光源的功率按比例发射光子。 接着，PBRT 使用一个 HaltonSampler 生成相机光线，接着运行 SPPM 方法数轮以收集辐照度值。迭代的次数是由用户控制的。与路径追踪带来的噪声不同，采样不足的光子映射会产生点状的噪声。 和 SamplerIntegrator 相似，SPPMIntegrator 也将图像分割为 16 * 16 像素的子块并行地渲染。在完成一系列采样器设置、内存管理初始化后，会进入迭代环节，并按顺序完成以下环节： 生成 SPPM 可视点 跟踪光子并累积贡献度 更新像素值，并周期性地将中间结果保存下来 16.2.4 生成可视点 和路径追踪的过程相似，这一步中会记录直接光照 LdL_dLd​ ，并在第一个 diffuse 表面或最大深度位置的 glossy 表面生成可视点。可视点结构体记录了该位置的出射方向、BSDF、beta 值等一系列信息。 1234567struct VisiblePoint &#123; &lt;&lt;VisiblePoint Public Methods&gt;&gt; Point3f p; Vector3f wo; const BSDF *bsdf = nullptr; Spectrum beta;&#125; vp; 16.2.5 构建可视点网格结构 在生成了所有可视点后，为了让接下来的光子可以迅速找到临近的可视点，需要构建一个空间网格加速结构以加速这一过程。PBRT 的默认实现是使用一个均匀的网格覆盖所有可视点的 AABB ，每个网格内保存一个 SPPMPixel 的链表以表示可能产生影响的可视点（这是由于一个可视点可能覆盖多个网格，因此只储存指针即可）。由于整个网格中可视点的分布是十分稀疏的，可以使用一个最大 hashsize 为屏幕分辨率大小的哈希表来储存这些位置。 如果一个像素在当前迭代中没有生成可视点，那它的路径透过率 β=0\\beta = 0β=0 ，这可能是由于路径射出了场景，或者是因为它被各种原因终止了。这样的可视点将不会参与到网格的构建中。而对于其他像素，则会构建一个宽度为 rir_iri​ 的包围盒，并储存在与包围盒相交的网格体素中。因为每个可视点在不同轮次都可能有不同的搜索半径，如果我们只储存裸可视点而不将搜索半径计入考量，在计算时就会平添许多难度。 计算网格的顺序如下： 顺序遍历所有有效可视点，生成最小全覆盖网格的 AABB ，并记录最大搜索半径 生成边长约为最大搜索半径的方形网格 并行遍历所有有效可视点，将每个可视点按影响范围写入网格 由于对网格的操作是并行的，网格中的链表结构的操作需要是原子的。网格使用了一个基础的哈希函数，并且并不会处理冲突（两个冲突单元格的所有影响可视点会被合并为一个链表） 16.2.6 累积光子贡献 接下来的步骤是发射并跟踪光子的路程，这一步骤由多个进程并行运行，并使用一组和可视点生成不同的内存池。每次迭代中的光子数量的选择也是一个需要平衡的点，如果光子数量太多，那么一个像素的搜索半径无法有效地缩小，会在前期使用大量的过远的样本；反之则无法有效分摊前面步骤产生的额外开销，降低整体的效率。 为了生成分布更加均匀的采样，SPPM 使用 Halton 序列来生成光源的采样，并使用 Sample_Le 生成出射光线，其影响记为： β=∣cos⁡ω0∣Le(p0,ω0)p(light)p(p0,ω0)\\beta = {|\\cos\\omega_0|L_e(p_0,\\omega_0) \\over p(\\mathrm{light})p(p_0,\\omega_0)} β=p(light)p(p0​,ω0​)∣cosω0​∣Le​(p0​,ω0​)​ 接下来的过程就和路径追踪类似，跟踪光子进入场景进行弹射，每击中一点就通过查询网格找到对应的受影响可视点，并根据不断更新的 β\\betaβ 计算贡献度。需要注意的是，光子的第一次弹射位置不会记录贡献，这是因为它代表的直接光照已经在前面的过程中计入考虑了。 为了提高效率，PBRT 使用了一种新的 RR 光线终止方案，它使用新 beta 与旧 beta 的亮度值之比作为终止概率，这样做会在反射率低的表面以更低的概率发射出权重更高的光线。 最后，在该轮中所有光子均完成追踪后，各个像素的 radiance 估计可以使用上述公式更新。同时更新的还有 SPPMPixel 中的若干状态量，最终的亮度值计算方法为： L=Ld+τNpπr2L = L_d + {\\tau \\over N_p\\pi r^2} L=Ld​+Np​πr2τ​ 16.3 Bidirectional Path Tracing 在前文中提到的路径追踪方法是一个完全通用的光线追踪算法，它可以处理大量种类的几何体、光源和表面模型。然而在特别的场景设置下，这种算法的收敛速度可能会十分缓慢。例如下图中光源被几何体包裹而不可见的情况下，大多数光线都会浪费在无法找到光源之上。 复杂的光源可以通过从光路的两端同时发出光线而提高效率，这就是 BDPT 的启发。这一算法是传统路径追踪的推广，而且和 SPPM 不同的是，这是一种无偏的算法。 BDPT 基于从摄像机和光源两个位置生成两个子路径，接着连接路径的端点从而生成一个完整的路径。从表面上看，这一过程和光子映射中的两个步骤相似度极高，但这两种方法实际上在构建和处理光路上有着巨大的差别。 为了提高 BDPT 的效率，一系列的优化方法包括了： 重用子路径：给定一条光路 q0,q1,⋯ ,qs−1,pt−1,⋯ ,p1,p0q_0, q_1, \\cdots, q_{s-1}, p_{t-1}, \\cdots, p_1, p_0q0​,q1​,⋯,qs−1​,pt−1​,⋯,p1​,p0​ ，其中任意的子序列均可能构成新的有效光路。 抛弃可以使用直接光照或直接重要性传输快速求解的路径第一个节点带来的光照 使用不同的权重对使用不同策略生成的光路进行加权，对于同一条包含 nnn 次散射的光路而言，一共有 n+3n+3n+3 种不同的链接方法，其中部分策略可能比别的策略更加有效，这意味着 MIS 也可以被引入路径的构建中 和 SPPMIntegrator 一样，BDPTIntegrator 也直接继承自 Integrator 类。所有子路径生成均在 BDPTIntegrator::Render() 中经由一个嵌套循环完成，且过程也十分相似： 细分图像为 16×1616 \\times 1616×16 的子块 对每个子块生成内存管理模块和采样器 对于每个像素，重复采样直到 Sampler::StartNextSample() 返回 false 对于 BDPT 而言，最重要的一步就是生成一系列的路径，并在其中试图找到光源和相机之间的一条通路。Vertex 类型储存了一个路径上的顶点信息，包括了光源和摄像机本身。在渲染的过程中会申请两个 Vertex 数组以分布储存从摄像机出发和从光源出发的不同子路径。接着 GenerateCameraSubpath 和 GenerateLightSubpath 方法负责生成这两条子路径。在这之后，一个嵌套的双层循环会尝试连接这两条路径上的所有顶点对。 123456789101112131415161718192021Spectrum L(0.f);for (int t = 1; t &lt;= nCamera; ++t) &#123; for (int s = 0; s &lt;= nLight; ++s) &#123; int depth = t + s - 2; if ((s == 1 &amp;&amp; t == 1) || depth &lt; 0 || depth &gt; maxDepth) continue; // Execute the $(s, t)$ connection strategy and // update _L_ Point2f pFilmNew = pFilm; Float misWeight = 0.f; Spectrum Lpath = ConnectBDPT( scene, lightVertices, cameraVertices, s, t, *lightDistr, lightToIndex, *camera, *tileSampler, &amp;pFilmNew, &amp;misWeight); if (t != 1) L += Lpath; else film-&gt;AddSplat(pFilmNew, Lpath); &#125;&#125; 特别地，当 t=1t = 1t=1 时，由于光线直接入射摄像机，其像素位置很大可能会与当前像素不同，此时会使用 film-&gt;AddSplat(pFilmNew, Lpath); 解决这一问题。 16.3.1 Vertex 抽象层 路径空间的渲染算法的其中一个优势在于：路径生成的方式可以是十分自由的。但这一特点常常导致复杂且难以 debug 的实际实现。为了避免在核心代码中出现大量的条件判断语句，PBRT 定义了 Vertex 类型以表现路径上的任意一种顶点。 PBRT 中总共有 4 种路径顶点类型：enum class VertexType &#123; Camera, Light, Surface, Medium &#125;; 其中的 beta 成员与之前的 β\\betaβ 相似，包含了 BSDF 、phase function 、透射率、cos⁡\\coscos 项等内容在路径上的乘积。 在原有的表面和介质 Interaction 之外，BDPT 还拓展了 EndpointInteraction 以表示摄像机或灯光的一个位置。它在 Interaction 基础上增加了一个 union 以储存指向摄像机或光源的指针。而这个类型也和其它两种类型一并以一个 union 的形式储存在 Vertex 内。 此外，在 Vertex 中还保存了 delta 布尔值表示当前节点是否采样自一个 Dirac delta 分布。 该抽象层中保存的最后两个变量是用于 MIS 的概率密度 pdfFwd, pdfRev 。为了从多种采样方式中得到的路径获取其概率密度 ，PBRT 使用了路径上所有节点的面积概率密度的乘积作为路径的概率密度。上述的两个变量分布代表了从采样算法得到的概率密度和一个假设的，在逆向传输（即假设所属子路径的类型互换）时对应的概率密度。 除此之外，本类中还包含了一系列的工具函数，包括但不限于： 统一 BSDF 和 phase function 的传输函数 f 判断表面类型、是否可连接的一系列函数 IsOnSurface, IsLight, IsConnectable... 根据给定前后节点计算该次采样 PDF 的 Pdf 由于一个光源上的节点可能由直接采样或光线追踪生成，这种节点的 PDF 需要单独的方法计算（需要注意的是，只有从光源子路径的第一个节点才有 type == VertexType::Light ，这也是判断节点来源的根据）。特别地，对于光源的采样，我们还需要加入场景种所有的光源信息的考量。 16.3.2 生成子路径 子路径的生成由一对对称的函数 GenerateCameraSubpath() 和 GenerateLightSubpath() 完成。二者均会在初始化路径的第一个顶点后调用一个统一的次级函数 RandomWalk() 以采样接下来的路径顶点，最后返回子路径中实际的顶点数。 生成两对子路径时，首先由上级的函数调用 Camera::Sample_We, Light::Sample_Le 生成第一个采样，并初始化路径的端点。紧接着它们会将当前的光线方向、β\\betaβ 、方向立体角 PDF 和最大深度传入 RandomWalk 函数。 在 RandomWalk 函数中，pdfFwd, pdfRev 两个局部变量在每个光线追踪的迭代之间更新，它们满足以下情况： 在迭代开始时，pdfFwd 记录了当前的采样射线 ray.d 在立体角上的概率 pdfFwd 会在创建 Vertex 时被转换为单位平面上的概率储存在当前 Vertex::pdfFwd 中 在迭代结束时，pdfRev 记录了在已知新的出射方向时，将旧射线端点交换后得到的反向射线的立体角概率 pdfRev 会被转换并写入前一个节点的 Vertex::pdfRev 特别地，由于使用的 phase function 均是对称的，在计算 medium 散射时会有 pdfFwd = pdfRev ；另一方面，当遇到完全光滑的表面时，会有 pdfFwd = pdfRev = 0 。 16.3.3 连接子路径 ConnectBDPT 函数的作用是，输入两段子路径和 s, t 两个参数表示两侧分别选取的节点数，返回对应连接策略的贡献值。特别地，当 t = 1 即只使用一个摄像机节点时，对应的胶片位置会使用 pRaster 返回。 函数的主体包含了对各种情况的分类处理： 对于非法连接（连接灯光路径和摄像机路径中的灯光）直接返回零值 t == 1 时：忽略灯光路径信息，而使用和 PT 相同的直接光照估计方法计算 s == 0 时：将相机路径视为一个完整路径处理，返回相机路径最后一点的出射照度对整个路径的贡献 s == 1 时：在返回贡献的同时返回像素位置 在其它情况下，在测试连接性后，返回贡献度，其中使用 G(scene, sampler, qs, pt) 函数返回两点之间的几何项，公式如下： P^(q‾sp‾t)=LeT^(q‾s)[f^(qs−2→qs−1→pt−1)G^(qs−1↔pt−1)f^(qs−1→pt−1→pt−2)]T^(p‾t)We\\begin{array}{r}\\hat{P}\\left(\\overline{\\mathrm{q}}_{s} \\overline{\\mathrm{p}}_{t}\\right)=L_{\\mathrm{e}} \\hat{T}\\left(\\overline{\\mathrm{q}}_{s}\\right)\\left[\\hat{f}\\left(\\mathrm{q}_{s-2} \\rightarrow \\mathrm{q}_{s-1} \\rightarrow \\mathrm{p}_{t-1}\\right) \\hat{G}\\left(\\mathrm{q}_{s-1} \\leftrightarrow \\mathrm{p}_{\\mathrm{t}-1}\\right)\\right. \\\\\\left.\\hat{f}\\left(\\mathrm{q}_{s-1} \\rightarrow \\mathrm{p}_{t-1} \\rightarrow \\mathrm{p}_{t-2}\\right)\\right] \\hat{T}\\left(\\overline{\\mathrm{p}}_{t}\\right) W_{\\mathrm{e}}\\end{array} P^(q​s​p​t​)=Le​T^(q​s​)[f^​(qs−2​→qs−1​→pt−1​)G^(qs−1​↔pt−1​)f^​(qs−1​→pt−1​→pt−2​)]T^(p​t​)We​​ 16.3.4 MIS MIS 在 BDPT 中发挥了重要的作用，通过赋予不同的连接方式以不同的权重，这一方法可以大幅降低结果的方差。为了实现在路径上的 MIS ，我们需要一种方法以获知每一种路径各自的概率。这一步发生在 ConnectBDPT 函数的最后，它调用 MISWeight ，利用路径信息，特别是之前缓存的 pdfFwd, pdfRev ，以生成对应的概率。 下图对比了在不使用 MIS 的情况下，各个路径生成方式的结果差异： 下图展示了 MIS 的权重在不同路径设置下对画面内容的选择倾向，可以注意到这种方法有效地降低了低质量的路径的权重： 我们可以使用元组 (s,t)(s, t)(s,t) 表示当前的一种连接策略，它代表了长度为 n=s+tn = s + tn=s+t 的一条路径 xˉ\\bar{x}xˉ ： x‾=(x0,…,xn−1)=(q0,…,qs−1,pt−1,…,p0)\\overline{\\mathrm{x}}=\\left(\\mathrm{x}_{0}, \\ldots, \\mathrm{x}_{\\mathrm{n}-1}\\right)=\\left(\\mathrm{q}_{0}, \\ldots, \\mathrm{q}_{s-1}, \\mathrm{p}_{t-1}, \\ldots, \\mathrm{p}_{0}\\right) x=(x0​,…,xn−1​)=(q0​,…,qs−1​,pt−1​,…,p0​) 记每个节点上的两个方向概率密度为 p→(xi),p←(xi)p^{\\rightarrow}(x_i), p^{\\leftarrow}(x_i)p→(xi​),p←(xi​) ，则某一条路径的概率密度为： ps(x‾)=p→(x0)⋯p→(xS−1)⋅p←(xS)⋯p←(xn−1)p_{s}(\\overline{\\mathrm{x}})=p^{\\rightarrow}\\left(\\mathrm{x}_{0}\\right) \\cdots p^{\\rightarrow}\\left(\\mathrm{x}_{\\mathrm{S}-1}\\right) \\cdot p^{\\leftarrow}\\left(\\mathrm{x}_{\\mathrm{S}}\\right) \\cdots p^{\\leftarrow}\\left(\\mathrm{x}_{\\mathrm{n}-1}\\right) ps​(x)=p→(x0​)⋯p→(xS−1​)⋅p←(xS​)⋯p←(xn−1​) 上式中的概率值均储存在对应子路径节点中的 pdfFwd 中。 更一般地，我们同样关心该路径中不同的传输方式的概率值，我们枚举 sss 的值 iii ，有： pi(x‾)=p→(x0)⋯p→(xi−1)⋅p←(xi)⋯p←(xn−1), 0≤i≤np_{i}(\\overline{\\mathrm{x}})=p^{\\rightarrow}\\left(\\mathrm{x}_{0}\\right) \\cdots p^{\\rightarrow}\\left(\\mathrm{x}_{i-1}\\right) \\cdot p^{\\leftarrow}\\left(\\mathrm{x}_{i}\\right) \\cdots p^{\\leftarrow}\\left(\\mathrm{x}_{\\mathrm{n}-1}\\right), \\ 0 \\leq i \\leq n pi​(x)=p→(x0​)⋯p→(xi−1​)⋅p←(xi​)⋯p←(xn−1​), 0≤i≤n 最后，我们使用 MIS 中的平衡启发式权重（balance heuristic weight）为单一路径赋值，即： ws(x‾)=ps(x‾)∑ipi(x‾)w_{s}(\\overline{\\mathrm{x}})=\\frac{p_{s}(\\overline{\\mathrm{x}})}{\\sum_{i} p_{i}(\\overline{\\mathrm{x}})} ws​(x)=∑i​pi​(x)ps​(x)​ 上述的基本思想就是 MISWeight 函数中将要进行的主要计算，但在实现上这带来了两个问题： 路径密度函数很容易溢出浮点数的精度表示，它的精度要求会随着路径长度和场景复杂度指数增长 原始的 MIS 算法实现会花费相对最大路径长度而言 O(n4)O(n^4)O(n4) 的时间复杂度（计算单一概率、总概率和枚举两个路径参数分别会贡献 O(n)O(n)O(n) 的复杂度） 为了避免上述两个问题，实现中会采用一种增量式的方法。首先将分子直接除到分母上可得： ws(x‾)=1∑ipi(x‾)ps(x‾)=(∑i=0s−1pi(x‾)ps(x‾)+1+∑i=s+1npi(x‾)ps(x‾))−1w_{s}(\\overline{\\mathrm{x}})=\\frac{1}{\\sum_{i} \\frac{p_{i}(\\overline{\\mathrm{x}})}{p_{s}(\\overline{\\mathrm{x}})}}=\\left(\\sum_{i=0}^{s-1} \\frac{p_{i}(\\overline{\\mathrm{x}})}{p_{s}(\\overline{\\mathrm{x}})}+1+\\sum_{i=s+1}^{n} \\frac{p_{i}(\\overline{\\mathrm{x}})}{p_{s}(\\overline{\\mathrm{x}})}\\right)^{-1} ws​(x)=∑i​ps​(x)pi​(x)​1​=(i=0∑s−1​ps​(x)pi​(x)​+1+i=s+1∑n​ps​(x)pi​(x)​)−1 接着引入一个新变量 ri(xˉ)r_i(\\bar{x})ri​(xˉ) 表示上式中出现的比例式，我们可以得到一系列的递归定义： ri(x‾)=pi(x‾)ps(x‾)r_{i}(\\overline{\\mathrm{x}})=\\frac{p_{i}(\\overline{\\mathrm{x}})}{p_{s}(\\overline{\\mathrm{x}})} ri​(x)=ps​(x)pi​(x)​ ri(x‾)=pi(x‾)pi+1(x‾)pi+1(x‾)ps(x‾)=pi(x‾)pi+1(x‾)ri+1(x‾)(i&lt;s)ri(x‾)=pi(x‾)pi−1(x‾)pi−1(x‾)ps(x‾)=pi(x‾)pi−1(x‾)ri−1(x‾)(i&gt;s)\\begin{aligned}&amp;r_{i}(\\overline{\\mathrm{x}})=\\frac{p_{i}(\\overline{\\mathrm{x}})}{p_{i+1}(\\overline{\\mathrm{x}})} \\frac{p_{i+1}(\\overline{\\mathrm{x}})}{p_{s}(\\overline{\\mathrm{x}})}=\\frac{p_{i}(\\overline{\\mathrm{x}})}{p_{i+1}(\\overline{\\mathrm{x}})} r_{i+1}(\\overline{\\mathrm{x}}) \\quad(i&lt;s) \\\\&amp;r_{i}(\\overline{\\mathrm{x}})=\\frac{p_{i}(\\overline{\\mathrm{x}})}{p_{i-1}(\\overline{\\mathrm{x}})} \\frac{p_{i-1}(\\overline{\\mathrm{x}})}{p_{s}(\\overline{\\mathrm{x}})}=\\frac{p_{i}(\\overline{\\mathrm{x}})}{p_{i-1}(\\overline{\\mathrm{x}})} r_{i-1}(\\overline{\\mathrm{x}}) \\quad(i&gt;s)\\end{aligned} ​ri​(x)=pi+1​(x)pi​(x)​ps​(x)pi+1​(x)​=pi+1​(x)pi​(x)​ri+1​(x)(i&lt;s)ri​(x)=pi−1​(x)pi​(x)​ps​(x)pi−1​(x)​=pi−1​(x)pi​(x)​ri−1​(x)(i&gt;s)​ 将递归定义的递归系数展开，易得： pi(x‾)pi+1(x‾)=p→(x0)⋯p→(xi−1)⋅p←(xi)⋅p←(xi+1)⋯p←(xn−1)p→(x0)⋯p→(xi−1)⋅p→(xi)⋅p←(xi+1)⋯p←(xn−1)=p←(xi)p→(xi)pi(x‾)pi−1(x‾)=p→(x0)⋯p→(xi−2)⋅p→(xi−1)⋅p←(xi)⋯p←(xn−1)p→(x0)⋯p→(xi−2)⋅p←(xi−1)⋅p←(xi)⋯p←(xn−1)=p→(xi−1)p←(xi−1)\\begin{aligned}\\frac{p_{i}(\\overline{\\mathrm{x}})}{p_{i+1}(\\overline{\\mathrm{x}})} &amp;=\\frac{p^{\\rightarrow}\\left(\\mathrm{x}_{0}\\right) \\cdots p \\rightarrow\\left(\\mathrm{x}_{\\mathrm{i}-1}\\right) \\cdot p^{\\leftarrow}\\left(\\mathrm{x}_{\\mathrm{i}}\\right) \\cdot p^{\\leftarrow}\\left(\\mathrm{x}_{\\mathrm{i}+1}\\right) \\cdots p^{\\leftarrow}\\left(\\mathrm{x}_{\\mathrm{n}-1}\\right)}{p \\rightarrow\\left(\\mathrm{x}_{0}\\right) \\cdots p \\rightarrow\\left(\\mathrm{x}_{\\mathrm{i}-1}\\right) \\cdot p \\rightarrow\\left(\\mathrm{x}_{\\mathrm{i}}\\right) \\cdot p^{\\leftarrow}\\left(\\mathrm{x}_{\\mathrm{i}+1}\\right) \\cdots p^{\\leftarrow}\\left(\\mathrm{x}_{\\mathrm{n}-1}\\right)}=\\frac{p^{\\leftarrow}\\left(\\mathrm{x}_{\\mathrm{i}}\\right)}{p^{\\rightarrow}\\left(\\mathrm{x}_{\\mathrm{i}}\\right)} \\\\\\frac{p_{i}(\\overline{\\mathrm{x}})}{p_{\\mathrm{i}-1}(\\overline{\\mathrm{x}})} &amp;=\\frac{p^{\\rightarrow}\\left(\\mathrm{x}_{0}\\right) \\cdots p \\rightarrow\\left(\\mathrm{x}_{\\mathrm{i}-2}\\right) \\cdot p^{\\rightarrow}\\left(\\mathrm{x}_{\\mathrm{i}-1}\\right) \\cdot p^{\\leftarrow}\\left(\\mathrm{x}_{\\mathrm{i}}\\right) \\cdots p^{\\leftarrow}\\left(\\mathrm{x}_{\\mathrm{n}-1}\\right)}{p \\rightarrow\\left(\\mathrm{x}_{0}\\right) \\cdots p \\rightarrow\\left(\\mathrm{x}_{\\mathrm{i}-2}\\right) \\cdot p^{\\leftarrow}\\left(\\mathrm{x}_{\\mathrm{i}-1}\\right) \\cdot p^{\\leftarrow}\\left(\\mathrm{x}_{\\mathrm{i}}\\right) \\cdots p^{\\leftarrow}\\left(\\mathrm{x}_{\\mathrm{n}-1}\\right)}=\\frac{p^{\\rightarrow}\\left(\\mathrm{x}_{\\mathrm{i}-1}\\right)}{p^{\\leftarrow}\\left(\\mathrm{x}_{\\mathrm{i}-1}\\right)}\\end{aligned} pi+1​(x)pi​(x)​pi−1​(x)pi​(x)​​=p→(x0​)⋯p→(xi−1​)⋅p→(xi​)⋅p←(xi+1​)⋯p←(xn−1​)p→(x0​)⋯p→(xi−1​)⋅p←(xi​)⋅p←(xi+1​)⋯p←(xn−1​)​=p→(xi​)p←(xi​)​=p→(x0​)⋯p→(xi−2​)⋅p←(xi−1​)⋅p←(xi​)⋯p←(xn−1​)p→(x0​)⋯p→(xi−2​)⋅p→(xi−1​)⋅p←(xi​)⋯p←(xn−1​)​=p←(xi−1​)p→(xi−1​)​​ 即： ri(x‾)={1, if i=sp←(xi)p→(xi)ri+1(x‾), if i&lt;sp→(xi−1)p←(xi−1)ri−1(x‾), if i&gt;sr_{i}(\\overline{\\mathrm{x}})= \\begin{dcases}1, &amp; \\text { if } i=s \\\\ \\frac{p^{\\leftarrow}\\left(\\mathrm{x}_{\\mathrm{i}}\\right)}{p \\rightarrow\\left(\\mathrm{x}_{\\mathrm{i}}\\right)} r_{i+1}(\\overline{\\mathrm{x}}), &amp; \\text { if } i&lt;s \\\\ \\frac{p \\rightarrow\\left(\\mathrm{x}_{\\mathrm{i}-1}\\right)}{p^{\\leftarrow}\\left(\\mathrm{x}_{\\mathrm{i}-1}\\right)} &amp; r_{i-1}(\\overline{\\mathrm{x}}), &amp; \\text { if } i&gt;s\\end{dcases} ri​(x)=⎩⎪⎪⎪⎪⎨⎪⎪⎪⎪⎧​1,p→(xi​)p←(xi​)​ri+1​(x),p←(xi−1​)p→(xi−1​)​​ if i=s if i&lt;sri−1​(x),​ if i&gt;s​ 有了这个式子，我们就可以在 O(n)O(n)O(n) 的时间内完成单个路径的权值计算，从而将总复杂度降低至 O(n3)O(n^3)O(n3) ，并避免精度问题了。 需要特别注意的是，对于 Dirac delta 分布会出现的 0/00 / 00/0 的情况需要特殊处理为 111 。 对于路径端点的数据需要特殊处理，由于连接路径的变化，我们需要重新计算两条子路径的端点处的 PDF ，PBRT 引入了一个模板类 ScopedAssignment 在当前函数中暂时地修改路径端点的各个性质。这个类输入一个目标对象作为构造函数，在本类中保存一份快照，并在析构时将快照恢复。 总感觉这个类的设计充斥着各种潜在的坑…… 16.3.5 背景光源和 BDPT 背景光源在 PBRT 中作为从一个无限远、无限大的光源发出的光线，对基于面积概率的 BDPT 而言是一个异类。虽然我们可以将这类光源实现为一个包裹场景的球体发出的光线，但它在增大整体复杂度之外对于解决系统的其它部分没有任何作用。因此 PBRT 中选择了向 Vertex 抽象层中添加固体角概率的支持以解决这一问题。 回顾 RandomWalk 函数，在射线离开场景时，我们还需要额外记录一个光源节点以表示环境光。这一节点的 pdfFwd 中储存的是固体角概率。 这一光源节点的出现与后文中的连接策略结合，防止了向出射方向连接出不存在的路径。 除了出射场景的情况以外，我们还可能在采样光源的时候采样出一个背景光源，这一特殊情况将在 GenerateLightSubpath() 的末端特殊处理： 将路径后的第一个端点的 pdfFwd 使用背景光在场景包围球上的面积概率替换 重新计算光源端点的 pdfFwd 为所有背景光源的 pdf 之和 16.4 Metropolis Light Transport 1997 年，Veach 和 Guibas 提出了一种非常规的渲染方法，他们称之为 Metropolis Light Transport (MLT)，这种方法将 Metropolis-Hastings 采样算法应用于路径空间的采样之中，使得采样的样本在统计学上具有相关性。MLT 会在场景中生成一系列携带光照的路径，每个路径均由上一个路径衍生而来，并在统计上和各个路径的贡献度具有相同的概率。这种算法拥有极高的灵活性，由于其对演变方法的限制较少，它可以使用一些高度专一化的演变方法以采样对于传统 MC 方法而言难以采样的场景。 原始的 MLT 算法直接在路径空间的光线传输理论上进行构建，这带来了额外的实现挑战。这是因为路径空间不是完整的欧氏空间，一方面，路径的顶点会落在一系列 3D 空间的 2D 子集中，另一方面，平滑高光反射和折射也会进一步压缩空间自由度。原始的 MLT 构建了五种不同的演变策略以应对不同种类的光线路径类型。其中的三种表示了局部的探索以采样焦散或一系列复杂的平滑-漫反射-平滑表面序列；而另外两种则表现出更大的步长和更小的接受率。实现完整的 MLT 变换是巨大的工程量，其主要原因之一是它的变换没有一个是对称的。任意一个出现在系统中的小错误都可能导致微妙的收敛视觉错误，而且这些错误是臭名昭著地难以找出。 16.4.1 Primary Sample Space MLT（PSSMLT） 2002 年，Kelemen 等人提出了另一种名为 Primary Sample Space MLT (PSSMLT) 的同样基于 Metropolis-Hastings 采样算法的渲染技术。和原始的 MLT 不同，PSSMLT 并不直接使用路径空间，而是通过附加在 PT 或 BDPT 算法上间接地采样光线。这一做法主要的优势在于 PSSMLT 可以在欧氏空间中使用对称的转移策略，进而更容易被实现，但缺点在于这种算法缺乏对以构建光路的细节信息，从而难以构建和原始 MLT 相似的那种复杂的转移策略。 回顾此前 PT 的实现方法，我们使用程序生成的随机变量在各个路径位置采样光线。但倘若我们将随机变量作为一个额外的输入值传入 PathIntegrator::L() 中，我们就能得到一个确定性函数，其除了给定场景以外的另一组参数就是输入的随机值 [0,1)∞[0,1)^{\\infty}[0,1)∞ 。 有了这种让 LLL 作为一个在所有可能的采样序列上定义的 radiance 估计函数的解释，我们就可以在这个采样序列空间中使用 Metropolis-Hastings 算法，以返回的辐照度为对应的重要性权重进行采样。这种采样方法就被称为主采样空间（Primary Sample Space）。为了简洁，我们记采样序列 X=(X1,X2,⋯ )∈[0,1)∞X = (X_1, X_2, \\cdots) \\in [0,1)^\\inftyX=(X1​,X2​,⋯)∈[0,1)∞ PSSMLT 搜索 PSS 的主要转移策略有两种： 直接替代所有 XXX 的分量为新的随机生成的数值（大步长） 在各个采样值 XiX_iXi​ 上添加微小的扰动，一般是从以当前位置为中心的正态分布采样（小步长） 这两种策略均是对称的，因此它们的转移概率在计算时可以互相抵消。 由于 Metropolis-Hastings 采样和 Integrator 的接口只包含了对虚拟采样向量的改变，这使得它成为了一个非常一般性的方法。理论上 PSSMLT 可以增强任意一种基于蒙特卡洛采样的渲染方法。事实上，它甚至可以增强和渲染无关的蒙特卡洛方法。 在实践中，PSSMLT 一般实现于已有的 BDPT 之上，新的方法在每次迭代之间生成新的采样空间状态并传给 BDPT ，让它使用已有的方法连接路径并在路径之间进行 MIS 。但这也并非没有缺点，通常情况下只有一小部分连接方法是较为有效的，渲染器仍然会花费大量时间生成并评估低权重的光路。 16.4.2 Multiplexed MLT（MMLT） 2014 年 Hachisuka 等人提出了一种 PSSMLT 的改进算法 Multiplexed Metropolis Light Transport (MMLT) 以解决上述低权重光路的评估问题，MMLT 没有改变每次迭代外的 Metropolis-Hastings 算法过程，而是在 BDPT 的内部增加了细微但有效的改动。和原始 BDPT 中尝试创建所有的路径不同，MMLT 增加了一个随机变量用于选择需要连接的光路，并将该唯一光路的贡献除以其概率并返回。 为了避免不必要的结构性路径变化，Hachisuka 等人更改了马尔科夫链，从而使得该随机值只会在固定长度的光路中进行挑选，更一般性的光照传输则由多个独立的马尔科夫链共同完成。这种实践的结果使得采样器可以在有效的光路上花费更多时间，从而产生更大的 MIS 权重的贡献值。而每个独立的迭代也因此变得更快了。 下图从左到右展示了 PT ，BDPT 和 MMLT 在 San Miguel 场景，近似计算量下的视觉表现： 下表则对比了不同场景中三种不同的方法产生零 radiance 光路的比例： PT BDPT MMLT Modern House 98.0% 97.6% 51.9% San Miguel 95.9% 97.0% 62.0% 16.4.3 渲染中的应用 Metropolis 采样会从给定的标量函数中生成样本，为了将它应用于渲染中，需要解决两个问题： 我们需要对每个像素计算不同的积分以生成整个图片 我们需要处理的函数 LLL 是一个在光谱上有多个维度的函数而非标量函数 为了解决这一问题，我们首先需要定义一个图像贡献函数，它表示了一个具有 jjj 个像素的图像，每个像素都有一个值 IjI_jIj​ 以表示其在滤波函数 hjh_jhj​ 下重建的像素值： Ij=∫Ωhj(X)L(X)dΩI_j= \\int_\\Omega h_j(X)L(X)\\mathrm{d}\\Omega Ij​=∫Ω​hj​(X)L(X)dΩ 当有 NNN 个样本从某一分布中取出时，给出的蒙特卡洛估计为： Ij≈1N∑i=1Nhj(Xi)L(Xi)p(Xi)I_{j} \\approx \\frac{1}{N} \\sum_{i=1}^{N} \\frac{h_{j}\\left(X_{i}\\right) L\\left(X_{i}\\right)}{p\\left(X_{i}\\right)} Ij​≈N1​i=1∑N​p(Xi​)hj​(Xi​)L(Xi​)​ 由于函数 LLL 的光谱性质，我们需要一个标量贡献函数以应用 Metropolis 采样。一般而言，直接使用光谱的亮度值就是一个不错的选择。实际上使用任何当 LLL 非零时也非零的函数都可以生成正确的结果，只不过其有效性会有所区别。 给定一个标量贡献函数 C(X)C(X)C(X) ，Metropolis 采样会从其标准化分布中采样一系列样本： Xi∼p(X)=C(X)∫ΩC(X)dΩX_i \\sim p(X) = {C(X) \\over \\int_\\Omega C(X)\\mathrm{d}\\Omega} Xi​∼p(X)=∫Ω​C(X)dΩC(X)​ 其中的分母，归一化常数 b=∫ΩC(X)dΩb = \\int_\\Omega C(X)\\mathrm{d}\\Omegab=∫Ω​C(X)dΩ ，可以实现使用 BDPT 等方法预计算出来，最终每个采样对像素的贡献为： bNhj(Xi)L(Xi)C(Xi)\\frac{b}{N} \\frac{h_{j}\\left(\\mathbf{X}_{i}\\right) L\\left(\\mathbf{X}_{i}\\right)}{C\\left(\\mathbf{X}_{i}\\right)} Nb​C(Xi​)hj​(Xi​)L(Xi​)​ 16.4.4 Primary Sample Space Sampler MLTIntegrator 基于 BDPT 实现了 Metropolis 采样和 MMLT 方法以渲染图片。在介绍该类之前，我们首先需要引入 MLTSampler ，它负责了管理 PSS 的状态变量、变换以及接受 / 拒绝的步骤。 在采样时，函数 MLTSampler::StartIteration() 首先被调用以决定当前迭代中使用的是哪一类步长。MTLSampler::currentIteration 成员变量记录了当前的迭代轮数（被拒绝的采样不会计入），而 MLTSampler::lastLargeStepIteration 则记录了上一次大步长发生的位置。 MLTSampler::Accept() 则会在任意采样提议被接受时调用。 MLTSampler::EnsureReady() 实现了一种懒更新的机制，它会在每次获取值时调用，保证当前调取的值已经被更新。所有的采样值使用 PrimarySample 保存，它除了记录采样值外还额外记录了上一次采样值更新的时间以及一份额外的备份值和备份更新时间，当一个样本被拒绝时，MLTSampler::Reject() 会被调用以恢复所有当前轮次生成的备份值。。特别地，由于正态分布采样有可能采样到超出 [0,1)[0,1)[0,1) 范围的数值，在最后还需要将采样值 warp 回规定的范围内：Xi.value -= std::floor(Xi.value) 。 为了分割不同目的的采样，MLTSampler 没有将所有采样顺序储存，而是根据初始化时传入的分隔流的数量按交叉顺序储存各个目的的采样，MLTSampler::StartStream(), MLTSampler::GetNextIndex() 方法负责开始对特定流的采样和转换流位置和实际位置。 16.4.5 MLT Integrator 在拥有了以上内容后，我们就可以定义 MLTIntgrator 了。 MLTIntegrator::L() 首先定义的函数是 MLTIntegrator::L() ，它负责根据所给的采样样本生成对应的 radiance 。其中的参数 depth 表示了对应的路径长度，pRaster 则返回了对应的像素位置。 PBRT 的实现使用了三个 MLTSampler 中的样本流，前两个流用于相机和灯光路径采样，而最后一个则用于连接路径中可能出现的采样。 接着，本函数会首先利用深度和相机采样的第一个元素确定采样的路径长度，接着调用 BDPT 中的子路径生成函数，用对应的采样流生成子路径，最后使用连接函数返回估计的 radiance 。 MLTIntegrator::Render() 在主渲染循环中，有两个重要的阶段： 首先会生成一系列的初始采样来作为后续马尔科夫链的初始状态，这里的采样同时会被用于计算前文中的归一化常数 bbb 。 接下来则会从此前的初始状态中挑选并运行一系列马尔科夫链以应用 Metropolis 采样。 在第一个阶段中，MTLIntegrator 创建并采样了一个 nBootstrapSamples = nBootstrap * (maxDepth + 1) 长的一维分布，每个位置的概率密度和对应深度和初始状态所对应的亮度值成正比。接着在主渲染循环中，会从这一分布中采样出对应的初始状态，按照每个马尔科夫链平均可使用的变换次数进行数次变换。为了提高效率，此处会使用此前讨论过的将两个样本按接受率同时写入图像的优化方法。最后，所有数据会使用前述的常数缩放参数 b/Nb / Nb/N 缩放后写入图像。 与其它 Integrator 按图像区块划分并行不同的是，MTLIntegrator 会按样本数并行，每个线程执行固定数量的马尔科夫链。 有个小问题，在图片全域进行 MH 采样会导致较暗的像素欠采样吧……？","categories":[{"name":"programming","slug":"programming","permalink":"https://blog.apassbydreg.work/categories/programming/"},{"name":"reading notes","slug":"programming/reading-notes","permalink":"https://blog.apassbydreg.work/categories/programming/reading-notes/"}],"tags":[{"name":"CG","slug":"CG","permalink":"https://blog.apassbydreg.work/tags/CG/"},{"name":"render","slug":"render","permalink":"https://blog.apassbydreg.work/tags/render/"},{"name":"PBRT","slug":"PBRT","permalink":"https://blog.apassbydreg.work/tags/PBRT/"}]},{"title":"BSDF Lobe 可编程可视化工具 | BSDF Lobe Visualization","slug":"BSDF-Lobe-Visualization","date":"2022-01-10T16:32:28.000Z","updated":"2022-01-10T16:56:41.838Z","comments":true,"path":"2022/01/BSDF-Lobe-Visualization/","link":"","permalink":"https://blog.apassbydreg.work/2022/01/BSDF-Lobe-Visualization/","excerpt":"","text":"在某个寒冷的冬日，一个萌新正在读论文。就在此时，他看见了一个从来没有见过的 BSDF 定义： fr,s(θi,φi,θr,φr,λ)=132F(θi,λ)πcos⁡θi⋅exp⁡[−(4πσλcos⁡θi)2]+F(θi,λ)cos⁡θicos⁡θrπ3(aλ)2(σλ)2(cos⁡θi+cos⁡θr)4⋅exp⁡{−(πaλ)2[sin⁡2θi+sin⁡2θr+2sin⁡θisin⁡θrcos⁡(φi−φr)]}\\begin{aligned} f_{r, s}\\left(\\theta_{i}, \\varphi_{i}, \\theta_{r}, \\varphi_{r}, \\lambda\\right)=&amp;\\frac{132 F\\left(\\theta_{i}, \\lambda\\right)}{\\pi \\cos \\theta_{i}} \\cdot \\exp \\left[-\\left(4 \\pi \\frac{\\sigma}{\\lambda} \\cos \\theta_{i}\\right)^{2}\\right]+ \\\\ &amp;\\frac{F\\left(\\theta_{i}, \\lambda\\right)}{\\cos \\theta_{i} \\cos \\theta_{r}} \\pi^{3}\\left(\\frac{a}{\\lambda}\\right)^{2}\\left(\\frac{\\sigma}{\\lambda}\\right)^{2}\\left(\\cos \\theta_{i}+\\cos \\theta_{r}\\right)^{4}\\cdot \\\\ &amp; \\exp \\left\\{-\\left(\\frac{\\pi a}{\\lambda}\\right)^{2}\\left[\\sin ^{2} \\theta_{i}+\\sin ^{2} \\theta_{r}+2 \\sin \\theta_{i} \\sin \\theta_{r} \\cos \\left(\\varphi_{i}-\\varphi_{r}\\right)\\right]\\right\\} \\end{aligned} fr,s​(θi​,φi​,θr​,φr​,λ)=​πcosθi​132F(θi​,λ)​⋅exp[−(4πλσ​cosθi​)2]+cosθi​cosθr​F(θi​,λ)​π3(λa​)2(λσ​)2(cosθi​+cosθr​)4⋅exp{−(λπa​)2[sin2θi​+sin2θr​+2sinθi​sinθr​cos(φi​−φr​)]}​ 这玩意叫 Davies BRDF, 常用于卫星的光谱和光度信号仿真 小萌新一下子就蒙了，他不知道这个复杂又奇葩的 BRDF 到底描述了一个什么东西，为了解决这一问题（顺便逃避一下这个项目），他掏出曾经学过的 WEB 和可视化知识，摸鱼半日终于做出了一个简陋但可编程的 BSDF Lobe 可视化工具 简介 这么简单的玩意还有甚么介绍的必要吗，只要在右边填上你需要的变量和 BSDF 的计算方法（in JavaScript），最后按一下下面那个按钮不就完事了。 技术路线 （这点屁技术真的有人看得上吗） Vue：web 框架 Material Design Bootstrap：直接嫖的样式 Ace：代码高亮 ECharts / ECharts GL：无脑的可视化工具 说是 TODO 实际上做不做完全随缘的列表 [ ] 增加内置的 utils 函数 [ ] 增加一点 samples [ ] 改进 tooltip 的显示内容 相关链接 Demo: https://apassbydreg.github.io/BSDF_Lobe_Visualization/ Repository: https://github.com/APassbyDreg/BSDF_Lobe_Visualization 它甚至可以用简单的 iframe 嵌入别的网页呢 1&lt;iframe style=&quot;border: 0px; width:100%; height: 75vh;&quot; src=&quot;https://apassbydreg.github.io/BSDF_Lobe_Visualization/&quot;&gt;","categories":[{"name":"programming","slug":"programming","permalink":"https://blog.apassbydreg.work/categories/programming/"},{"name":"projects","slug":"programming/projects","permalink":"https://blog.apassbydreg.work/categories/programming/projects/"}],"tags":[{"name":"visualization","slug":"visualization","permalink":"https://blog.apassbydreg.work/tags/visualization/"},{"name":"web","slug":"web","permalink":"https://blog.apassbydreg.work/tags/web/"}]},{"title":"基于 Optix 的渲染器框架 v0.3 | Optix Based Renderer Framework v0.3","slug":"OptixBasedRendererFramework-v0-3","date":"2022-01-07T09:19:17.000Z","updated":"2022-02-26T02:44:27.275Z","comments":true,"path":"2022/01/OptixBasedRendererFramework-v0-3/","link":"","permalink":"https://blog.apassbydreg.work/2022/01/OptixBasedRendererFramework-v0-3/","excerpt":"","text":"简介 本项目是一个基于 Optix 7.3 的 GPU 光线追踪渲染框架，在保障了一定的可拓展性的同时，利用 NVIDIA 光线追踪技术提高了渲染的效率。 本页面仅为 v0.2 版本的介绍，旧版本介绍见此页面 渲染样例 包含了 GGX 材质、玻璃材质、以及参与介质的渲染结果 1000spp，512 * 512，耗时约 5 分钟 更新日志 增加了参与介质的渲染 从利用类似虚拟机制实现的 Mesh, Light, Material 等类型抽象出 VirtualProgramEntry 用于管理对象 重构了渲染管线，从递归式改为循环式 框架结构调整","categories":[{"name":"programming","slug":"programming","permalink":"https://blog.apassbydreg.work/categories/programming/"},{"name":"projects","slug":"programming/projects","permalink":"https://blog.apassbydreg.work/categories/programming/projects/"}],"tags":[{"name":"CG","slug":"CG","permalink":"https://blog.apassbydreg.work/tags/CG/"},{"name":"render","slug":"render","permalink":"https://blog.apassbydreg.work/tags/render/"},{"name":"OBR","slug":"OBR","permalink":"https://blog.apassbydreg.work/tags/OBR/"}]},{"title":"PBRT 第十五章笔记 | Notes for PBRT Chapter 15 - Light Transport II > Volume Rendering","slug":"PBRT-ch15","date":"2021-12-26T17:46:20.000Z","updated":"2022-02-15T09:41:41.312Z","comments":true,"path":"2021/12/PBRT-ch15/","link":"","permalink":"https://blog.apassbydreg.work/2021/12/PBRT-ch15/","excerpt":"","text":"15.1 The Equation of Transfer 传输函数是光线在介质中吸收、散射、发光的基本描述方程。它描述了光线在空间一点处沿某一方向出射的辐照度和其它各项的关系。 首先考虑 11 章中提到的散射函数： Ls(p,ω)=Le(p,ω)+σs(p,ω)∫S2p(p,ω,ω′)Li(p,ω′)dω′L_s(p,\\omega) = L_e(p,\\omega) + \\sigma_s(p,\\omega)\\int_{S^2}p(p,\\omega, \\omega&#x27;)L_i(p,\\omega&#x27;)\\mathrm{d}\\omega&#x27; Ls​(p,ω)=Le​(p,ω)+σs​(p,ω)∫S2​p(p,ω,ω′)Li​(p,ω′)dω′ 这一函数描述了光线在一点位置上的变化，结合光线在同一方向上的变化就有： ∂∂tLo(p′,ω)=−σt(p′,ω)Li(p′,−ω)+Ls(p′,ω)\\frac{\\partial}{\\partial t} L_{\\mathrm{o}}\\left(\\mathrm{p}^{\\prime}, \\omega\\right)=-\\sigma_{\\mathrm{t}}\\left(\\mathrm{p}^{\\prime}, \\omega\\right) L_{\\mathrm{i}}\\left(\\mathrm{p}^{\\prime},-\\omega\\right)+L_{\\mathrm{s}}\\left(\\mathrm{p}^{\\prime}, \\omega\\right) ∂t∂​Lo​(p′,ω)=−σt​(p′,ω)Li​(p′,−ω)+Ls​(p′,ω) 积分并将散射系数转换为透照率： Li(p,ω)=Tr(po→p)Lo(po,−ω)+∫0tTr(p′→p)Ls(p′,−ω)dt′L_i(p,\\omega) = T_r(p_o \\to p)L_o(p_o,-\\omega) + \\int_0^t T_r(p&#x27; \\to p)L_s(p&#x27;,-\\omega)\\mathrm{d}t&#x27; Li​(p,ω)=Tr​(po​→p)Lo​(po​,−ω)+∫0t​Tr​(p′→p)Ls​(p′,−ω)dt′ 15.1.1 推广至路径追踪方程 回顾路径追踪中单路径的贡献函数： P(p‾n)=∫A∫A⋯∫A⏟n−1Le(pn→pn−1)T(p‾n)dA(p2)⋯dA(pn)\\begin{aligned}P\\left(\\overline{\\mathrm{p}}_{n}\\right)=&amp; \\underbrace{\\int_{A} \\int_{A} \\cdots \\int_{A}}_{n-1} L_{\\mathrm{e}}\\left(\\mathrm{p}_{n} \\rightarrow \\mathrm{p}_{n-1}\\right) T(\\overline{p}_n)\\mathrm{d} A\\left(\\mathrm{p}_{2}\\right) \\cdots \\mathrm{d} A\\left(\\mathrm{p}_{n}\\right) \\end{aligned} P(p​n​)=​n−1∫A​∫A​⋯∫A​​​Le​(pn​→pn−1​)T(p​n​)dA(p2​)⋯dA(pn​)​ 其中透照率的定义： T(p‾n)=∏i=1n−1f(pi+1→pi→pi−1)G(pi+1↔pi)T\\left(\\overline{\\mathrm{p}}_{n}\\right)=\\prod_{i=1}^{n-1} f\\left(\\mathrm{p}_{i+1} \\rightarrow \\mathrm{p}_{i} \\rightarrow \\mathrm{p}_{i-1}\\right) G\\left(\\mathrm{p}_{i+1} \\leftrightarrow \\mathrm{p}_{i}\\right)T(p​n​)=i=1∏n−1​f(pi+1​→pi​→pi−1​)G(pi+1​↔pi​) 从前，路径追踪的路径节点只需要考虑在物体表面上的位置，但对于引入了参与介质的情况下，我们需要加入包含空间中任意的点的路径。我们在定义路径 PnP_nPn​ 的同时定义另一个数组 ccc 来记录该路径点是在空间中还是在物体表面上： Pnc=×i=1{A, if ci=0V, if ci=1Pn=⋃c∈{0,1}nPnc\\begin{gathered}\\mathrm{P}_{n}^{\\mathrm{c}}=\\underset{i=1}{\\times} \\begin{cases}A, &amp; \\text { if } \\mathbf{c}_{i}=0 \\\\V, &amp; \\text { if } \\mathbf{c}_{i}=1\\end{cases} \\\\\\mathrm{P}_{n}=\\bigcup_{\\mathbf{c} \\in\\{0,1\\}^{n}} \\mathrm{P}_{n}^{\\mathbf{c}} \\end{gathered} Pnc​=i=1×​{A,V,​ if ci​=0 if ci​=1​Pn​=c∈{0,1}n⋃​Pnc​​ 我们接着改写透照率的定义，这首先需要将定义在表面的 BSDF 扩展到空间中： f^(pi+1→pi→pi−1)={σsp(pi+1→pi→pi−1), if pi∈Vf(pi+1→pi→pi−1), if pi∈A\\begin{gathered}\\hat{f}\\left(\\mathrm{p}_{i+1} \\rightarrow \\mathrm{p}_{i} \\rightarrow \\mathrm{p}_{i-1}\\right)= \\begin{cases}\\sigma_{\\mathrm{s}} p\\left(\\mathrm{p}_{i+1} \\rightarrow \\mathrm{p}_{i} \\rightarrow \\mathrm{p}_{i-1}\\right), &amp; \\text { if } \\mathrm{p}_{\\mathrm{i}} \\in V \\\\f\\left(\\mathrm{p}_{i+1} \\rightarrow \\mathrm{p}_{i} \\rightarrow \\mathrm{p}_{i-1}\\right), &amp; \\text { if } \\mathrm{p}_{\\mathrm{i}} \\in A \\end{cases} \\end{gathered} f^​(pi+1​→pi​→pi−1​)={σs​p(pi+1​→pi​→pi−1​),f(pi+1​→pi​→pi−1​),​ if pi​∈V if pi​∈A​​ 接着改写对应的 GGG 项，同时引入透照度，并在空间位置不考虑由面积微分转换的影响有： G^(p↔p′)=V(p↔p′)Tr(p→p′)Cp(p,p′)Cp′(p′,p)∥p−p′∥2Cp(p,p′)={∣np⋅p−p′∥p−p′∥∣, if p is a surface vertex 1, otherwise \\\\\\hat{G}\\left(\\mathrm{p} \\leftrightarrow \\mathrm{p}^{\\prime}\\right)=V\\left(\\mathrm{p} \\leftrightarrow \\mathrm{p}^{\\prime}\\right) T_{r}\\left(\\mathrm{p} \\rightarrow \\mathrm{p}^{\\prime}\\right) \\frac{C_{\\mathrm{p}}\\left(\\mathrm{p}, \\mathrm{p}^{\\prime}\\right) C_{\\mathrm{p}^{\\prime}}\\left(\\mathrm{p}^{\\prime}, \\mathrm{p}\\right)}{\\left\\|\\mathrm{p}-\\mathrm{p}^{\\prime}\\right\\|^{2}} \\\\C_{\\mathrm{p}}\\left(\\mathrm{p}, \\mathrm{p}^{\\prime}\\right)= \\begin{cases}\\left|\\mathbf{n}_{\\mathrm{p}} \\cdot \\frac{\\mathrm{p}-\\mathrm{p}^{\\prime}}{\\left\\|\\mathrm{p}-\\mathrm{p}^{\\prime}\\right\\|}\\right|, &amp; \\text { if } \\mathrm{p} \\text { is a surface vertex } \\\\1, &amp; \\text { otherwise }\\end{cases} G^(p↔p′)=V(p↔p′)Tr​(p→p′)∥p−p′∥2Cp​(p,p′)Cp′​(p′,p)​Cp​(p,p′)={∣∣∣​np​⋅∥p−p′∥p−p′​∣∣∣​,1,​ if p is a surface vertex otherwise ​ 即可得到新的透照率和路径追逐的一般形式。 15.2 Sampling Volume Scattering 为了在体积中进行采样，我们首先需要定义 Medium::Sample() 接口。他的目标是采样上文中提到的包含介质的传输函数： Li(p,ω)=Tr(po→p)Lo(po,−ω)+∫0tmax⁡Tr(p′→p)Ls(p′,−ω)dt′L_i(p,\\omega) = T_r(p_o \\to p)L_o(p_o,-\\omega) + \\int_0^{t_{\\max}} T_r(p&#x27; \\to p)L_s(p&#x27;,-\\omega)\\mathrm{d}t&#x27; Li​(p,ω)=Tr​(po​→p)Lo​(po​,−ω)+∫0tmax​​Tr​(p′→p)Ls​(p′,−ω)dt′ 其中 p0=p+tmax⁡p_0 = p + t_{\\max}p0​=p+tmax​ 是某个表面上的一点（因为无穷远处的光最终会被介质消光至无任何影响），这一采样行为有两种可能：其一，没有在路径上采样到任何 interaction ，则应该计算和表面有关的那一项 Tr(po→p)Lo(po,−ω)T_r(p_o \\to p)L_o(p_o, -\\omega)Tr​(po​→p)Lo​(po​,−ω) ，否则则需要在空间中的一点处生成一个 MediumInteraction ，并继续采样新的光线。 假设 pt(t)p_t(t)pt​(t) 定义了在点 p+tωp + t\\omegap+tω nn 位置采样的概率，则在表面采样的概率有： psurf=1−∫0tmax⁡pt(t)dtp_{surf} = 1 - \\int_0^{t_{\\max}}p_t(t)\\mathrm{d}t psurf​=1−∫0tmax​​pt​(t)dt 利用这一概率就可以定义对应的 β\\betaβ 为： βsurf=Tr(p→p+tω)psurfβmed=σs(p+tω)Tr(p→p+tω)pt(t)\\beta_{surf} = {T_r(p \\to p+t\\omega) \\over p_{surf}}\\\\ \\beta_{med} = {\\sigma_s(p+t\\omega)T_r(p \\to p+t\\omega) \\over p_t(t)}βsurf​=psurf​Tr​(p→p+tω)​βmed​=pt​(t)σs​(p+tω)Tr​(p→p+tω)​ 15.2.1 Homogeneous Medium 在一个各向同性的简单介质中，由于其各种性质在空间中没有变化，其中唯一的复杂度仅仅在于要处理不同波长下的消光值。 在 13.3.1 中，曾经介绍了一个简单的指数透射率分布，其 PDF 为： pt(t)=σte−σttp_t(t) = \\sigma_te^{-\\sigma_t t} pt​(t)=σt​e−σt​t 可以得到如下的采样方法： t=−ln⁡(1−ξ)σtt = -{\\ln(1 - \\xi) \\over \\sigma_t} t=−σt​ln(1−ξ)​ 但由于 σt\\sigma_tσt​ 可能在不同波长上有所差异，但我们也不能在光线上同时采样多个位置，最后的解决方案就是首先均匀地采样一个通道 iii ，再在这个通道上采样 ttt 。使用这种方法计算得到的 PDF 是在各个通道上的 PDF 均值。 p^t(t)=1n∑i=1nσti−σtitpsurf=1n∑i=1nσti−σtitmax⁡\\hat{p}_t(t) = {1 \\over n}\\sum_{i=1}^n{\\sigma^i_t}^{-\\sigma_t^i t}\\\\ p_{surf} = {1 \\over n}\\sum_{i=1}^n{\\sigma^i_t}^{-\\sigma_t^i t_{\\max}}p^​t​(t)=n1​i=1∑n​σti​−σti​tpsurf​=n1​i=1∑n​σti​−σti​tmax​ 最后返回采样到的对应 β\\betaβ 即可。 15.2.2 Heterogeneous Medium 对于在空间上介质特性分布不均匀的情况，如 GridDensityMedium ，我们往往需要额外的一些开销以对它进行采样。在这一情况下，pt(t)p_t(t)pt​(t) 不是一个常数了。 要对变化的 σt\\sigma_tσt​ 进行采样，最直观的方法是 ray marching 。通过沿着光线采样 σt\\sigma_tσt​ ，进而构建出对应的 PDF 以进行采样。但这一方法会引入系统性的 bias ，总而降低渲染的质量。 为了解决这一问题，PBRT 使用了原本是为了计算中子在原子反应堆中的散射现象的 delta tracking 算法。这一方法使用空白粒子将介质填充至拥有均匀的 σt\\sigma_tσt​，并在发生 interaction 时增加一步 validation 以剔除空白粒子，从而实现可变的介质密度。 首先，在 GridDensityMedium 中会预计算一个最大密度。 接着，在 Sample 方法中，则会按照这个最大密度采样 ttt 。当在 tmax⁡t_{\\max}tmax​ 内如果发生了 interaction ，则会接着判断该 interaction 是否是由真实粒子贡献的（通过使用 U[0,1]U[0,1]U[0,1] 的随机样本与当前密度除以最大密度比较得到），如果不是，则在当前位置继续向前寻找 interaction ，直到找到或达到边界为止。由于不采样介质 interaction 的概率等于光线的透照率，因此对于 βsurf\\beta_{surf}βsurf​ 我们直接返回 1.0 即可。另一方面，对于一个介质的 interaction ，返回的 βmed\\beta_{med}βmed​ 则应该等于该位置的光线散射比例 σs/σt\\sigma_s / \\sigma_tσs​/σt​ 。 另一个需要实现的内容是该类的透照率函数 Tr() 。有了上面的采样函数，我们可以简单地用一组随机数去无偏地估计它，即我们可以进行多次采样，并取没有采样到 interaction 的情况比例作为透照率。在实际实现中，PBRT 还将 Sample 中二次 validate 的概率直接作为 TrTrTr 的估计值使用，从而加速收敛。 15.2.3 采样 Phase Functions 在 PBRT 中，由于 phase functions 是由公式显示定义并且经过了归一化的，所以它默认对这个函数的采样的 PDF 是和函数值完全一致的。 通过对 Henyey–Greenstein 函数的分析有： ϕ=2πξ1cos⁡θ=−12g(1+g2−(1−g21+g−2gξ2)2)\\phi = 2\\pi\\xi_1\\\\ \\cos \\theta=-\\frac{1}{2 g}\\left(1+g^{2}-\\left(\\frac{1-g^{2}}{1+g-2 g \\xi_2}\\right)^{2}\\right)ϕ=2πξ1​cosθ=−2g1​(1+g2−(1+g−2gξ2​1−g2​)2) 特别地，当 g=0g=0g=0 时该函数退化为一个均匀的球面采样，即 cos⁡θ=1−2ξ2\\cos\\theta = 1 - 2\\xi_2cosθ=1−2ξ2​ 15.3 Volumetric Light Transport 在拥有了以上采样技术后，我们就可以实现 EstimateDirect 中加入对空间中的介质点的采样支持了。这和采样 BSDF 的过程是极其相似的，只不过将 fff 项替换为了对 phase function 的采样，并将 scatteringPdf 设置为对应的采样值即可。 15.3.1 路径追踪 VolPathIntegrator 是将体积纳入考虑的路径追踪积分器。这一实现与之前描述的路径追踪方法的最大不同在于，当光线处在介质中时，会对该介质调用一次 Medium::Sample 从而确认是否存在 medium interaction ，同时记录光线的透照率到 β\\betaβ 上。如果找到了一个 MI ，则接下来会使用 UniformSampleOneLight 采样一个直接光照，并使用 phase function 采样并生成新的光线。反之则按照原来的方法计算。 15.4 Sampling Subsurface Reflection Functions ⚠️ 另一种渲染介质的方法是利用 BSSRDF 和一个物体表面表示介质，并对 BSSRDF 进行采样从而获得最终的着色值，它大大减少了对介质中的每一条路径都进行采样所带来的极高的复杂度（特别是对于 albedo 较大的介质而言，它们中的光路通常十分复杂）。本节中介绍了对它的采样方法。 和 BSDF 只用采样一个方向不同的是，BSSRDF 的采样还需要在物体表面采样另一个位置。BSSRDF::Sample_S() 函数负责这一采样过程，它接收三个随机数（由一个 float 和一个 Point2f 组成），以采样一个新的 surface interaction ，并返回传输率。 15.4.1 采样 SeparableBSSRDF SeparableBSSRDF 将 BSSRDF 分为了菲涅尔项、简化为与距离有关的 SpS_pSp​ 项和与入射光角度有关的 SωS_\\omegaSω​ 项。 S(po,ωo,pi,ωi)≈(1−Fr(cos⁡θo))Sp(po,pi)Sω(ωi)S(p_o,\\omega_o,p_i,\\omega_i) \\approx (1 - F_r(\\cos\\theta_o))S_p(p_o,p_i)S_{\\omega}(\\omega_i)S(po​,ωo​,pi​,ωi​)≈(1−Fr​(cosθo​))Sp​(po​,pi​)Sω​(ωi​) SeparableBSSRDF::Sample_S 的函数会首先转发一个子函数 SeparableBSSRDF::Sample_Sp ，如果采样出来的结果不是黑色，则会初始化对应的 surface interaction 中的 BSDF 和 wo 信息。 由于 BSSRDF 中的 SωS_\\omegaSω​ 项实际上是一个归一化的菲涅尔反射项，它实际上和一个 BSDF_DIFFUSE 的表现极其一致，并且可以使用 BxDF::Sample_f 进行采样。利用 PBRT 中的设计，我们可以直接在出射 SI 上添加这样一个实际上相当于封装了对应 BSSRDF 的 Sample_Sw 的 SeparableBSSRDFAdapter 以实现对出射方向的估计和采样。 另一方面，为了实现对空间项 SpS_pSp​ 的采样，我们需要一种方法将二维的随机数映射到三维的场景几何体表面的点上。一种直观的想法是使用测地线进行采样，但这一方法并不具有普遍性，并需要对各个模型附加极大难度的不同的测量实现。为此，PBRT 使用了更简单的基于光线追踪的映射方法。 上图展示了这一方法的基本概念：基于出点 SI 提供的 po,Nop_o, N_opo​,No​ 可以构建一个球体的切面，我们会在这个以 pop_opo​ 为球心，被以 non_ono​ 为法线的切面上采样一个角度 ϕ\\phiϕ 和一个半径 rrr ，接着在该位置沿着出点法线的逆方向发射一条光线与几何体求交，从而得到入点的 SI 信息。 这一方法仍然具有多个缺点： 径向的衰减项 SrS_rSr​ 并不一定在所有波长上都是一致的，事实上在很多情况下各个通道的平均自由程是不一样的 当 no⋅ni→0n_o \\cdot n_i \\to 0no​⋅ni​→0 时，探测射线会与平面相交于一个较远的位置，从而提供一个非常差的低概率样本，进而增加结果的方差 探测光线可能与物体多次相交，而其中的每个交点都会以不同的方式贡献能量 对于前两个问题，一种结合了多投影方向和多光谱通道的 MIS 方法被用于同时解决这两个问题。在 PBRT 中，对投影方向的选择不止限于法线的逆向，而是以 2:1:12:1:12:1:1 的权重分别选择法线或是两个切线的反方向之一（因为另两个方向的探测光线更容易 miss 掉物体本身）。接着，会随机地采样一个颜色通道。 SeperableBSSRDF 接口提供了以下两个函数以采样一个半径，以及从对应的采样恢复 PDF ： 12virtual Float Sample_Sr(int ch, Float u) const = 0;virtual Float Pdf_Sr(int ch, Float r) const = 0; 在一般情况下，BSSRDF 值会随着半径快速降低，我们对大多数距离较远的位置并不感兴趣，因此采样的范围被缩小到了距离圆心有限的范围 rmax⁡r_{\\max}rmax​ 中。这一值是由使用固定的数值调用 Sample_Sr(ch, 0.99) 生成的，以保证其中包含了 99.999.9%99.9 的散射能量。 接着，PBRT 会在 rmax⁡r_{\\max}rmax​ 的球范围内按照给定的投影轴和采样位置生成一段光线（如上图中长为 lll 的线段），这根光线会和场景进行多次求交，并在与本物体相交时将交点信息保存在一个相交位置的链表中，直到走完整个线段为止： 12345struct IntersectionChain &#123; SurfaceInteraction si; IntersectionChain *next = nullptr;&#125;;IntersectionChain *chain = ARENA_ALLOC(arena, IntersectionChain)(); 我记得 PBRT 里面应该有光线和单个物体相交的函数来着？ 最后，PBRT 会均匀且随机地使用其中一个交点作为最终的采样结果。这一选择和之前的投影轴选择以及通道的选择均有传入的第一个随机数完成。每次使用后随机数会被进一步缩放至满足 U[0,1]U[0,1]U[0,1] 分布，对于这些简单地选择而言单一随机数的精度在绝大多数情况下都绰绰有余。 第二个需要考虑的函数是 SeparableBSSRDF::Pdf_Sp() 它会评估输入的 SI 在采样过程中的 PDF 。它主要分为三个步骤： 使用定义在 pop_opo​ 的局部坐标系表示 pi−pop_i - p_opi​−po​ 将这半径投影到另外两个坐标系上得到 rProj 遍历所有的 3 * Spectrum::nSamples 种不同的采样组合并计算对应的 PDF ，最终取加权均值 15.4.2 采样 TabulatedBSSRDF ⚠️ 上一节中，我们讨论了对 BSSRDF 的采样，其中没有设计的唯二函数是 Sample_Sr, Pdf_Sr 。本节中将说明它们在 TabulatedBSSRDF 中的实现。 和此前的 FourierBSDF 的采样类似，它的采样函数调用了同样的 SampleCatmullRom2D 以获得一个在单位圆上的半径采样，接着除以对应通道的 σt\\sigma_tσt​ 以得到最终的采样半径。 而 PDF 的计算则和之前一致，只需要将半径乘以对应通道的 σt\\sigma_tσt​ 就能获得一致的权重，接着调用前文中的接口计算 sr ，最后做一次 PDF 的重映射即可。 由于之前的章节中跳过了对傅里叶 BSDF 的采样部分，此处仅作简单描述 15.4.3 路径追踪中的次表面散射 我们有： Lo(po,ωo)≈S(po,ωo,pi,ωi)(Ld(pi,ωi)+Li(pi,ωi))∣cos⁡θi∣p(pi)p(ωi)L_{\\mathrm{o}}\\left(\\mathrm{p}_{\\mathrm{o}}, \\omega_{\\mathrm{o}}\\right) \\approx \\frac{S\\left(\\mathrm{p}_{\\mathrm{o}}, \\omega_{\\mathrm{o}}, \\mathrm{p}_{\\mathrm{i}}, \\omega_{\\mathrm{i}}\\right)\\left(L_{\\mathrm{d}}\\left(\\mathrm{p}_{\\mathrm{i}}, \\omega_{\\mathrm{i}}\\right)+L_{\\mathrm{i}}\\left(\\mathrm{p}_{\\mathrm{i}}, \\omega_{\\mathrm{i}}\\right)\\right)\\left|\\cos \\theta_{\\mathrm{i}}\\right|}{p\\left(\\mathrm{p}_{\\mathrm{i}}\\right) p\\left(\\omega_{\\mathrm{i}}\\right)} Lo​(po​,ωo​)≈p(pi​)p(ωi​)S(po​,ωo​,pi​,ωi​)(Ld​(pi​,ωi​)+Li​(pi​,ωi​))∣cosθi​∣​ 特别地，对于一般的表面我们直接有：pi=po,p(pi)=1p_i = p_o, p(p_i) = 1pi​=po​,p(pi​)=1 这意味着将 BSSRDF 整合入路径追踪之中非常简单，我们只需要在当生成的 interaction 中包含 BSSRDF 时改用对应的函数采样和求解光照即可。PBRT 中的 PathIntegrator 和 VolPathIntegrator 均支持次表面材质。 15.5 Subsurface Scattering Using the Diffusion Equation ⚠️ 完成 BSSRDF 的采样和估计过程的最后一块拼图是 SeperableBSSRDF::Sr(Float r) 函数，它被广泛用于对 SpS_pSp​ 的估计之中，贯穿整个采样和求值的过程。PBRT 中使用的方法基于 Habel 等人于 2013 年提出的光子束扩散技术 photon beam diffusion (PBD) 。为了高效地估计这一值，该技术做出了大量假设： 光线在半透明物体中的分布是由扩散近似法建模的，描述了高度散射的材质中的光线稳态 它需要散射属性在整个介质中是同质的 它基于 Seperable BSSRDF 所做出的一切假设 在满足以上条件时，PBD 方法得到的结果和由路径追踪得到的结果可以做到非常相近。但大部分情况下，这些条件并不能都被满足，尤其是物体具有复杂的几何形状的时候。但即使一部分假设并不能得到满足，这一方法仍然可以生成视觉上过得去的结果。 零一方面，这一算法需要求与 SrS_rSr​ 的 CDF 的逆，并完成其在球座标上的映射。但这通常并不能在 TabulatedBSSRDF 中得到一个解析解，因此 PBRT 会在构建场景时预计算包括 radii, albedo 等一系列数值并储存在表中。 15.5.1 相似性原理 为了将普适性的方程转换为扩散方程，接着用于估计求解次表面散射，需要使用到一系列的假设和转换。其中之一就是相似性原理（principal of similarity）。它认为，一个各向异性且具有高 albedo 的散射介质可以通过一个各向同性的 phase function 和适当修改的散射和吸光系数来表示。这主要是因为当散射次数逐渐增多时，散射光线的分布就会越来越趋向于均匀分布。Yanovitskij 定性了这一表示方法，他写出了 HG 分布函数在 n 次散射后的推广形式： p(ω→ω′)=1−g2n4π(1+g2n−2g∣gn−1∣(−ω⋅ω′))3/2p(\\omega \\to \\omega&#x27;) = {1 - g^{2n} \\over 4\\pi(1 + g^{2n} - 2g|g^{n-1}|(-\\omega \\cdot \\omega&#x27;))^{3 / 2}} p(ω→ω′)=4π(1+g2n−2g∣gn−1∣(−ω⋅ω′))3/21−g2n​ 显然，当 n→∞n \\to \\inftyn→∞ 时，只要 g≠±1g \\neq \\pm1g​=±1 ，这一方程会收敛到各向同性的 phase function 1/4π1 / 4\\pi1/4π 上。这一原理将被应用于对 phase function 的简化上，同时会修改散射相关的系数： σs′=(1−g)σsσt′=σa+σs′ρ′=σs′σt′\\begin{aligned} \\sigma_s&#x27; &amp;= (1 - g)\\sigma_s\\\\ \\sigma_t&#x27; &amp;= \\sigma_a + \\sigma_s&#x27;\\\\ \\rho&#x27; &amp;= {\\sigma_s&#x27; \\over \\sigma_t&#x27;} \\end{aligned}σs′​σt′​ρ′​=(1−g)σs​=σa​+σs′​=σt′​σs′​​​ 对于这一近似的直观解释如下：当一个介质拥有 g→1g \\to 1g→1 时，这意味着在多次散射的过程中大部分情况下光线都会大致沿着原来的方向前进，造成一种类似低散射系数的效果。反之，当 g→−1g \\to -1g→−1 时，光线总是会在反射后射向相反的方向，造成的光路就如同进入了高散射系数的情况一样。下图展示了 g=±0.9g = \\pm0.9g=±0.9 的情况下的光路： 15.5.2 扩散理论 扩散理论提供了一种在同质且高散射的介质中简化传输方程的解决方法。它可以通过将上述修改后的系数带入传输方程中得到。我们首先考虑传输方程如下： ∂∂tLo(p′,ω)=−σt(p′,ω)Li(p′,−ω)+Le(p,ω)+σs(p,ω)∫S2p(p,ω,ω′)Li(p,ω′)dω′\\begin{aligned} \\frac{\\partial}{\\partial t} L_{\\mathrm{o}}\\left(\\mathrm{p}^{\\prime}, \\omega\\right)=&amp;-\\sigma_{\\mathrm{t}}\\left(\\mathrm{p}^{\\prime}, \\omega\\right) L_{\\mathrm{i}}\\left(\\mathrm{p}^{\\prime},-\\omega\\right)\\\\ &amp;+L_e(p,\\omega) + \\sigma_s(p,\\omega)\\int_{S^2}p(p,\\omega, \\omega&#x27;)L_i(p,\\omega&#x27;)\\mathrm{d}\\omega&#x27; \\end{aligned}∂t∂​Lo​(p′,ω)=​−σt​(p′,ω)Li​(p′,−ω)+Le​(p,ω)+σs​(p,ω)∫S2​p(p,ω,ω′)Li​(p,ω′)dω′​ 将相似性原理应用于其上，同时简化 Lo(p,ω)=Li(p,−ω)=L(p,ω)L_o(p,\\omega) = L_i(p,-\\omega) = L(p, \\omega)Lo​(p,ω)=Li​(p,−ω)=L(p,ω) 之后有： ∂∂tL(p+tω,ω)=−σt′L(p,ω)+σs′4π∫S2L(p,ω′)dω′+Le(p,ω)\\frac{\\partial}{\\partial t} L(\\mathrm{p}+t \\omega, \\omega)=-\\sigma_{\\mathrm{t}}^{\\prime} L(\\mathrm{p}, \\omega)+\\frac{\\sigma_{\\mathrm{s}}^{\\prime}}{4 \\pi} \\int_{\\mathrm{S}^{2}} L\\left(\\mathrm{p}, \\omega^{\\prime}\\right) \\mathrm{d} \\omega^{\\prime}+L_{\\mathrm{e}}(\\mathrm{p}, \\omega) ∂t∂​L(p+tω,ω)=−σt′​L(p,ω)+4πσs′​​∫S2​L(p,ω′)dω′+Le​(p,ω) 扩散理论的核心假设在于，由于散射过程有效地对入射光进行了分散，其中来自入射位置沿角度分布的高频信息会迅速被混成一团。在高密度且同质的介质中，所有的光线方向性都会最终消解掉。因此，我们可以只使用在球面动量的二阶展开来表示辐照度方程。对于定义在球面上的函数 f:S2→Rf: S^2 \\to Rf:S2→R ，其 nnn 阶动量的定义为： (μn[f])i,j,k,…=∫S2ωiωjωk⋯⏟n factors f(ω)dω.\\left(\\mu_{n}[f]\\right)_{i, j, k, \\ldots}=\\int_{S^{2}} \\underbrace{\\omega_{\\mathrm{i}} \\omega_{j} \\omega_{k} \\cdots}_{n \\text { factors }} f(\\omega) \\mathrm{d} \\omega . (μn​[f])i,j,k,…​=∫S2​n factors ωi​ωj​ωk​⋯​​f(ω)dω. 也就是说，在三维的情况下，kkk 阶动量就相当于一个大小为 3k3^k3k 的常数 / 向量 / 矩阵 / 高维矩阵。其中 i,j⋯i,j\\cdotsi,j⋯ 位置上的元素就是由原始函数值和笛卡尔坐标系对应维度的值相乘而成的。特别地，零阶动量就相当于这一函数在球面上的均值，一阶动量则相当于一个表示质心的向量，二阶动量是一个正定的 3×33 \\times 33×3 矩阵。虽然更高阶的动量可以给我们提供更优秀的方向相关的特性重建结果，但此处我们只关心 ≤1\\leq 1≤1 阶的动量以对原函数做一个展开操作。对于光照函数，我们有： ϕ(p)=μ0[L(p,⋅)]=∫S2L(p,ω)dωE(p)=μ1[L(p,⋅)]=∫S2ωL(p,ω)dω\\begin{aligned} \\phi(p) &amp;= \\mu_0[L(p, \\cdot)] &amp;=&amp; \\int_{S^2}L(p,\\omega)\\mathrm{d}\\omega\\\\ E(p) &amp;= \\mu_1[L(p, \\cdot)] &amp;=&amp; \\int_{S^2}\\omega L(p,\\omega)\\mathrm{d}\\omega&amp; \\end{aligned}ϕ(p)E(p)​=μ0​[L(p,⋅)]=μ1​[L(p,⋅)]​==​∫S2​L(p,ω)dω∫S2​ωL(p,ω)dω​​ 展开式可以使用上述两阶动量展开为（以下 LdL_dLd​ 表示了使用扩散方法计算的光照，而非直接光照）： L(p,ω)≈Ld(p,ω)=14πϕ(p)+34πω⋅E(p)L(p,\\omega) \\approx L_{d}(p,\\omega) = {1 \\over 4\\pi}\\phi(p) + {3 \\over 4\\pi}\\omega \\cdot E(p) L(p,ω)≈Ld​(p,ω)=4π1​ϕ(p)+4π3​ω⋅E(p) 在获得这一近似的下一步就是将这一近似应用于上述的传输方程之中。但很不幸的是，这一方程并不一定有解。但这一问题由一个小 trick 解决：在计算扩散方程时，我们只要求方程两边的各阶动量相等，即： μi[∂∂tLo(p′,ω)]=μi[−σt(p′,ω)Li(p′,−ω)+Le(p,ω)+σs(p,ω)∫S2p(p,ω,ω′)Li(p,ω′)dω′]\\begin{aligned} \\mu_i\\left[\\frac{\\partial}{\\partial t} L_{\\mathrm{o}}\\left(\\mathrm{p}^{\\prime}, \\omega\\right)\\right]=\\mu_i\\bigg[&amp;-\\sigma_{\\mathrm{t}}\\left(\\mathrm{p}^{\\prime}, \\omega\\right) L_{\\mathrm{i}}\\left(\\mathrm{p}^{\\prime},-\\omega\\right)\\\\ &amp;+L_e(p,\\omega) + \\sigma_s(p,\\omega)\\int_{S^2}p(p,\\omega, \\omega&#x27;)L_i(p,\\omega&#x27;)\\mathrm{d}\\omega&#x27;\\bigg] \\end{aligned}μi​[∂t∂​Lo​(p′,ω)]=μi​[​−σt​(p′,ω)Li​(p′,−ω)+Le​(p,ω)+σs​(p,ω)∫S2​p(p,ω,ω′)Li​(p,ω′)dω′]​ 通过化简上式，我们有： divE(p)=−σaϕ(p)+μ0[Le(p,⋅)]\\mathrm{div} E(p) = -\\sigma_a\\phi(p) + \\mu_0[L_e(p, \\cdot)] divE(p)=−σa​ϕ(p)+μ0​[Le​(p,⋅)] 其中 divE(p)\\mathrm{div}E(p)divE(p) 表示了 E(p)E(p)E(p) 的散度： divE(p)=∂∂xE(p)+∂∂yE(p)+∂∂zE(p)\\mathrm{div}E(p) = {\\partial \\over \\partial x}E(p) + {\\partial \\over \\partial y}E(p) + {\\partial \\over \\partial z}E(p) divE(p)=∂x∂​E(p)+∂y∂​E(p)+∂z∂​E(p) 另一方面，从动量的定义我们又可得： 13∇ϕ(p)=−σt′E(p)+μ1(Le(p,⋅)){1 \\over 3} \\nabla \\phi(p) = -\\sigma&#x27;_tE(p) + \\mu_1(L_e(p, \\cdot)) 31​∇ϕ(p)=−σt′​E(p)+μ1​(Le​(p,⋅)) 我们接着做出另外一个假设：介质中的光源均匀地向所有方向发光，即 ∀i≥1,μi[Le(p,⋅)]=0\\forall i \\geq 1, \\mu_i[L_e(p,\\cdot)] = 0∀i≥1,μi​[Le​(p,⋅)]=0 ，这又和之前的相似性假设类似。通过结合以上假设和方程，我们可得： D∇2ϕ(p)−σaϕ(p)=−μ0[Le]D\\nabla^2\\phi(p) - \\sigma_a \\phi(p) = - \\mu_0[L_e] D∇2ϕ(p)−σa​ϕ(p)=−μ0​[Le​] 其中 ∇2=div∇\\nabla^2 = \\mathrm{div}\\nabla∇2=div∇ 被称为拉普拉斯算子，常数 D=1/(3σt)D = 1 / (3\\sigma_t)D=1/(3σt​) 项被称为 classical diffusion coefficient 。 有了上述的扩散方程，我们接着会从一个点光源和一块完全充满了无穷空间的介质开始分析，接着考虑多种方法以提高近似的精度。 15.5.3 Monopole Solution 我们首先由最简单的一种情况开始思考，考虑一块无限大的同质性介质，其空间的原点处有一个释放单位能量的点光源（monopole），即空间中的自发光项的分布为： Le(p,ω)=14πδ(p)μ0[Le(p,⋅)]=δ(p)L_e(p,\\omega) = {1 \\over 4\\pi}\\delta(p)\\\\ \\mu_0[L_e(p,\\cdot)] = \\delta(p)Le​(p,ω)=4π1​δ(p)μ0​[Le​(p,⋅)]=δ(p) 将此式带入扩散方程可以得到一个简单的解析解： ϕM(r)=14πDe−σtrrr\\phi_M(r) = {1 \\over 4\\pi D}{e^{-\\sigma_{tr}r} \\over r} ϕM​(r)=4πD1​re−σtr​r​ 其中的常数 σtr=σa/D\\sigma_{tr} = \\sqrt{\\sigma_a / D}σtr​=σa​/D​ 被称为 effective transport coefficient ，它贡献了主要的指数衰减项。这说明在扩散中光线衰减的速度和 σt′\\sigma_t&#x27;σt′​ 并不相同，σtr\\sigma_{tr}σtr​ 反而取决于介质的 albedo 。 接着，将这一公式带入动量的定义中，我们可以得到 EEE 项： EM(p)=−D∇ϕM(p)=[−D∂∂rϕM(r)]r^=1+rσtr4πr2e−σtrrr^\\begin{aligned}\\mathbf{E}_{\\mathrm{M}}(\\mathrm{p}) &amp;=-D \\nabla \\phi_{\\mathrm{M}}(\\mathrm{p}) \\\\&amp;=\\left[-D \\frac{\\partial}{\\partial r} \\phi_{\\mathrm{M}}(r)\\right] \\widehat{\\mathbf{r}} \\\\&amp;=\\frac{1+r \\sigma_{\\mathrm{tr}}}{4 \\pi r^{2}} \\mathrm{e}^{-\\sigma_{\\mathrm{tr}} r} \\hat{\\mathbf{r}}\\end{aligned} EM​(p)​=−D∇ϕM​(p)=[−D∂r∂​ϕM​(r)]r=4πr21+rσtr​​e−σtr​rr^​ 15.5.4 非典型扩散 虽然在上述 Monopole 的情况下我们可以得到一个有关通量的精确解，但它在底层的扩散性假设失效时相较于使用原始方法而言仍然具有较大的误差。特别地，有两个特殊情况：其一，对能量的吸收阻止了辐照度场达到稳态；其二则是在光源附近辐照度函数不能忽略介质的各向异性。 多年来，为了更加精确地在不同情况下进行近似，研究者们提出了多种改进方法。其中一个较为有效的是使用 Grosjean 在1956 年在中子传输领域提出的改进的 monopole 解： ϕG(r)=e−σt′r4πr2+ϕM~(r)ϕM~(r)=ρ′ϕM(r)\\begin{gathered} \\phi_{\\mathrm{G}}(r)=\\frac{\\mathrm{e}^{-\\sigma_{\\mathrm{t}}^{\\prime} r}}{4 \\pi r^{2}}+\\tilde{\\phi_{\\mathrm{M}}}(r) \\\\ \\tilde{\\phi_{\\mathrm{M}}}(r)=\\rho^{\\prime} \\phi_{\\mathrm{M}}(r) \\end{gathered}ϕG​(r)=4πr2e−σt′​r​+ϕM​~​(r)ϕM​~​(r)=ρ′ϕM​(r)​ 第一部分是一个使用传统的辐射传输方法计算的一个消光系数以表示无散射情况下的通量（即单散射的部分），这有效地消除了不能被扩散理论解决的部分。而剩下的扩散（多散射）项表示了至少经过了一次散射的光线，它被一个 reduced albedo 项 ρ′\\rho&#x27;ρ′ 缩放以体现额外的散射带来的能量损失。它还需要修改前文种使用的 diffusion coefficient DDD 项如下： DG=2σa+σs′3(σa+σs′)2D_G = {2\\sigma_a + \\sigma_s&#x27; \\over 3(\\sigma_a + \\sigma_s&#x27;)^2} DG​=3(σa​+σs′​)22σa​+σs′​​ 在低 albedo 的情况下，Grosjean 解（蓝线）相比上一节中的传统解（红线）更好地拟合了实际解（黑线）： 在接下来的内容中，我们将关注于 Grosjean 解中的后一个多次散射项，而前一半的消光项会在之后进行分离简化处理。 15.5.5 Dipole Solution 为了将扩散方程应用于次表面散射中，这一解必须考虑到分界面的存在。接下来，我们将使用一个分割平面拓展 monopole 的场景，以场景中的平面 z=0z = 0z=0 为分界线，一面是介质，另一面则假定为真空。一个单位点光源被放置在介质中的 zzz 轴上的点 (0,0,zr)(0,0,z_r)(0,0,zr​) 处。由于分界面的存在，一部分光线可以逃逸出介质，并不再进行散射，而另一部分光线则在分界面上发生镜面反射，重新回到介质中参与作用。 分界面的影响可以使用镜像法进行近似。我们假设在真空部分中的 (0,0,zv)(0,0,z_v)(0,0,zv​) 处有一个虚拟的光源，它与原始光源在分割面上的投影位置相同，但它在释放负的能量。这一假设让它吸收从原始光源出射的光线，剩余的光线则体现出反射的性质。由 zrz_rzr​ 确认 zvz_vzv​ 的值便是我们接下来需要探讨的内容。 由于扩散方程的线性性质，我们可以通过相加两个点光源的结果以得到它们的效果之和： ϕD(r)=ϕM~(dr)−ϕM~(dv)ED(r)=EM~(dr)−EM~(dv)dr=r2+zr2, dv=r2+zv2\\phi_D(r) = \\tilde{\\phi_M}(d_r) - \\tilde{\\phi_M}(d_v)\\\\ E_D(r) = \\tilde{E_M}(d_r) - \\tilde{E_M}(d_v)\\\\ d_r = \\sqrt{r^2+z_r^2}, \\ d_v = \\sqrt{r^2+z_v^2}ϕD​(r)=ϕM​~​(dr​)−ϕM​~​(dv​)ED​(r)=EM​~​(dr​)−EM​~​(dv​)dr​=r2+zr2​​, dv​=r2+zv2​​ 特别地，假设 zr&gt;0, zv&lt;0z_r&gt;0,\\ z_v&lt;0zr​&gt;0, zv​&lt;0 对于一阶动量 EEE 在 zzz 轴上的分量有： (0,0,1)⋅ED(r)=14π[zr(1+drσtr)dr3e−σtrdr−zv(1+dvσtr)dv3e−σtrdv](0,0,1) \\cdot E_D(r) = \\frac{1}{4 \\pi}\\left[\\frac{z_{\\mathrm{r}}\\left(1+d_{\\mathrm{r}} \\sigma_{\\mathrm{tr}}\\right)}{d_{\\mathrm{r}}^{3}} \\mathrm{e}^{-\\sigma_{\\mathrm{tr}} d_{\\mathrm{r}}}-\\frac{z_{\\mathrm{v}}\\left(1+d_{\\mathrm{v}} \\sigma_{\\mathrm{tr}}\\right)}{d_{\\mathrm{v}}^{3}} \\mathrm{e}^{-\\sigma_{\\mathrm{tr}} d_{\\mathrm{v}}}\\right] (0,0,1)⋅ED​(r)=4π1​[dr3​zr​(1+dr​σtr​)​e−σtr​dr​−dv3​zv​(1+dv​σtr​)​e−σtr​dv​] 边界情况 在边界的真空一侧，由于没有任何散射现象的参与，散射过程会以平方反比的速度快速衰减。而当我们在边界面的位置使用扩散方程用到的一阶展开来近似这一过程的话，这个线性函数就会在某一位置 zez_eze​ 变成零。这一位置对应到负光源的情况下就恰好是两个光源的连线中点：zv=2ze−zrz_v = 2 z_e - z_rzv​=2ze​−zr​ 。一种对这一边界情况的近似 zez_eze​ 如下： ze=−2DG1+3Fˉr,2(η)1−2Fˉr,1(η)z_e = -2D_G{1 + 3\\bar{F}_{r,2}(\\eta) \\over 1 - 2\\bar{F}_{r,1}(\\eta)} ze​=−2DG​1−2Fˉr,1​(η)1+3Fˉr,2​(η)​ 其中的 Fˉr,1, Fˉr,2\\bar{F}_{r,1},\\ \\bar{F}_{r,2}Fˉr,1​, Fˉr,2​ 分别是 11 章中提到的菲涅尔动量。 出射辐照度 到了这一步，我们已经拥有了所有需要计算表面的出射光线的要素，通过将对应值写入扩散方程，我们可以得到介质内的光线值： Ld(p,ω)=14πϕ(∣∣p∣∣)+34πω⋅E(∣∣p∣∣)L_{d}(p,\\omega) = {1 \\over 4\\pi}\\phi(||p||) + {3 \\over 4\\pi}\\omega \\cdot E(||p||) Ld​(p,ω)=4π1​ϕ(∣∣p∣∣)+4π3​ω⋅E(∣∣p∣∣) 为了计算边界上的出射能量，我们需要使用菲涅尔项和 cos⁡\\coscos 项和这一函数在半球面上积分： Ed(p)=∫H2(n)(1−Fr(η−1,cos⁡θ))Ld(p,ω)cos⁡θdω=Ed,ϕD(∥p∥)+Ed,ED(∥p∥).\\begin{aligned}E_{\\mathrm{d}}(\\mathrm{p}) &amp;=\\int_{\\mathrm{H}^{2}(\\mathbf{n})}\\left(1-F_{\\mathrm{r}}\\left(\\eta^{-1}, \\cos \\theta\\right)\\right) L_{\\mathrm{d}}(\\mathrm{p}, \\omega) \\cos \\theta \\mathrm{d} \\omega \\\\&amp;=E_{\\mathrm{d}, \\phi_{\\mathrm{D}}}(\\|\\mathrm{p}\\|)+E_{\\mathrm{d}, \\mathrm{E}_{\\mathrm{D}}}(\\|\\mathrm{p}\\|) .\\end{aligned} Ed​(p)​=∫H2(n)​(1−Fr​(η−1,cosθ))Ld​(p,ω)cosθdω=Ed,ϕD​​(∥p∥)+Ed,ED​​(∥p∥).​ 通过线性性质将这两部分分别积分： Ed,ϕD(r)=∫02π∫0π2(1−Fr(η−1,cos⁡θ))14πϕD(r)cos⁡θsin⁡θdθdϕ=12ϕD(r)∫0π2(1−Fr(η−1,cos⁡θ))cos⁡θsin⁡θdθ=ϕD(r)(14−12Fˉr,1)Ed,ED(r)=∫02π∫0π2(1−Fr(η−1,cos⁡θ))(34πω⋅ED(r))cos⁡θsin⁡θdθdϕ=∫0π2(1−Fr(η−1,cos⁡θ))(3cos⁡θ2n⋅ED(r))cos⁡θsin⁡θdθ=n⋅ED(r)(12−32Fˉr,2)⋅\\begin{aligned}E_{\\mathrm{d}, \\phi_{\\mathrm{D}}}(r) &amp;=\\int_{0}^{2 \\pi} \\int_{0}^{\\frac{\\pi}{2}}\\left(1-F_{\\mathrm{r}}\\left(\\eta^{-1}, \\cos \\theta\\right)\\right) \\frac{1}{4 \\pi} \\phi_{\\mathrm{D}}(r) \\cos \\theta \\sin \\theta \\mathrm{d} \\theta \\mathrm{d} \\phi \\\\&amp;=\\frac{1}{2} \\phi_{\\mathrm{D}}(r) \\int_{0}^{\\frac{\\pi}{2}}\\left(1-F_{\\mathrm{r}}\\left(\\eta^{-1}, \\cos \\theta\\right)\\right) \\cos \\theta \\sin \\theta \\mathrm{d} \\theta \\\\&amp;=\\phi_{\\mathrm{D}}(r)\\left(\\frac{1}{4}-\\frac{1}{2} \\bar{F}_{\\mathrm{r}, 1}\\right) \\\\E_{\\mathrm{d}, \\mathrm{E}_{\\mathrm{D}}}(r) &amp;=\\int_{0}^{2 \\pi} \\int_{0}^{\\frac{\\pi}{2}}\\left(1-F_{\\mathrm{r}}\\left(\\eta^{-1}, \\cos \\theta\\right)\\right)\\left(\\frac{3}{4 \\pi} \\omega \\cdot \\mathbf{E}_{\\mathrm{D}}(r)\\right) \\cos \\theta \\sin \\theta \\mathrm{d} \\theta \\mathrm{d} \\phi \\\\&amp;=\\int_{0}^{\\frac{\\pi}{2}}\\left(1-F_{\\mathrm{r}}\\left(\\eta^{-1}, \\cos \\theta\\right)\\right)\\left(\\frac{3 \\cos \\theta}{2} \\mathbf{n} \\cdot \\mathbf{E}_{\\mathrm{D}}(r)\\right) \\cos \\theta \\sin \\theta \\mathrm{d} \\theta \\\\&amp;=\\mathbf{n} \\cdot \\mathbf{E}_{\\mathrm{D}}(r)\\left(\\frac{1}{2}-\\frac{3}{2} \\bar{F}_{\\mathrm{r}, 2}\\right) \\cdot\\end{aligned} Ed,ϕD​​(r)Ed,ED​​(r)​=∫02π​∫02π​​(1−Fr​(η−1,cosθ))4π1​ϕD​(r)cosθsinθdθdϕ=21​ϕD​(r)∫02π​​(1−Fr​(η−1,cosθ))cosθsinθdθ=ϕD​(r)(41​−21​Fˉr,1​)=∫02π​∫02π​​(1−Fr​(η−1,cosθ))(4π3​ω⋅ED​(r))cosθsinθdθdϕ=∫02π​​(1−Fr​(η−1,cosθ))(23cosθ​n⋅ED​(r))cosθsinθdθ=n⋅ED​(r)(21​−23​Fˉr,2​)⋅​ 至此，我们就可以获得在单个位于 (0,0,zr)(0,0,z_r)(0,0,zr​) 位置的光源的情况下，在表面位置 ppp 出射的总能量。我们会将这一值写作 E(p,zr)E(p, z_r)E(p,zr​) 以供接下来使用。 15.5.6 Beam Solution（多散射项） 对 dipole 模型而言，最后一个需要考虑的内容在于，那一个介质中的光源究竟应该被放在什么位置上。第一个在 CG 中应用的基于 dipole 的 BSSRDF 将光源放置在入射光的一倍平均自由程上 zr=1/σt′z_r = 1 / \\sigma&#x27;_tzr​=1/σt′​ 。这一近似虽然有一点道理，但会在接近光源时产生极大的误差。 使用 PBD 方法，点光源的解需要在整个介质域内 zr∈[0,∞)z_r\\in[0,\\infty)zr​∈[0,∞) 积分，即： Ed(p)=∫0∞σs′e−σt′zrED(p,zr)dzrE_d(p) = \\int_0^{\\infty}\\sigma_s&#x27;e^{-\\sigma_t&#x27;z_r}E_D(p, z_r)\\mathrm{d}z_r Ed​(p)=∫0∞​σs′​e−σt′​zr​ED​(p,zr​)dzr​ 这一公式中的指数项代表了光线在介质中传播过程中的损失，它计算了一个垂直入射的单位辐照度的光线对于表面各点的影响。PBD 的一些其它变体还可以处理非垂直入射的情况，或者加快这一数值的估计，但此处我们不再深究。 在 PBRT 中，函数 BeamDiffusionMS() 使用介质参数 σs,σa,g,η\\sigma_s,\\sigma_a,g,\\etaσs​,σa​,g,η 和半径 rrr ，根据我们上面的推导计算这一估计值，它会返回对指数项进行重要性采样 100 次的结果。 zr=−ln⁡(1−ξi)σt′z_r = -{\\ln(1 - \\xi_i) \\over \\sigma_t&#x27;} zr​=−σt′​ln(1−ξi​)​ 虽然对第二项进行分析可以提供更加准确的采样效果，但由于这一积分只会在预计算期间计算一次，我们并不特别关注这一估计值的性能表现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253Float BeamDiffusionMS(Float sigma_s, Float sigma_a, Float g, Float eta, Float r) &#123; const int nSamples = 100; Float Ed = 0; // Precompute information for dipole integrand // Compute reduced scattering coefficients $\\sigmaps, \\sigmapt$ and albedo // $\\rhop$ Float sigmap_s = sigma_s * (1 - g); Float sigmap_t = sigma_a + sigmap_s; Float rhop = sigmap_s / sigmap_t; // Compute non-classical diffusion coefficient $D_\\roman&#123;G&#125;$ using // Equation (15.24) Float D_g = (2 * sigma_a + sigmap_s) / (3 * sigmap_t * sigmap_t); // Compute effective transport coefficient $\\sigmatr$ based on $D_\\roman&#123;G&#125;$ Float sigma_tr = std::sqrt(sigma_a / D_g); // Determine linear extrapolation distance $\\depthextrapolation$ using // Equation (15.28) Float fm1 = FresnelMoment1(eta), fm2 = FresnelMoment2(eta); Float ze = -2 * D_g * (1 + 3 * fm2) / (1 - 2 * fm1); // Determine exitance scale factors using Equations (15.31) and (15.32) Float cPhi = .25f * (1 - 2 * fm1), cE = .5f * (1 - 3 * fm2); for (int i = 0; i &lt; nSamples; ++i) &#123; // Sample real point source depth $\\depthreal$ Float zr = -std::log(1 - (i + .5f) / nSamples) / sigmap_t; // Evaluate dipole integrand $E_&#123;\\roman&#123;d&#125;&#125;$ at $\\depthreal$ and add to // _Ed_ Float zv = -zr + 2 * ze; Float dr = std::sqrt(r * r + zr * zr), dv = std::sqrt(r * r + zv * zv); // Compute dipole fluence rate $\\dipole(r)$ using Equation (15.27) Float phiD = Inv4Pi / D_g * (std::exp(-sigma_tr * dr) / dr - std::exp(-sigma_tr * dv) / dv); // Compute dipole vector irradiance $-\\N&#123;&#125;\\cdot\\dipoleE(r)$ using // Equation (15.27) Float EDn = Inv4Pi * (zr * (1 + sigma_tr * dr) * std::exp(-sigma_tr * dr) / (dr * dr * dr) - zv * (1 + sigma_tr * dv) * std::exp(-sigma_tr * dv) / (dv * dv * dv)); // Add contribution from dipole for depth $\\depthreal$ to _Ed_ Float E = phiD * cPhi + EDn * cE; Float kappa = 1 - std::exp(-2 * sigmap_t * (dr + zr)); Ed += kappa * rhop * rhop * E; &#125; return Ed / nSamples;&#125; 15.5.7 单散射项 我们曾在 15.5.4 中为了简化计算忽略了公式中第一项单散射部分的求解，这一节中我们就要对它进行补全。 单散射项在介质中接近光源的位置，即 r→0r \\to 0r→0 的地方贡献了不可忽略的影响，我们可以简单地通过对原始的传输方程计算这一参数。对于路径积分的情况有： Lss(p1→p0)=P^(p‾2)=∫P1Le(p2→p1)T^(p0,p1,p2)dμ1(p2)Le(p,ω)=δ(p−pi)δ(ω+n)\\begin{gathered}L_{\\mathrm{ss}}\\left(\\mathrm{p}_{1} \\rightarrow \\mathrm{p}_{0}\\right)=\\widehat{P}\\left(\\overline{\\mathrm{p}}_{2}\\right)=\\int_{\\mathrm{P}_{1}} L_{\\mathrm{e}}\\left(\\mathrm{p}_{2} \\rightarrow \\mathrm{p}_{1}\\right) \\hat{T}\\left(\\mathrm{p}_{0}, \\mathrm{p}_{1}, \\mathrm{p}_{2}\\right) \\mathrm{d} \\mu_{1}\\left(\\mathrm{p}_{2}\\right) \\\\L_{\\mathrm{e}}(\\mathrm{p}, \\omega)=\\delta\\left(\\mathrm{p}-\\mathrm{p}_{\\mathrm{i}}\\right) \\delta(\\omega+\\mathbf{n})\\end{gathered} Lss​(p1​→p0​)=P(p​2​)=∫P1​​Le​(p2​→p1​)T^(p0​,p1​,p2​)dμ1​(p2​)Le​(p,ω)=δ(p−pi​)δ(ω+n)​ 它表示了从入点垂直入射进入介质的所有光线上的点形成的虚拟光源对出点经过一次散射的贡献值。我们接着对该项在所有体积内的点进行积分以得到出射的 irradiance ，有： ESS(p0)=∫P1LSS(p1→p0)G^(p1↔p0)dμ1(p1)=∫P2Le(p2→p1)T^(p0,p1,p2)G^(p1↔p0)dμ2(p1,p2)\\begin{aligned}E_{\\mathrm{SS}}\\left(\\mathrm{p}_{0}\\right) &amp;=\\int_{\\mathrm{P}_{1}} L_{\\mathrm{SS}}\\left(\\mathrm{p}_{1} \\rightarrow \\mathrm{p}_{0}\\right) \\hat{G}\\left(\\mathrm{p}_{1} \\leftrightarrow \\mathrm{p}_{0}\\right) \\mathrm{d} \\mu_{1}\\left(\\mathrm{p}_{1}\\right) \\\\&amp;=\\int_{\\mathrm{P}_{2}} L_{\\mathrm{e}}\\left(\\mathrm{p}_{2} \\rightarrow \\mathrm{p}_{1}\\right) \\hat{T}\\left(\\mathrm{p}_{0}, \\mathrm{p}_{1}, \\mathrm{p}_{2}\\right) \\hat{G}\\left(\\mathrm{p}_{1} \\leftrightarrow \\mathrm{p}_{0}\\right) \\mathrm{d} \\mu_{2}\\left(\\mathrm{p}_{1}, \\mathrm{p}_{2}\\right)\\end{aligned} ESS​(p0​)​=∫P1​​LSS​(p1​→p0​)G^(p1​↔p0​)dμ1​(p1​)=∫P2​​Le​(p2​→p1​)T^(p0​,p1​,p2​)G^(p1​↔p0​)dμ2​(p1​,p2​)​ 如图所示，通过把 LeL_eLe​ 带入式中，并展开传输率项 T^\\hat{T}T^ 、和传输函数 f^\\hat{f}f^​ ，我们接着将它转换为关于入点距离 ttt 的积分： Ess(po)=∫0∞t2G^(pi↔(pi−tn))σsp(−cos⁡θs)G^((pi−tn)↔po)dtE_{ss}(p_o) = \\int_0^\\infty t^2\\hat{G}(p_i \\leftrightarrow (p_i-t\\mathbf{n}))\\sigma_sp(-\\cos\\theta_s)\\hat{G}((p_i-t\\mathbf{n})\\leftrightarrow p_o)\\mathrm{d}t Ess​(po​)=∫0∞​t2G^(pi​↔(pi​−tn))σs​p(−cosθs​)G^((pi​−tn)↔po​)dt 其中的 t2t^2t2 项是由体积积分转换为对球坐标积分时引入的。 接着需要分析的是两个几何量 G^\\hat{G}G^ ，基于对介质均匀性的假设，我们很容易的就有： G^(pi↔(pi−tn))=e−σttt2G^((pi−tn)↔po)=e−σtdd2∣cos⁡θo∣=e−σtdd2∣cos⁡θs∣\\begin{aligned} \\hat{G}(p_i \\leftrightarrow (p_i-t\\mathbf{n})) = &amp; {e^{-\\sigma_tt} \\over t^2}\\\\ \\hat{G}((p_i-t\\mathbf{n}) \\leftrightarrow p_o) = &amp; {e^{-\\sigma_td} \\over d^2} |\\cos\\theta_o| = &amp; {e^{-\\sigma_td} \\over d^2} |\\cos\\theta_s| \\end{aligned}G^(pi​↔(pi​−tn))=G^((pi​−tn)↔po​)=​t2e−σt​t​d2e−σt​d​∣cosθo​∣=​d2e−σt​d​∣cosθs​∣​ 需要注意的是，在单散射项中我们使用的是原始的 σt\\sigma_tσt​ ，而非经过扩散假设变换后的那一个。这是因为在这一情况下各向异性的介质也是比较容易处理的。 最后，我们引入出射位置的菲涅尔项，既有： ESS,Fr(po)=∫0∞σse−σt(t+d)d2p(cos⁡θs)(1−Fr(η,cos⁡θo))∣cos⁡θo∣dtE_{\\mathrm{SS}, F_{\\mathrm{r}}}\\left(\\mathrm{p}_{\\mathrm{o}}\\right)=\\int_{0}^{\\infty} \\frac{\\sigma_{\\mathrm{s}} \\mathrm{e}^{-\\sigma_{\\mathrm{t}}(t+d)}}{d^{2}} p\\left(\\cos \\theta_{\\mathrm{s}}\\right)\\left(1-F_{\\mathrm{r}}\\left(\\eta, \\cos \\theta_{\\mathrm{o}}\\right)\\right)\\left|\\cos \\theta_{\\mathrm{o}}\\right| \\mathrm{d} t ESS,Fr​​(po​)=∫0∞​d2σs​e−σt​(t+d)​p(cosθs​)(1−Fr​(η,cosθo​))∣cosθo​∣dt 特别地，对于相对折射率 η&gt;1\\eta &gt; 1η&gt;1 的情况下，我们还可以将全反射考虑在内，从而缩小需要积分的区域为 (tcrit,∞)(t_{crit}, \\infty)(tcrit​,∞) ，使用几何光学方法易得： tcrit=rη2−1t_{crit} = r \\sqrt{\\eta^2 - 1} tcrit​=rη2−1​ 和多散项一样，我们同样只对指数衰减项做重要性采样，从而有： ti=tcrit−ln⁡(1−ξi)σtPDF(t)=σte−σt(t−tcrit)t_i = t_{crit} - {\\ln(1 - \\xi_i) \\over \\sigma_t}\\\\ \\mathrm{PDF}(t) = \\sigma_te^{-\\sigma_t(t-t_{crit})}ti​=tcrit​−σt​ln(1−ξi​)​PDF(t)=σt​e−σt​(t−tcrit​) 和计算多散项相似的，BeamDiffusionSS 负责返回对这一值的估计。 12345678910111213141516171819202122Float BeamDiffusionSS(Float sigma_s, Float sigma_a, Float g, Float eta, Float r) &#123; // Compute material parameters and minimum $t$ below the critical angle Float sigma_t = sigma_a + sigma_s, rho = sigma_s / sigma_t; Float tCrit = r * std::sqrt(eta * eta - 1); Float Ess = 0; const int nSamples = 100; for (int i = 0; i &lt; nSamples; ++i) &#123; // Evaluate single scattering integrand and add to _Ess_ Float ti = tCrit - std::log(1 - (i + .5f) / nSamples) / sigma_t; // Determine length $d$ of connecting segment and $\\cos\\theta_\\roman&#123;o&#125;$ Float d = std::sqrt(r * r + ti * ti); Float cosThetaO = ti / d; // Add contribution of single scattering at depth $t$ Ess += rho * std::exp(-sigma_t * (d + tCrit)) / (d * d) * PhaseHG(cosThetaO, g) * (1 - FrDielectric(-cosThetaO, 1, eta)) * std::abs(cosThetaO); &#125; return Ess / nSamples;&#125; 15.5.8 填充 BSSRDFTable 函数 ComputeBeamDiffusionBSSRDF() 负责根据给定的 g,ηg, \\etag,η 项生成一个预计算的 BSSRDFTable 。由于 SrS_rSr​ 是根据半径的指数递减的，在储存表格时采样位置也会以指数储存： 12345// Choose radius values of the diffusion profile discretizationt-&gt;radiusSamples[0] = 0;t-&gt;radiusSamples[1] = 2.5e-3f;for (int i = 2; i &lt; t-&gt;nRadiusSamples; ++i) t-&gt;radiusSamples[i] = t-&gt;radiusSamples[i - 1] * 1.2f; 上图展示了散射定义的 albedo 和多次散射实际上产生的 albedo 之间的差异。这种非线性的关系对于艺术家调整参数时是非常不友好的，因此我们一般会使用 ρeff\\rho_{eff}ρeff​ 作为参数。而在 BSSRDFTable 的储存上我们则会以非线性的间隔放置 albedo ： ρi=1−e−8i/(N−1)1−e−8\\rho_i = {1 - e^{-8i/(N-1)} \\over 1 - e^{-8}} ρi​=1−e−81−e−8i/(N−1)​ 接着上述的计算单次散射和多次散射的函数会被用于计算 rho, rhoEff 。 123456789101112// Compute scattering profile for chosen albedo $\\rho$for (int j = 0; j &lt; t-&gt;nRadiusSamples; ++j) &#123; Float rho = t-&gt;rhoSamples[i], r = t-&gt;radiusSamples[j]; t-&gt;profile[i * t-&gt;nRadiusSamples + j] = 2 * Pi * r * (BeamDiffusionSS(rho, 1 - rho, g, eta, r) + BeamDiffusionMS(rho, 1 - rho, g, eta, r));&#125;// Compute effective albedo $\\rho_&#123;\\roman&#123;eff&#125;&#125;$ and CDF for importance samplingt-&gt;rhoEff[i] = IntegrateCatmullRom(t-&gt;nRadiusSamples, t-&gt;radiusSamples.get(), &amp;t-&gt;profile[i * t-&gt;nRadiusSamples], &amp;t-&gt;profileCDF[i * t-&gt;nRadiusSamples]); 其中 IntegrateCatmullRom 的细节此处暂且略过。 15.5.9 设置散射参数 在散射中，设置参数 σs,σa\\sigma_s, \\sigma_aσs​,σa​ 的过程是极其不直观的，调整这两个参数以获得期望的视觉表现的过程极其复杂且非线性。本节中定义了一个更加简单的工具函数 SubsurfaceFromDiffuse ，它被用于 KdSubsurfaceMaterial 中以解决参数不直观的问题。 它的输入只有两个参数：ρeff\\rho_{eff}ρeff​ 和平均自由程的长度。这一函数会根据这两个参数逆推出 ρ, σs, σt\\rho,\\ \\sigma_s,\\ \\sigma_tρ, σs​, σt​ 等参数。 123456789void SubsurfaceFromDiffuse(const BSSRDFTable &amp;t, const Spectrum &amp;rhoEff, const Spectrum &amp;mfp, Spectrum *sigma_a, Spectrum *sigma_s) &#123; for (int c = 0; c &lt; Spectrum::nSamples; ++c) &#123; Float rho = InvertCatmullRom(t.nRhoSamples, t.rhoSamples.get(), t.rhoEff.get(), rhoEff[c]); (*sigma_s)[c] = rho / mfp[c]; (*sigma_a)[c] = (1 - rho) / mfp[c]; &#125;&#125;","categories":[{"name":"programming","slug":"programming","permalink":"https://blog.apassbydreg.work/categories/programming/"},{"name":"reading notes","slug":"programming/reading-notes","permalink":"https://blog.apassbydreg.work/categories/programming/reading-notes/"}],"tags":[{"name":"CG","slug":"CG","permalink":"https://blog.apassbydreg.work/tags/CG/"},{"name":"render","slug":"render","permalink":"https://blog.apassbydreg.work/tags/render/"},{"name":"PBRT","slug":"PBRT","permalink":"https://blog.apassbydreg.work/tags/PBRT/"}]},{"title":"RTR 第二章笔记 | Notes for Realtime Rendering Chapter 02 - The Graphics Render Pipeline","slug":"RTR-ch02","date":"2021-12-19T16:33:17.000Z","updated":"2021-12-19T16:41:27.025Z","comments":true,"path":"2021/12/RTR-ch02/","link":"","permalink":"https://blog.apassbydreg.work/2021/12/RTR-ch02/","excerpt":"","text":"本章描述了实时渲染中最核心的部分——渲染管线。它根据给定的场景设定、摄像机等参数渲染二维图像。 总体架构 渲染管线中 pipeline 一词的含义和 CPU 流水线相近，各个部分只依赖前一部分的结果工作，因此在理论上一个分为 n 级的流水线可以至多有 n 倍的加速效果。 在 RTR 中渲染管线被分为四个部分：Application, Geometry Processing, Rasterizatioin, Pixel Processing 。他们将在接下来的章节中被一一讲解。 第一个阶段，应用阶段，正如其名所表示的，是应用程序驱动的。程序开发者拥有着对这一阶段的完全控制权。 接下来的几何处理阶段则负责处理几何体的变换、投影等一系列操作。这一阶段负责计算哪些几何体应该被绘制、这些几何体会被如何绘制、以及它们是否会被绘制。 第三个光栅化阶段通常会以 3 个顶点形成的一个三角形作为输入，接着找到三角形内的像素，并将这些像素交给下一阶段（RTR3 中这两个阶段并没有分开）。 最后，像素处理阶段负责在每个汇报的像素上运行着色、深度测试等工作。 一般而言，应用阶段主要运行在 CPU 上，而后三个阶段则主要运行在 GPU 上。而且在一个阶段中有时还会被切分为子阶段以更好地完成任务。 应用阶段（Application Stage） 虽然应用阶段在大部分情况下是由 CPU 执行的，但它也可以利用 compute shader 将 GPU 视作一个高度并行的通用运算器以提高效率。另一个提高效率的做法是利用 CPU 的多个核心和线程，或者某些特殊指令集特性做一定程度的并行计算。 在应用阶段中最常处理的工作包括了碰撞检测、物理模拟、动画等等。这一阶段同样负责处理输入、实现加速算法（如 culling ）等其它阶段无法处理的工作。 在这一阶段的结尾，需要被渲染的几何体会被传入几何处理阶段，他们被称为 rendering primitives 。 几何处理阶段（Geometry Processing Stage） 在几何处理阶段，GPU 主要负责的就是基于三角形和顶点的一系列操作。它一般被分为以下四个阶段： Vertex Shading 这一阶段的主要人物有两个： 确定顶点的位置 根据程序员的要求指定顶点附加的数据 传统的做法是在每个顶点上计算光照并保存着色结果在顶点上，接着通过插值各个顶点的颜色以填充三角形。因此，负责这一过程程序名为 vertex shader 。随着 GPU 的发展，这一过程已经变得更为通用，并通常不再计算着色结果了。现在的 vertex shader 更多用于生成和记录顶点的数据，如生成部分着色用的数据、应用动画等。 一般而言，投影的过程也在这一阶段发生，程序会先用 Model - View 变换矩阵得到相机空间的物体表示，接着经由 Projection 矩阵得到投影位置。投影后视锥体内的场景被变换为一个对角线在 (−1,−1,−1), (1,1,1)(-1,-1,-1),\\ (1,1,1)(−1,−1,−1), (1,1,1) 的立方体，称为 canonical view volume 。 Optional Vertex Processing 在上一流程结束后，根据硬件平台和软件设定的不同可能有以下的几个可选的流程，按调用顺序排列如下： 曲面细分（tessellation）：这一流程可以结合场景和相机的设置，为几何体生成合适数量的三角形，以保证在显示和效率上达到一个最优点 geometry shader：这一流程与曲面细分有些相似——它们均通过输入信息生成新的顶点和三角形。但这一部分负责的则是更简单的内容，如为基于点的粒子生成负责渲染的几何体等 stream output：这一流程会截获将要输入接下来的管线的数据并写入一个序列中以便 CPU 或 GPU 在接下来的自定义流程中用到 Clipping 只有在视锥体，或投影后在裁剪空间（等效于之前的 canonical view volume ）内的三角形才需要被渲染，这一步骤会剔除该空间外的三角形，并通过算法将部分在空间外的三角形裁剪至只包含空间内的部分。 需要注意的是，在裁剪发生时，生成的新顶点的各项属性并不都是被线性插值得到的。对于透视投影，需要除以一个投影系数以纠正数值误差。 除此之外，用户也可以自己指定裁剪平面以生成需要的效果。 Screen Mapping 几何处理阶段的最后一件事是将裁剪后的坐标投影到对应的屏幕坐标上。这一点在不同 API 的实现有所不同，主要是因为它们对屏幕坐标的定义有所差别。但基本上都会完成从浮点数的坐标转换到整数的像素坐标上这一步。像素的中心点一般定义在对应区域的中心位置，即： d=⌊c⌋c=d+0.5\\begin{aligned} d &amp; = \\lfloor c \\rfloor\\\\ c &amp; = d + 0.5 \\end{aligned}dc​=⌊c⌋=d+0.5​ 光栅化阶段（Rasterization） 给定了屏幕空间的顶点和它们对应的着色信息，这一阶段的目标在于找到所有在几何体内的的像素以进行着色。他拥有三角形初始化和三角形遍历两个子步骤（虽然名为「三角形」，但实际上可以处理如线段等其它几何体）。 在 RTR 3ed 中，上述四个步骤均属于 Rasterization 阶段，本版将后两者进行了合并 Triangle Setup 在这一步骤中，微分、边函数以及其它与三角形有关的数据被计算。它们会在三角形遍历和像素插值中被使用到。 Triangle Traversal 在这一步中，所有在三角形内的像素会被找到（根据设置的不同，定义一个像素在三角形内部的方法也不同）。对于每个判断在三角形内部的像素（或采样），会根据三个顶点的插值生成一份顶点数据，接着被送入下一步骤中进行着色。 像素处理阶段（Pixel Processing） 这一阶段的处理并行于每个像素或采样之上，并如上一节图中的右侧一样被分为了着色和合并两个子阶段。 Pixel Shading 任何像素级别的操作均在这一阶段完成。利用插值后的顶点数据，最终输出一个或者多个颜色值给接下来的流程。与此前的几何处理和光栅化通常由 GPU 中预先设置好的物理模块运行不同，这一模块会使用 GPU 中的可编程模块以便程序员使用 pixel/fragment shader 自定义着色流程。 Merging 每个像素的信息会被存放在一个或者数个 buffer 之中，这一阶段就决定了哪些信息会被写入 buffer 中。和着色阶段不同，这一部分可被自定义的内容就少很多了。 这一部分的另一个作用是处理可见性。当整个场景被渲染时，应该只有可见的物体会最终被写入 buffer 中。大部分可见性的处理均是通过 z-buffer 或深度缓存完成的。 模板（stencil）buffer 是另一个常用的缓冲区，它一般会用于记录对应像素分别对应了哪个和模板测试有关的物体。这一缓冲区通常会在需要生成一些特殊效果（如以某一物体的区域作为蒙版）时用到。这些操作又被称为 blending 。 最终，所有使用到的缓冲区一般统称为 framebuffer 。 当这一流程结束后，如果没有后续的进一步处理，frame buffer 中的 color buffer 会被显示在屏幕上。为了防止对正在显示的图像进行直接操作，会使用双缓冲方法，交替地使用两个缓冲分别作为显示缓冲和写入缓冲。 总结 这一渲染管线经历了数十年的 API 和 GPU 的针对实时渲染应用发展，最终演进至今。但它并不是唯一的渲染管线。离线渲染具有着另一套流程，如影视制作中曾经使用过的 micropolygon 管线和光线追踪管线。 多年来，开发者大多数使用一个由图形 API 定义的 fixed-function pipeline 进行研发，这种性质一直持续到 2006 年发布的任天堂 Wii 管线。随着可编程 GPU 的出现，程序员得以深入定制管线中的部分子部分以实现更丰富和优秀的效果。","categories":[{"name":"programming","slug":"programming","permalink":"https://blog.apassbydreg.work/categories/programming/"},{"name":"reading notes","slug":"programming/reading-notes","permalink":"https://blog.apassbydreg.work/categories/programming/reading-notes/"}],"tags":[{"name":"CG","slug":"CG","permalink":"https://blog.apassbydreg.work/tags/CG/"},{"name":"render","slug":"render","permalink":"https://blog.apassbydreg.work/tags/render/"},{"name":"RTR","slug":"RTR","permalink":"https://blog.apassbydreg.work/tags/RTR/"}]},{"title":"PBRT 第十四章笔记 | Notes for PBRT Chapter 14 - Light Transport I > Surface Reflection (basis)","slug":"PBRT-ch14","date":"2021-12-18T14:42:10.000Z","updated":"2022-02-15T09:41:41.312Z","comments":true,"path":"2021/12/PBRT-ch14/","link":"","permalink":"https://blog.apassbydreg.work/2021/12/PBRT-ch14/","excerpt":"","text":"14.1 Sampling Reflection Functions BxDF::Sample_f() 函数会根据底层的散射函数采样一个出射光线，它接收来自 U[0,1]2U[0,1]^2U[0,1]2 的随机数，输出采样方向、经散射出射的光线 BSDF 值以及本次采样对应的固体角上的 PDF 。 在默认情况下，这一函数会使用 cos⁡\\coscos 加权的半球采样方法采样光线，这对于大部分非 delta 分布的 BRDF 都是一种可接受的采样方法（但这意味着需要在整个球面内采样的 BTDF 必须重载这一方法）。默认的实现同样会在光线从法线另一侧入射时翻转出射光线，从而保证出射与入射方向在法线的同一侧。（即物体的两面都已相同的材质参数反射光线） 14.1.1 Microfacet BxDFs 在 8.4 节中提到的微表面模型使用 D(ωh)D(\\omega_h)D(ωh​) 描述了镜面反射 / 折射的表面法线分布。由于这一函数对 Torrance–Sparrow 模型的最终 BSDF 曲线影响极大，对于这一分布进行采样，再使用微表面法线计算反射或折射的光线就成为了一种非常有效的方法。为此 MicrofacetDistribution 中实现了从出射光线和宏观法线采样微表面法线的方法 Sample_wh 。 直接采样法线分布 一种采样方法是直接对 DDD 进行采样，以各向同性的 Beckmann 分布为例，其两个参数是可分的，即 p(θ,ϕ)=p(θ)p(ϕ)p(\\theta,\\phi) = p(\\theta)p(\\phi)p(θ,ϕ)=p(θ)p(ϕ) ，由于其各项同性，易有： p(ϕ)=12π, ϕ=2πξp(\\phi) = {1 \\over 2\\pi},\\ \\phi = 2\\pi\\xi p(ϕ)=2π1​, ϕ=2πξ 而由于： ∫H2(n)p(θ,ϕ)dθdϕ=1∫H2(n)D(ωh)cos⁡θhdωh=∫H2(n)D(ωh)cos⁡θhsin⁡θhdθdϕ=1\\int_{H^2(n)} p(\\theta, \\phi)\\mathrm{d}\\theta\\mathrm{d}\\phi = 1\\\\ \\int_{H^2(n)} D(\\omega_h)\\cos\\theta_h\\mathrm{d}\\omega_h = \\int_{H^2(n)} D(\\omega_h)\\cos\\theta_h\\sin\\theta_h\\mathrm{d}\\theta\\mathrm{d}\\phi = 1 ∫H2(n)​p(θ,ϕ)dθdϕ=1∫H2(n)​D(ωh​)cosθh​dωh​=∫H2(n)​D(ωh​)cosθh​sinθh​dθdϕ=1 有： p(θ)=D(θ,ϕ)sin⁡θcos⁡θp(ϕ)=2e−tan⁡2θ/α2sin⁡θα2cos⁡3θp(\\theta) = {D(\\theta,\\phi)\\sin\\theta\\cos\\theta \\over p(\\phi)} = {2e^{-\\tan^2\\theta / \\alpha^2}\\sin\\theta \\over \\alpha^2\\cos^3\\theta} p(θ)=p(ϕ)D(θ,ϕ)sinθcosθ​=α2cos3θ2e−tan2θ/α2sinθ​ 对其积分得到 CDF ： Ph(θ′)=∫0θ′2e−tan⁡2θ/α2sin⁡θα2cos⁡3θdθ=1−e−tan⁡2θ′/α2\\begin{aligned}P_{\\mathrm{h}}\\left(\\theta^{\\prime}\\right) &amp;=\\int_{0}^{\\theta^{\\prime}} \\frac{2 \\mathrm{e}^{-\\tan ^{2} \\theta / \\alpha^{2}} \\sin \\theta}{\\alpha^{2} \\cos ^{3} \\theta} \\mathrm{d} \\theta \\\\&amp;=1-\\mathrm{e}^{-\\tan ^{2} \\theta^{\\prime} / \\alpha^{2}}\\end{aligned} Ph​(θ′)​=∫0θ′​α2cos3θ2e−tan2θ/α2sinθ​dθ=1−e−tan2θ′/α2​ 则从 ξ∼U[0,1]\\xi \\sim U[0,1]ξ∼U[0,1] 转换到该分布的转换方式如下： ξ=1−e−tan2θ/α2tan⁡2θ=−α2log⁡(1−ξ)\\begin{aligned} \\xi &amp;= 1 - e^{-tan^2\\theta / \\alpha^2}\\\\ \\tan^2\\theta &amp;= -\\alpha^2\\log(1-\\xi) \\end{aligned}ξtan2θ​=1−e−tan2θ/α2=−α2log(1−ξ)​ 而有了 tan⁡2θ\\tan^2\\thetatan2θ 后，我们就可以轻易得到 cos⁡2θ,cos⁡θ\\cos^2\\theta, \\cos\\thetacos2θ,cosθ 等用于计算位置值的参数了。 只采样可视法线 在给定入射光的方向时，并不是所有微表面模型的法线都是可见的，采样不可见的法线会造成计算的浪费。在给定出射方向 ω\\omegaω 时，可见法线的分布实际上应该如下： Dω(ωh)=D(ωh)G1(ω,ωh)max⁡(0,ω⋅ωh)cos⁡θD_\\omega(\\omega_h) = {D(\\omega_h)G_1(\\omega,\\omega_h)\\max(0, \\omega\\cdot\\omega_h) \\over \\cos\\theta} Dω​(ωh​)=cosθD(ωh​)G1​(ω,ωh​)max(0,ω⋅ωh​)​ 这一公式的正确性可以由对 G1G_1G1​ 的定义侧面佐证： cos⁡θ=∫H2(n)G1(ω,ωh)max⁡(0,ω⋅ωh)D(ωh)dωh.\\cos \\theta=\\int_{\\mathrm{H}^{2}(\\mathbf{n})} G_{1}\\left(\\omega, \\omega_{\\mathrm{h}}\\right) \\max \\left(0, \\omega \\cdot \\omega_{\\mathrm{h}}\\right) D\\left(\\omega_{\\mathrm{h}}\\right) \\mathrm{d} \\omega_{\\mathrm{h}} . cosθ=∫H2(n)​G1​(ω,ωh​)max(0,ω⋅ωh​)D(ωh​)dωh​. 它首先通过一个 G1G_1G1​ 项代表自阴影，进而用 max⁡(0,ω⋅ωh)/cos⁡θ\\max(0, \\omega\\cdot\\omega_h) / \\cos\\thetamax(0,ω⋅ωh​)/cosθ 将面积投影回单位表面积上。下图展示了 cos⁡θo=0.1,α=0.3\\cos\\theta_o = 0.1, \\alpha = 0.3cosθo​=0.1,α=0.3 时两种采样方式产生的概率 lobe 的区别： 最后，我们需要对这种采样的 PDF 进行转换，因为我们进行采样时采样的是微表面的法线，但实际上我们需要的是入射光线的分布。为了进行 PDF 的转换，我们需要计算采样的微分。 由上图可得：dϕi=dϕh,dθi=2dθh\\mathrm{d}\\phi_i = \\mathrm{d}\\phi_h, \\mathrm{d}\\theta_i = 2\\mathrm{d}\\theta_hdϕi​=dϕh​,dθi​=2dθh​ ，则有： dωhdωi=sin⁡θhdθhdϕhsin⁡θidθirϕi=sin⁡θhdθhdϕhsin⁡2θh2 dθhdϕh=sin⁡θh4cos⁡θhsin⁡θh=14cos⁡θh=14(ωi⋅ωh)=14(ωo⋅ωh)\\begin{aligned}\\frac{\\mathrm{d} \\omega_{\\mathrm{h}}}{\\mathrm{d} \\omega_{\\mathrm{i}}} &amp;=\\frac{\\sin\\theta_h\\mathrm{d}\\theta_h\\mathrm{d}\\phi_h}{\\sin\\theta_i\\mathrm{d}\\theta_i\\mathrm{r}\\phi_i} \\\\&amp;=\\frac{\\sin \\theta_{\\mathrm{h}} \\mathrm{d} \\theta_{\\mathrm{h}} \\mathrm{d} \\phi_{\\mathrm{h}}}{\\sin 2 \\theta_{\\mathrm{h}} 2 \\mathrm{~d} \\theta_{\\mathrm{h}} \\mathrm{d} \\phi_{\\mathrm{h}}} \\\\&amp;=\\frac{\\sin \\theta_{\\mathrm{h}}}{4 \\cos \\theta_{\\mathrm{h}} \\sin \\theta_{\\mathrm{h}}} \\\\&amp;=\\frac{1}{4 \\cos \\theta_{\\mathrm{h}}} \\\\&amp;=\\frac{1}{4\\left(\\omega_{\\mathrm{i}} \\cdot \\omega_{\\mathrm{h}}\\right)}=\\frac{1}{4\\left(\\omega_{\\mathrm{o}} \\cdot \\omega_{\\mathrm{h}}\\right)}\\end{aligned} dωi​dωh​​​=sinθi​dθi​rϕi​sinθh​dθh​dϕh​​=sin2θh​2 dθh​dϕh​sinθh​dθh​dϕh​​=4cosθh​sinθh​sinθh​​=4cosθh​1​=4(ωi​⋅ωh​)1​=4(ωo​⋅ωh​)1​​ 因此对于任何采样 ωh\\omega_hωh​ 的微表面分布，其 PDF 需要在微表面的 PDF 之上额外除以 4cos⁡θh4\\cos\\theta_h4cosθh​，即： p(θ)=ph(θh)4(ωo⋅ωh)p(\\theta) = {p_h(\\theta_h)\\over 4(\\omega_o \\cdot \\omega_h)} p(θ)=4(ωo​⋅ωh​)ph​(θh​)​ 14.1.2 FresnelBlend 回顾 FresnelBlend 的定义，它混合了一个微表面材质和一个 Lambertian 材质。在采样时，我们假设这两个材质对出射的贡献是相当的，因此我们会以各 50% 的概率采样两个分布。而其 PDF 也就相当于两个分布 PDF 的算术均值。 在实现中，我们利用 ξ1\\xi_1ξ1​ 判断用于采样的分布，接着将 ξ1\\xi_1ξ1​ 重新映射到 U[0,1]U[0,1]U[0,1] 上。 14.1.3 Specular Reflection and Transmission 正如之前讨论过的，镜面反射和折射的光路是唯一确定的，因而其 PDF 是一个无法被采样的 delta 分布，任何该方向外的光线的 PDF 均为零，而对应方向上的 PDF 则是无穷大。 PBRT 中 FresnelSpecular 类型同时包装了反射和折射两种情况。它使用菲涅尔项作为选择传输模式的概率，从二者选出一种传输方式采样。 14.1.4 Fourier BSDF ⚠️ 这一部分讲解了傅里叶 BSDF 的采样方法，此处暂且跳过 14.1.5 Application: Estimating Reflectance 回顾反射率的定义： ρhd(ωo)=∫H2(n)fr(ωo,ωi)∣cos⁡θi∣dωi.ρhh=1π∫H2(n)∫H2(n)fr(ω′,ω′′)∣cos⁡θ′cos⁡θ′′∣dω′dω′′,\\begin{aligned}\\rho_{\\mathrm{hd}}\\left(\\omega_{\\mathrm{o}}\\right) &amp;=\\int_{\\mathrm{H}^{2}(\\mathbf{n})} f_{\\mathrm{r}}\\left(\\omega_{\\mathrm{o}}, \\omega_{\\mathrm{i}}\\right)\\left|\\cos \\theta_{\\mathrm{i}}\\right| \\mathrm{d} \\omega_{\\mathrm{i}} . \\\\\\rho_{\\mathrm{hh}} &amp;=\\frac{1}{\\pi} \\int_{\\mathrm{H}^{2}(\\mathbf{n})} \\int_{\\mathrm{H}^{2}(\\mathbf{n})} f_{\\mathrm{r}}\\left(\\omega^{\\prime}, \\omega^{\\prime \\prime}\\right)\\left|\\cos \\theta^{\\prime} \\cos \\theta^{\\prime \\prime}\\right| \\mathrm{d} \\omega^{\\prime} \\mathrm{d} \\omega^{\\prime \\prime},\\end{aligned} ρhd​(ωo​)ρhh​​=∫H2(n)​fr​(ωo​,ωi​)∣cosθi​∣dωi​.=π1​∫H2(n)​∫H2(n)​fr​(ω′,ω′′)∣cosθ′cosθ′′∣dω′dω′′,​ 使用蒙特卡洛方法估计这两个值： ρhd≈1N∑jNfr(ω,ωj)∣cos⁡θj∣p(ωj)ρhh≈1πN∑jNfr(ωj′,ωj′′)∣cos⁡θj′cos⁡θj′′∣p(ωj′)p(ωj′′)\\begin{aligned} \\rho_{hd} &amp;\\approx\\frac{1}{N} \\sum_{j}^{N} \\frac{f_{\\mathrm{r}}\\left(\\omega, \\omega_{j}\\right)\\left|\\cos \\theta_{j}\\right|}{p\\left(\\omega_{j}\\right)} \\\\ \\rho_{hh} &amp;\\approx\\frac{1}{\\pi N} \\sum_{j}^{N} \\frac{f_{\\mathrm{r}}\\left(\\omega_{j}^{\\prime}, \\omega_{j}^{\\prime \\prime}\\right)\\left|\\cos \\theta_{j}^{\\prime} \\cos \\theta_{j}^{\\prime \\prime}\\right|}{p\\left(\\omega_{j}^{\\prime}\\right) p\\left(\\omega_{j}^{\\prime \\prime}\\right)}\\end{aligned}ρhd​ρhh​​≈N1​j∑N​p(ωj​)fr​(ω,ωj​)∣cosθj​∣​≈πN1​j∑N​p(ωj′​)p(ωj′′​)fr​(ωj′​,ωj′′​)∣∣​cosθj′​cosθj′′​∣∣​​​ 14.1.6 Sampling BSDFs 由于 BSDF 中储存了一个或多个 BxDF ，在 PBRT 中实际采样的则是它们的 PDF 均值： p(ω)=1N∑i=1Npi(ω)p(\\omega) = {1 \\over N}\\sum_{i=1}^N p_i(\\omega) p(ω)=N1​i=1∑N​pi​(ω) BSDF::Sample_f() 函数接收两个随机数和入射光线的世界坐标为输入值，接着使用第一个随机数选择采样的分布编号（随后会将改随机数缩放回对应 U[0,1]U[0,1]U[0,1] 分布）。紧接着调用对应的 BxDF::Sample_f 生成光线、在该采样上调用所有 BxDF::Pdf 计算 PDF 的均值，最后调用 BxDF::f 计算传输率的均值并返回。 14.2 Sampling Light Sources 对表面采样有可能有入射光线的位置是另一种重要性采样的重要方式。考虑一个 diffuse 的球体被一个相对较小的光源照亮的场景，当在表面上随机采样时，只有很小一部分的光源会采样到光源本身上，从而大大降低了收敛的速度。 对于光源而言，有两个必须实现的采样函数：Sample_Li 负责采样一条可能有来自该光源的入射方向，并返回对应的 radiance ；以及会在 16 章描述的 Sample_Le 。 光源的 Light::Pdf_Li 函数则与表面模型的 PDF 函数类似，它通过给定着色点和入射方向返回对于该光源和采样模式下的 PDF 。 14.2.1 采样 delta 分布的光源 正如镜面反射和折射的表面，使用 delta 分布定义的光源的光路是唯一确定的，这导致它的 PDF 在除了光源方向外的所有位置均为 0 。另外将 Sample_Li 的 PDF 设为 1 以表示这条光路上的 radiance 就是光源的全部贡献。详细的实现方法在 12 章中已有描述。 14.2.2 采样面光源 在 PBRT 中，面光源是通过在一个 Shape 上附加发光特性而定义的。因此，为了采样这类光源，我们需要在物体表面均匀地生成样本。为了满足这一要求，在 Shape 类中设计了接口 Shape::Sample 。 PBRT 中实现了两种采样方法和他们对应的 PDF 计算函数： 第一种方法使用和表面积相关的采样分布在物体表面采样一点，并返回对应的 SurfaceInteraction 。除此之外它还需要初始化浮点误差 pError 以计算高鲁棒性的采样位置。对于这种方式而言，由于其样本是按表面积均匀地分布的，因此其 PDF 就相当与总表面积的倒数：p=1/Ap = 1 / Ap=1/A 。 第二种方法则同时输入了需要着色的目标点 SurfaceInteraction 信息，以辅助在采样的过程中尽量不生成对该位置没有贡献的样本。与第一种方法返回基于表面积的概率不同的是，这一方法下的 PDF 函数返回的概率密度是基于着色点的立体角的一个值。 为了计算这一 PDF ，首先需要测试光线是否和光源几何体相交，如果不相交则 PDF 会被设为零（由于这样的样本不应该被生成或计算，这种方法是有效的，而且仅仅与一个物体求交的速度也是相对较快的）。下一步，为了将定义在光源面积上的 PDF 转换为定义在固体角上的 PDF ，我们有： dωidA=cos⁡θor2{\\mathrm{d}\\omega_i \\over \\mathrm{d}A} = {\\cos\\theta_o\\over r^2} dAdωi​​=r2cosθo​​ 采样圆盘 对圆盘的采样并不复杂，在上一章中我们讨论了如何在单位圆中进行采样，在这里也只需要首先从单位圆上采样、接着将样本转换到对应的位置上即可。 PBRT 中的采样方法并没有考虑圆盘的 innerRadius 和 pMax ，为了支持这两个特征还需要对采样方式进行更进一步的修改。 采样圆柱 对柱面的采样并没有什么特别的：对高度和 ϕ\\phiϕ 值的采样均是均匀地，只要简单地把来自 U[0,1]2U[0,1]^2U[0,1]2 的样本映射到圆柱坐标上即可 采样三角形 从上一节中我们得到了返回均匀采样的重心坐标的函数 UniformSampleTriangle 。我们会使用它返回的重心坐标经过顶点位置插值得到最后的采样点。 采样球体 采样球体的方式同样由之前的 UniformSampleSphere 可得。和 Disk 一样 PBRT 中也没有支持对被切割过的球的采样。 虽然在整个球体上采样毫无疑问是正确的，但更加有效的方法是只采样对于着色点可见的那一部分。PBRT 在由球和着色点确定的立体角中进行采样。 为了实现这一点，首先会计算一个着色点上的局部坐标系，其中 zzz 轴指向由着色点指向圆心的方向。接着根据相切的正交性可以判断采样的锥体内的 θmax⁡\\theta_{\\max}θmax​。 在得到了采样的锥体后，我们就可以在这上面做固体角上的均匀采样了。将均匀采样转换为球体表面坐标的方法如下三步： 通过如上方法获得的 α\\alphaα 结合之前采样的 ϕ\\phiϕ 就可以确定球上一点了。 个人感觉把局部坐标系的原点放在球体中心会不会好一些，但这要考虑 PDF 的转换 对于样本对应的 PDF ，PBRT 会考虑采样方法的性质：对于在球体内部的点，会将 PDF 直接交由底层的 Shape::Pdf 处理以转换成固体角的 PDF ，而对于更一般的情况，则会返回之前所言的锥体上的 PDF 。 14.2.3 范围光源 有了之前的采样 Shape 的方法，漫反射面光源的 Sample_Li() 方法的实现就显而易见了： 12345678910Spectrum DiffuseAreaLight::Sample_Li(const Interaction &amp;ref, const Point2f &amp;u, Vector3f *wi, Float *pdf, VisibilityTester *vis) const &#123; Interaction pShape = shape-&gt;Sample(ref, u); pShape.mediumInterface = mediumInterface; *wi = Normalize(pShape.p - ref.p); *pdf = shape-&gt;Pdf(ref, *wi); *vis = VisibilityTester(ref, pShape); return L(pShape, -*wi);&#125; 而 Pdf_Li() 方法也仅是简单地转发 Shape::Pdf 接口即可。 14.2.4 无穷范围光源 在无穷远面光源的使用中，采用的光照贴图常常并不是均匀的，对于这类光源进行重要性采样就成了一个重要的减少方差的手段。采样这类光源的方法如下： 使用贴图的辐照度初始化一个离散的二维 PDF 在该 PDF 上进行重要性采样 将 PDF 从 (u,v)(u,v)(u,v) 坐标转换到球坐标上 需要注意的是，虽然 PDF 和贴图的大小是相同的，但其中的值已经被双线性插值平滑过了。这是为了尽可能地避免出现零值的 PDF： 由于 PBRT 中使用的映射是 θ=πu, ϕ=2πv\\theta = \\pi u, \\ \\phi = 2\\pi vθ=πu, ϕ=2πv ，在转换时就需要将每一行的 PDF 均除以 sin⁡θ\\sin\\thetasinθ 以调整这种映射带来的畸变。（没搞明白这里为啥不用 sin⁡θ\\sin\\thetasinθ 分布映射） 14.3 Direct Lighting 在引入一般的光线传输方程之前，首先介绍的是 DirectLightingIntegrator 。它只对场景中的直接光照进行着色，忽略所有间接光照。 PBRT 中提供了两种策略来计算直接光照，它们均是无偏的。第一种策略 UniformSampleAll 会遍历所有光源并根据对应光源的 Light::nSamples 采样，最后将各个光源的贡献相加。而第二种策略 UniformSampleOne 则随机地选择一个光源采样一次。一般而言，当图片的 SPP 较高时，可以选择后者以节省运行消耗，反之则需要使用前者降低噪声。 为了构建一个 DirectLightingIntegrator 对象，我们需要传入一个 Camera 和一个 Sampler 对象到 SamplerIntergrator 基类的构造函数中，并初始化计算策略和对于镜面反射和折射能使用的最大递归层数。 123456789101112131415161718192021222324// LightStrategy Declarationsenum class LightStrategy &#123; UniformSampleAll, UniformSampleOne &#125;;// DirectLightingIntegrator Declarationsclass DirectLightingIntegrator : public SamplerIntegrator &#123; public: // DirectLightingIntegrator Public Methods DirectLightingIntegrator(LightStrategy strategy, int maxDepth, std::shared_ptr&lt;const Camera&gt; camera, std::shared_ptr&lt;Sampler&gt; sampler, const Bounds2i &amp;pixelBounds) : SamplerIntegrator(camera, sampler, pixelBounds), strategy(strategy), maxDepth(maxDepth) &#123;&#125; Spectrum Li(const RayDifferential &amp;ray, const Scene &amp;scene, Sampler &amp;sampler, MemoryArena &amp;arena, int depth) const; void Preprocess(const Scene &amp;scene, Sampler &amp;sampler); private: // DirectLightingIntegrator Private Data const LightStrategy strategy; const int maxDepth; std::vector&lt;int&gt; nLightSamples;&#125;; 在这一 Integrator 的预处理阶段，会根据计算策略决定是否需要预先生成一组随机样本。 作为一个基于采样的 Integrator ，这一类型中最重要的函数就是 Li() ，它的实现方法和 WhittedIntegrator::Li() 相似，其中最重要的函数调用是 UniformSampleAllLights 和 UniformSampleOneLight 。 由于 PBRT 中假定了光的线性特性，对于光照函数有： Lo(p,ωo)=∫S2f(p,ωo,ωi)Ld(p,ωi)∣cos⁡θi∣dωi∑j=1n∫S2f(p,ωo,ωi)Ld(j)(p,ωi)∣cos⁡θi∣dωi,Ld(p,ωi)=∑jLd(j)(p,ωi).\\begin{gathered}L_{\\mathrm{o}}\\left(\\mathrm{p}, \\omega_{\\mathrm{o}}\\right)=\\int_{\\mathrm{S}^{2}} f\\left(\\mathrm{p}, \\omega_{\\mathrm{o}}, \\omega_{\\mathrm{i}}\\right) L_{\\mathrm{d}}\\left(\\mathrm{p}, \\omega_{\\mathrm{i}}\\right)\\left|\\cos \\theta_{\\mathrm{i}}\\right| \\mathrm{d} \\omega_{\\mathrm{i}} \\\\\\sum_{j=1}^{n} \\int_{\\mathrm{S}^{2}} f\\left(\\mathrm{p}, \\omega_{\\mathrm{o}}, \\omega_{\\mathrm{i}}\\right) L_{\\mathrm{d}(j)}\\left(\\mathrm{p}, \\omega_{\\mathrm{i}}\\right)\\left|\\cos \\theta_{\\mathrm{i}}\\right| \\mathrm{d} \\omega_{\\mathrm{i}}, \\\\L_{\\mathrm{d}}\\left(\\mathrm{p}, \\omega_{\\mathrm{i}}\\right)=\\sum_{j} L_{\\mathrm{d}(j)}\\left(\\mathrm{p}, \\omega_{\\mathrm{i}}\\right) .\\end{gathered} Lo​(p,ωo​)=∫S2​f(p,ωo​,ωi​)Ld​(p,ωi​)∣cosθi​∣dωi​j=1∑n​∫S2​f(p,ωo​,ωi​)Ld(j)​(p,ωi​)∣cosθi​∣dωi​,Ld​(p,ωi​)=j∑​Ld(j)​(p,ωi​).​ 因此，对所有光源进行采样并累加在一起就成为了最基础的采样方法，它被实现在 UniformSampleAllLights 中。 另一方面，当场景中存在着大量的光源时，逐个遍历他们以得到总的直接光照变得开销极大。此时，通过随机采样任意一个光源，并将结果乘以总光源数量，就能得到无偏的估计值了。 更进一步地，我们还可以使用 MIS 的思想使用一个非均匀的概率采样各个光源，从而加速它的收敛。 14.3.1 估计直接光照 在选择完确定的光源进行采样之后，我们就需要计算该光源经着色点散射，最终出射的光线辐照度了，这个辐照度被定义为： ∫S2f(p,ωo,ωi)Ld(p,ωi)∣cos⁡θi∣dωi\\int_{\\mathrm{S}^{2}} f\\left(\\mathrm{p}, \\omega_{\\mathrm{o}}, \\omega_{\\mathrm{i}}\\right) L_{\\mathrm{d}}\\left(\\mathrm{p}, \\omega_{\\mathrm{i}}\\right)\\left|\\cos \\theta_{\\mathrm{i}}\\right| \\mathrm{d} \\omega_{\\mathrm{i}} ∫S2​f(p,ωo​,ωi​)Ld​(p,ωi​)∣cosθi​∣dωi​ 在采样时，对 BRDF 和对光源采样各有优势。对于 BRDF lobe 较为窄小的情况，对 BRDF 采样的效果较优，而对于光源的投影立体角较小的情况下，则对光源采样较优。PBRT 因此选用了结合二者的 MIS 采样方式来解决这一问题。 EstimateDirect 方法实现了对于直接光照的采样，它首先对光源进行一次采样，再接着对 BSDF 进行一次采样，最后使用 MIS 将二者结合起来。需要注意的是，对于以 delta 分布定义的光源，由于其 PDF 是恒值零，所以我们并不需要对它再额外进行 BSDF 采样。 14.4 The Light Transport Equation 光线传输方程（LTE）是描述场景中的辐照度平衡值的方程。它给出了从一点处出射的辐照度与其自发光、BSDF 以及入射的光线的关系。 14.4.1 基础概念 LTE 的成立依赖于我们在很早之前就对光线的性质做出的一系列假设，而其中最重要的一点就是能量守恒，这一概念在各个尺度上都有其体现。宏观上，我们有： Φo−Φi=Φe−Φa\\Phi_o - \\Phi_i = \\Phi_e - \\Phi_a Φo​−Φi​=Φe​−Φa​ 即从物体出射的能量与入射的能量的差值等于自释放的和吸收的能量之差。通过在某一位置的立体角上积分就有： Lo(p,ω)=Le(p,ω)+∫S2f(p,ωo,ωi)Li(p,ωi)∣cos⁡θi∣dωiL_o(p,\\omega) = L_e(p,\\omega) + \\int_{S^2} f(p,\\omega_o,\\omega_i)L_i(p,\\omega_i)|\\cos\\theta_i|\\mathrm{d}\\omega_iLo​(p,ω)=Le​(p,ω)+∫S2​f(p,ωo​,ωi​)Li​(p,ωi​)∣cosθi​∣dωi​ 在真空中，对于入射光线又有： Li(p,ω)=Lo(t(p,ω),−ω)L_i(p,\\omega) = L_o(t(p,\\omega), -\\omega) Li​(p,ω)=Lo​(t(p,ω),−ω) 其中 t(p,ω)t(p,\\omega)t(p,ω) 是反方向的光线与物体的物理交点（也可能是无穷远表示无穷远的环境光）。通过这一公式我们就能写出一个递归的关系式： L(p,ω)=Le(p,ω)+∫S2f(p,ωo,ωi)L(t(p,ωi),−ωi)∣cos⁡θi∣dωiL(p,\\omega) = L_e(p,\\omega) + \\int_{S^2} f(p,\\omega_o,\\omega_i)L(t(p, \\omega_i),-\\omega_i)|\\cos\\theta_i|\\mathrm{d}\\omega_i L(p,ω)=Le​(p,ω)+∫S2​f(p,ωo​,ωi​)L(t(p,ωi​),−ωi​)∣cosθi​∣dωi​ 14.4.2 LTE 的解析解 虽然光线传输方程看似简单，但其在大部分情况下是无法得到解析解的。着是由于大部分场景中均包含了复杂的基于物理的材质、以及各个不同物体之间的各类关系。 当然，在一些极简的情况下我们确实可能为它找到解析解，虽然它对求解一般情况下的光线传输方程基本没有帮助，但它提供了 debug 部分 Integrator 的方法。如果一个 Integrator 给出的结果和解析解不同，这就能说明它绝对存在问题。 考虑一个带有自发光的 Lambertian 材质的球体的内侧，由于其对称性，我们可知从任意角度观察任意点得到的结果应该均是同一个常数 LLL ，我们就有： L(p,ωo)=Le+∫H2(n)cL(t(p,ωi),−ωi)∣cos⁡θi∣dωiL=Le+ρhh(Le+ρhh(Le+⋯ ))=Le1−ρhhL=Le+cπLL(p,\\omega_o) = L_e + \\int_{H^2(n)}cL(t(p,\\omega_i), -\\omega_i)|\\cos\\theta_i|\\mathrm{d}\\omega_i\\\\ L = L_e + \\rho_{hh}(L_e + \\rho_{hh}(L_e + \\cdots)) = {L_e \\over 1 - \\rho_{hh}}\\\\ L = L_e + c \\pi L\\\\L(p,ωo​)=Le​+∫H2(n)​cL(t(p,ωi​),−ωi​)∣cosθi​∣dωi​L=Le​+ρhh​(Le​+ρhh​(Le​+⋯))=1−ρhh​Le​​L=Le​+cπL 由于 ρhh&lt;1\\rho_{hh} &lt; 1ρhh​&lt;1 ，这一方程会严格收敛到有限的值上。 14.4.3 LTE 的表面形式 之所以 LTE 会写作由 LiL_iLi​ 代表入射光的形式，主要是为了隐去场景中几何体对公式的影响。在这里我们会考虑该方程的另一种替代： L(p′→p)=L(p′,ω)f(p′′→p′→p)=f(p′,ωo,ωi)L(p&#x27; \\to p) = L(p&#x27;, \\omega)\\\\ f(p&#x27;&#x27; \\to p&#x27; \\to p) = f(p&#x27;, \\omega_o, \\omega_i)L(p′→p)=L(p′,ω)f(p′′→p′→p)=f(p′,ωo​,ωi​) 除此之外，我们还需要将积分域从立体角转换到面积上。这将乘以一个 Jacobian 项 ∣cos⁡θ′∣/r2|\\cos\\theta&#x27;|/r^2∣cosθ′∣/r2 。我们将这一个积分转换项和原来的 ∣cos⁡θ∣|\\cos\\theta|∣cosθ∣ 项，以及可见性测试的函数 V(p↔p′)V(p \\leftrightarrow p&#x27;)V(p↔p′) 结合为一项 GGG ： G(p↔p′)=V(p↔p′)∣cos⁡θ′∣∣cos⁡θ∣∣∣p−p′∣∣2G(p \\leftrightarrow p&#x27;) = V(p \\leftrightarrow p&#x27;) {|\\cos\\theta&#x27;||\\cos\\theta| \\over ||p-p&#x27;||^2} G(p↔p′)=V(p↔p′)∣∣p−p′∣∣2∣cosθ′∣∣cosθ∣​ 利用这一代换，我们就能写出 LTE 关于几何体面积的表达形式： L(p′→p)=Le(p′→p)+∫Af(p′′→p′→p)L(p′′→p′)G(p′′↔p′)dA(p′′)L\\left(\\mathrm{p}^{\\prime} \\rightarrow \\mathrm{p}\\right)=L_{\\mathrm{e}}\\left(\\mathrm{p}^{\\prime} \\rightarrow \\mathrm{p}\\right)+\\int_{A} f\\left(\\mathrm{p}^{\\prime \\prime} \\rightarrow \\mathrm{p}^{\\prime} \\rightarrow \\mathrm{p}\\right) L\\left(\\mathrm{p}^{\\prime \\prime} \\rightarrow \\mathrm{p}^{\\prime}\\right) G\\left(\\mathrm{p}^{\\prime \\prime} \\leftrightarrow \\mathrm{p}^{\\prime}\\right) \\mathrm{d} A\\left(\\mathrm{p}^{\\prime \\prime}\\right) L(p′→p)=Le​(p′→p)+∫A​f(p′′→p′→p)L(p′′→p′)G(p′′↔p′)dA(p′′) 虽然这一公式与基于立体角的 LTE 是一致的，但它却体现了不同的采样思路：对于原始 LTE ，我们通常在点周围采样方向，追逐生成的光线以检测辐照度，而对于本公式则通常在物体表面采样对应数量的点，追踪其连线以确定实际贡献的辐照度。 14.4.4 在路径上积分 通过展开上述与面积有关的积分，我们可以得到一个有关路径的积分： L(p1→p0)=Le(p1→p0)+∫ALe(p2→p1)f(p2→p1→p0)G(p2↔p1)dA(p2)+∫A∫ALe(p3→p2)f(p3→p2→p1)G(p3↔p2)×f(p2→p1→p0)G(p2↔p1)dA(p3)dA(p2)+⋯\\begin{aligned}L\\left(\\mathrm{p}_{1} \\rightarrow \\mathrm{p}_{0}\\right)=&amp; L_{\\mathrm{e}}\\left(\\mathrm{p}_{1} \\rightarrow \\mathrm{p}_{0}\\right) \\\\&amp;+\\int_{A} L_{\\mathrm{e}}\\left(\\mathrm{p}_{2} \\rightarrow \\mathrm{p}_{1}\\right) f\\left(\\mathrm{p}_{2} \\rightarrow \\mathrm{p}_{1} \\rightarrow \\mathrm{p}_{0}\\right) G\\left(\\mathrm{p}_{2} \\leftrightarrow \\mathrm{p}_{1}\\right) \\mathrm{d} A\\left(\\mathrm{p}_{2}\\right) \\\\&amp;+\\int_{A} \\int_{A} L_{\\mathrm{e}}\\left(\\mathrm{p}_{3} \\rightarrow \\mathrm{p}_{2}\\right) f\\left(\\mathrm{p}_{3} \\rightarrow \\mathrm{p}_{2} \\rightarrow \\mathrm{p}_{1}\\right) G\\left(\\mathrm{p}_{3} \\leftrightarrow \\mathrm{p}_{2}\\right) \\times f\\left(\\mathrm{p}_{2} \\rightarrow \\mathrm{p}_{1} \\rightarrow \\mathrm{p}_{0}\\right) G\\left(\\mathrm{p}_{2} \\leftrightarrow \\mathrm{p}_{1}\\right) \\mathrm{d} A\\left(\\mathrm{p}_{3}\\right) \\mathrm{d} A\\left(\\mathrm{p}_{2}\\right)\\\\ &amp; +\\cdots\\end{aligned}L(p1​→p0​)=​Le​(p1​→p0​)+∫A​Le​(p2​→p1​)f(p2​→p1​→p0​)G(p2​↔p1​)dA(p2​)+∫A​∫A​Le​(p3​→p2​)f(p3​→p2​→p1​)G(p3​↔p2​)×f(p2​→p1​→p0​)G(p2​↔p1​)dA(p3​)dA(p2​)+⋯​ 公式右端的每一项都代表了一条长度递增的路径，这说明只要我们使用一种随机采样路径的算法，在足够的采样数下总能得到收敛的结果。 我们将右侧的累加式写为一个新的公式： L(p1→p0)=∑n=1∞P(pˉn)L(p_1 \\to p_0) = \\sum_{n=1}^\\infty P(\\bar{p}_n) L(p1​→p0​)=n=1∑∞​P(pˉ​n​) 其中 P(pˉn)P(\\bar{p}_n)P(pˉ​n​) 代表了从所有路径长度为 nnn 的路径接收的 radiance 值。 P(p‾n)=∫A∫A⋯∫A⏟n−1Le(pn→pn−1)(∏i=1n−1f(pi+1→pi→pi−1)G(pi+1↔pi))dA(p2)⋯dA(pn).\\begin{aligned}P\\left(\\overline{\\mathrm{p}}_{n}\\right)=&amp; \\underbrace{\\int_{A} \\int_{A} \\cdots \\int_{A}}_{n-1} L_{\\mathrm{e}}\\left(\\mathrm{p}_{n} \\rightarrow \\mathrm{p}_{n-1}\\right) \\left(\\prod_{i=1}^{n-1} f\\left(\\mathrm{p}_{i+1} \\rightarrow \\mathrm{p}_{i} \\rightarrow \\mathrm{p}_{i-1}\\right) G\\left(\\mathrm{p}_{i+1} \\leftrightarrow \\mathrm{p}_{i}\\right)\\right) \\mathrm{d} A\\left(\\mathrm{p}_{2}\\right) \\cdots \\mathrm{d} A\\left(\\mathrm{p}_{n}\\right) .\\end{aligned} P(p​n​)=​n−1∫A​∫A​⋯∫A​​​Le​(pn​→pn−1​)(i=1∏n−1​f(pi+1​→pi​→pi−1​)G(pi+1​↔pi​))dA(p2​)⋯dA(pn​).​ 更进一步的，我们定义单条路径上的 throughput 为： T(p‾n)=∏i=1n−1f(pi+1→pi→pi−1)G(pi+1↔pi)T\\left(\\overline{\\mathrm{p}}_{n}\\right)=\\prod_{i=1}^{n-1} f\\left(\\mathrm{p}_{i+1} \\rightarrow \\mathrm{p}_{i} \\rightarrow \\mathrm{p}_{i-1}\\right) G\\left(\\mathrm{p}_{i+1} \\leftrightarrow \\mathrm{p}_{i}\\right) T(p​n​)=i=1∏n−1​f(pi+1​→pi​→pi−1​)G(pi+1​↔pi​) 因此： P(p‾n)=∫A∫A⋯∫A⏟n−1Le(pn→pn−1)T(p‾n)dA(p2)⋯dA(pn).\\begin{aligned}P\\left(\\overline{\\mathrm{p}}_{n}\\right)=&amp; \\underbrace{\\int_{A} \\int_{A} \\cdots \\int_{A}}_{n-1} L_{\\mathrm{e}}\\left(\\mathrm{p}_{n} \\rightarrow \\mathrm{p}_{n-1}\\right) T(\\overline{p}_n)\\mathrm{d} A\\left(\\mathrm{p}_{2}\\right) \\cdots \\mathrm{d} A\\left(\\mathrm{p}_{n}\\right) .\\end{aligned} P(p​n​)=​n−1∫A​∫A​⋯∫A​​​Le​(pn​→pn−1​)T(p​n​)dA(p2​)⋯dA(pn​).​ 使用上述公式，在给定路径长度 nnn 的情况下，我们就可以使用蒙特卡洛方法估计经由这一长度的路径到达着色点的 radiance 。而这一路径的选择可以是非常自由的。我们可以自由地从相机、光源、甚至场景中选取点来构建路径。 14.4.5 积分中的 delta 分布 由于特殊的 BSDF 和光源的形式，在 P(pˉn)P(\\bar{p}_n)P(pˉ​n​) 中时常会出现 delta 函数。这类分布需要被光照传输算法显式地处理，使用随机算法是无法采样到这些分布的。 考虑一个只包含了单一点光源的直接光照场景 P(pˉ2)P(\\bar{p}_2)P(pˉ​2​) ： P(p‾2)=∫ALe(p2→p1)f(p2→p1→p0)G(p2↔p1)dA(p2)=δ(plight −p2)Le(plight →p1)p(plight )f(p2→p1→p0)G(p2↔p1).\\begin{aligned}P\\left(\\overline{\\mathrm{p}}_{2}\\right) &amp;=\\int_{A} L_{\\mathrm{e}}\\left(\\mathrm{p}_{2} \\rightarrow \\mathrm{p}_{1}\\right) f\\left(\\mathrm{p}_{2} \\rightarrow \\mathrm{p}_{1} \\rightarrow \\mathrm{p}_{0}\\right) G\\left(\\mathrm{p}_{2} \\leftrightarrow \\mathrm{p}_{1}\\right) \\mathrm{d} A\\left(\\mathrm{p}_{2}\\right) \\\\&amp;=\\frac{\\delta\\left(\\mathrm{p}_{\\text {light }}-\\mathrm{p}_{2}\\right) L_{\\mathrm{e}}\\left(\\mathrm{p}_{\\text {light }} \\rightarrow \\mathrm{p}_{1}\\right)}{p\\left(\\mathrm{p}_{\\text {light }}\\right)} f\\left(\\mathrm{p}_{2} \\rightarrow \\mathrm{p}_{1} \\rightarrow \\mathrm{p}_{0}\\right) G\\left(\\mathrm{p}_{2} \\leftrightarrow \\mathrm{p}_{1}\\right) .\\end{aligned} P(p​2​)​=∫A​Le​(p2​→p1​)f(p2​→p1​→p0​)G(p2​↔p1​)dA(p2​)=p(plight ​)δ(plight ​−p2​)Le​(plight ​→p1​)​f(p2​→p1​→p0​)G(p2​↔p1​).​ 点光源把对面积的积分简化为了单一的对光源位置的采样，这一简化得以发生主要是因为在任何其它采样点，delta 分布均会给出零值。 14.4.6 LTE 的分解 在诸多光线传输算法中，不同的算法常常会在不同的情况下表现优秀，而在其它情况下表现平平甚至非常差。如 whitted 光线追踪可以优秀地处理镜面反射和折射，但对漫反射表面无能为力，而基于密度估计的光子映射（stochastic progressive photon mapping, SPPM）算法则在粗糙表面能获得优秀的结果，但对光滑表面无能为力。 为了设计可以适应不同散射情况的光线传输算法，我们常常会将 LTE 进行分解。常用的一种分解方法如下： L(p1→p0)=P(pˉ1)+P(pˉ2)+∑i=3∞P(pˉi)L(p_1 \\to p_0) = P(\\bar{p}_1) + P(\\bar{p}_2) + \\sum_{i=3}^\\infty P(\\bar{p}_i) L(p1​→p0​)=P(pˉ​1​)+P(pˉ​2​)+i=3∑∞​P(pˉ​i​) 其中第一项代表自发光、第二项代表直接光照，这二者均可以通过相对准确的算法得到，而第三项则会通常使用更高效但准确度略低的方案。 另一种分解的方法则可以从光源的贡献入手，如将光源分为来自小光源和大光源两类分别计算结果： P(p‾n)=∫An−1(Le,s(pn→pn−1)+Le,1(pn→pn−1))T(p‾n)dA(p2)⋯dA(pn)=∫An−1Le,s(pn→pn−1)T(p‾n)dA(p2)⋯dA(pn)+∫An−1Le,l(pn→pn−1)T(p‾n)dA(p2)⋯dA(pn).\\begin{aligned}P\\left(\\overline{\\mathrm{p}}_{n}\\right)=&amp; \\int_{A^{n-1}}\\left(L_{\\mathrm{e}, \\mathrm{s}}\\left(\\mathrm{p}_{n} \\rightarrow \\mathrm{p}_{n-1}\\right)+L_{\\mathrm{e}, 1}\\left(\\mathrm{p}_{\\mathrm{n}} \\rightarrow \\mathrm{p}_{\\mathrm{n}-1}\\right)\\right) T\\left(\\overline{\\mathrm{p}}_{n}\\right) \\mathrm{d} A\\left(\\mathrm{p}_{2}\\right) \\cdots \\mathrm{d} A\\left(\\mathrm{p}_{n}\\right) \\\\=&amp; \\int_{A^{n-1}} L_{\\mathrm{e}, \\mathrm{s}}\\left(\\mathrm{p}_{\\mathrm{n}} \\rightarrow \\mathrm{p}_{\\mathrm{n}-1}\\right) T\\left(\\overline{\\mathrm{p}}_{n}\\right) \\mathrm{d} A\\left(\\mathrm{p}_{2}\\right) \\cdots \\mathrm{d} A\\left(\\mathrm{p}_{n}\\right) \\\\&amp;+\\int_{A^{n-1}} L_{\\mathrm{e}, \\mathrm{l}}\\left(\\mathrm{p}_{\\mathrm{n}} \\rightarrow \\mathrm{p}_{\\mathrm{n}-1}\\right) T\\left(\\overline{\\mathrm{p}}_{n}\\right) \\mathrm{d} A\\left(\\mathrm{p}_{2}\\right) \\cdots \\mathrm{d} A\\left(\\mathrm{p}_{n}\\right) .\\end{aligned} P(p​n​)==​∫An−1​(Le,s​(pn​→pn−1​)+Le,1​(pn​→pn−1​))T(p​n​)dA(p2​)⋯dA(pn​)∫An−1​Le,s​(pn​→pn−1​)T(p​n​)dA(p2​)⋯dA(pn​)+∫An−1​Le,l​(pn​→pn−1​)T(p​n​)dA(p2​)⋯dA(pn​).​ 根据不同大小的光源特性，上述两个积分可以使用完全不同的算法进行计算——只要它们互相忽略对方的贡献即可。 除此之外，还可以根据 BSDF 的特性进行分解，一种常见的算法就是将 BSDF 分为 delta 和非 delta 两类： P(p‾n)=∫An−1Le(pn→pn−1)×∏i=1n−1(fΔ(pi+1→pi→pi−1)+f¬Δ(pi+1→pi→pi−1))×G(pi+1↔pi)dA(p2)⋯dA(pn)\\begin{aligned}P\\left(\\overline{\\mathrm{p}}_{n}\\right)=\\int_{A^{n-1}} L_{\\mathrm{e}} &amp;\\left(\\mathrm{p}_{\\mathrm{n}} \\rightarrow \\mathrm{p}_{\\mathrm{n}-1}\\right) \\\\\\times &amp; \\prod_{i=1}^{n-1}\\left(f_{\\Delta}\\left(\\mathrm{p}_{\\mathrm{i}+1} \\rightarrow \\mathrm{p}_{\\mathrm{i}} \\rightarrow \\mathrm{p}_{\\mathrm{i}-1}\\right)+f_{\\neg \\Delta}\\left(\\mathrm{p}_{\\mathrm{i}+1} \\rightarrow \\mathrm{p}_{\\mathrm{i}} \\rightarrow \\mathrm{p}_{\\mathrm{i}-1}\\right)\\right) \\\\ &amp; \\times G\\left(\\mathrm{p}_{\\mathrm{i}+1} \\leftrightarrow \\mathrm{p}_{\\mathrm{i}}\\right) \\mathrm{d} A\\left(\\mathrm{p}_{2}\\right) \\cdots \\mathrm{d} A\\left(\\mathrm{p}_{\\mathrm{n}}\\right)\\end{aligned} P(p​n​)=∫An−1​Le​×​(pn​→pn−1​)i=1∏n−1​(fΔ​(pi+1​→pi​→pi−1​)+f¬Δ​(pi+1​→pi​→pi−1​))×G(pi+1​↔pi​)dA(p2​)⋯dA(pn​)​ 14.5 Path Tracing 路径追踪是图形学中的首个通用且无偏的蒙特卡洛光线传输算法。它通过不断地在散射发生的位置生成并跟踪光线，最终终止于光源，从而计算采样值。 14.5.1 总览 给定路径形式的 LTE ，我们的目标就是估计相机光线与场景几何体相交位置 p1p_1p1​ 的出射辐照度。 L(p1→p0)=∑i=1∞P(pˉi)L(p_1 \\to p_0) = \\sum_{i = 1}^\\infty P(\\bar{p}_i) L(p1​→p0​)=i=1∑∞​P(pˉ​i​) 对于路径追踪而言，由于场景的物理性质，我们常常能够假定路径较短的光线往往会传输更多的能量。因此在路径追踪中我们通常会计算前数项，接着使用 Russian Roulette 方法粗略地估计后面的数项： L≈∑i=1∞((∏j=1i11−qj)P(pˉi))q1=q2=q3=0L \\approx \\sum_{i=1}^\\infty \\left(\\left(\\prod_{j=1}^i {1 \\over 1 - q_j} \\right)P(\\bar{p}_i)\\right)\\\\ q_1 = q_2 = q_3 = 0L≈i=1∑∞​((j=1∏i​1−qj​1​)P(pˉ​i​))q1​=q2​=q3​=0 14.5.2 采样路径 在有了以上指导的情况下，我们接下来需要考虑的是如何采样 P(pˉi)P(\\bar{p}_i)P(pˉ​i​) ，在给定光线终点的情况下，我们需要在场景中采样 iii 个位置以形成完整的光路。这一节中描述了一种非常低效的采样算法，它在整个场景中按表面积等概率地均匀采样。因为过于低效，此处就不再详述。 14.5.3 增量地构建路径 最经典的路径追踪采样方法增量地构建光路。在每一个光路的顶点位置，使用 BSDF 采样生成新的光线方向以寻找下一个顶点。 由于 BSDF 的采样是定义在立体角上的，我们需要将基于面积积分的路径追踪公式改写为对立体角积分，而由于这一变化基本上就相当于前述的 GGG 项的逆过程，因此过程中的绝大多数内容都被抵消掉了。对于单根光线，使用蒙特卡洛方法估计的贡献值如下： Le(pi→pi−1)f(pi→pi−1→pi−2)G(pi↔pi−1)pA(pi)×(∏j=1i−2f(pj+1→pj→pj−1)∣cos⁡θj∣pω(pj+1−pj))\\begin{gathered}\\frac{L_{\\mathrm{e}}\\left(\\mathrm{p}_{\\mathrm{i}} \\rightarrow \\mathrm{p}_{\\mathrm{i}-1}\\right) f\\left(\\mathrm{p}_{\\mathrm{i}} \\rightarrow \\mathrm{p}_{\\mathrm{i}-1} \\rightarrow \\mathrm{p}_{\\mathrm{i}-2}\\right) G\\left(\\mathrm{p}_{\\mathrm{i}} \\leftrightarrow \\mathrm{p}_{\\mathrm{i}-1}\\right)}{p_{A}\\left(\\mathrm{p}_{\\mathrm{i}}\\right)} \\\\\\quad \\times\\left(\\prod_{j=1}^{i-2} \\frac{f\\left(\\mathrm{p}_{\\mathrm{j}+1} \\rightarrow \\mathrm{p}_{\\mathrm{j}} \\rightarrow \\mathrm{p}_{\\mathrm{j}-1}\\right)\\left|\\cos \\theta_{j}\\right|}{p_{\\omega}\\left(\\mathrm{p}_{\\mathrm{j}+1}-\\mathrm{p}_{\\mathrm{j}}\\right)}\\right)\\end{gathered} pA​(pi​)Le​(pi​→pi−1​)f(pi​→pi−1​→pi−2​)G(pi​↔pi−1​)​×(j=1∏i−2​pω​(pj+1​−pj​)f(pj+1​→pj​→pj−1​)∣cosθj​∣​)​ 14.5.4 算法实现 在 PathIntegrator 中，从摄像机光线的交点开始，程序使用对应 SurfaceInteraction 的信息采样新的方向，生成并跟踪下一条光线。当由 Russian Roulette 或最大深度结束了本轮采样时，为了保证这条光路尽可能有效，会使用之前采样直接光照的方法采样从最后一个顶点接收到的辐照度。 为了记录光线追踪过程中的一系列状态，PBRT 记录了一系列参数。其中一个参数 beta 代表了当前光路下的 throughput 权重，将它与本位置接收到的辐照度估计值相乘即可得到摄像机处最终会获得的辐照度： β=∏j=1i−2f(pj+1→pj→pj−1)∣cos⁡θj∣pω(pj+1−pj)\\beta=\\prod_{j=1}^{i-2} \\frac{f\\left(\\mathrm{p}_{\\mathrm{j}+1} \\rightarrow \\mathrm{p}_{\\mathrm{j}} \\rightarrow \\mathrm{p}_{\\mathrm{j}-1}\\right)\\left|\\cos \\theta_{j}\\right|}{p_{\\omega}\\left(\\mathrm{p}_{\\mathrm{j}+1}-\\mathrm{p}_{\\mathrm{j}}\\right)} β=j=1∏i−2​pω​(pj+1​−pj​)f(pj+1​→pj​→pj−1​)∣cosθj​∣​ L 则记录了在本条光路上所有长度辐照度累计值 ∑P(pˉi)\\sum P(\\bar{p}_i)∑P(pˉ​i​) ，ray 保存了下一个需要追踪的光线信息，specularBounce 保存了当前位置的物体是否为镜面材质。 在 PBRT 出版后，源码中加入了另一个状态变量 etaScale 以调控在发生镜面折射的时候的 RR 概率值的变量，它在光线进入介质时减小为 η2\\eta^2η2 ，出射时回到初始值 111 。 函数的主要工作均在一个循环中完成，在循环中，会完成以下内容： 光线和场景求交以得到 SurfaceInteraction 在光线恰好击中光源时记入自发光项，或者在 miss 的情况下记入背景光 如果没有找到相交或者已经达到最大深度则终止光线 调用 SurfaceInteraction::ComputeScatteringFunctions 计算 BSDF 和 BSSRDF，并跳过空的介质分界面。 使用上一节中的 UniformSampleOneLight 采样直接光源，并与当前的 beta 相乘累加到总辐照度中，代表了本长度的贡献值 采样 BSDF 以得到新的光线 如果有 BSSRDF 则需要计算次表面散射的情况，这将在下一节中讲解 使用由 beta 和 etaScale 相乘得到的向量的最大值来确认 RR 的概率 q = std::max((Float).05, 1 - (beta * etaScale).MaxComponentValue()); ，并应用 RR 方法","categories":[{"name":"programming","slug":"programming","permalink":"https://blog.apassbydreg.work/categories/programming/"},{"name":"reading notes","slug":"programming/reading-notes","permalink":"https://blog.apassbydreg.work/categories/programming/reading-notes/"}],"tags":[{"name":"CG","slug":"CG","permalink":"https://blog.apassbydreg.work/tags/CG/"},{"name":"render","slug":"render","permalink":"https://blog.apassbydreg.work/tags/render/"},{"name":"PBRT","slug":"PBRT","permalink":"https://blog.apassbydreg.work/tags/PBRT/"}]},{"title":"PBRT 第十三章笔记 | Notes for PBRT Chapter 13 - Monte Carlo Integration","slug":"PBRT-ch13","date":"2021-12-14T17:12:47.000Z","updated":"2022-02-15T09:41:41.311Z","comments":true,"path":"2021/12/PBRT-ch13/","link":"","permalink":"https://blog.apassbydreg.work/2021/12/PBRT-ch13/","excerpt":"","text":"13.1 Background and Probability Review 本节简单介绍了概率论中的几个基础概念： cumulative distribution function (CDF): P(x)=P{X≤x}P(x) = P\\{X \\leq x\\}P(x)=P{X≤x} probability density function (PDF): p(x)=dP(x)/dxp(x) = \\mathrm{d}P(x) / \\mathrm{d}xp(x)=dP(x)/dx expected value: E[f(x)]=∫Df(x)p(x)dxE[f(x)] = \\int_Df(x)p(x)\\mathrm{d}xE[f(x)]=∫D​f(x)p(x)dx variance: V[f(x)]=E[(f(x)−E[f(x)])2]=E[f2(x)]−E[f(x)]2V[f(x)] = E[(f(x) - E[f(x)])^2] = E[f^2(x)] - E[f(x)]^2V[f(x)]=E[(f(x)−E[f(x)])2]=E[f2(x)]−E[f(x)]2 13.2 The Monte Carlo Estimator 蒙特卡洛估计器给了我们一种可以使用部分样本估计总体积分结果的方法： FN=1N∑i=1nf(Xi)p(Xi)F_N = {1 \\over N} \\sum_{i=1}^n{f(X_i) \\over p(X_i)} FN​=N1​i=1∑n​p(Xi​)f(Xi​)​ 13.3 Sampling Random Variables 为了能够正确地使用蒙特卡洛方法求解积分，我们需要一种方法，以从任意的分布进行采样。 13.3.1 求逆法 求逆法通过对 CDF 进行求逆操作以得到从 U[0,1]U[0,1]U[0,1] 样本到对应样本的映射，其采样一个样本流程为： 根据给定的 PDF 通过积分计算 CDF 计算 PDF 的逆函数 P−1(x)P^{-1}(x)P−1(x) 从一个 U[0,1]U[0,1]U[0,1] 中采样一个数 ξ\\xiξ 计算 Xi=P−1(ξ)X_i = P^{-1}(\\xi)Xi​=P−1(ξ) 作为采样值 特别地，对于离散的情况，PBRT 提供了 Distribution1D 类型作为一个工具类。它输入一组离散的样本值和离散点的个数，在构造函数中计算它的积分值（用于生成 PDF ），并生成归一化的 CDF 函数。 当需要采样一个值时，这个对象会首先使用二分查找找到采样随机数两侧的离散位置，接着根据采样的连续性要求与否生成采样值，最后返回对应的 PDF 。 13.3.2 拒绝法 对于无法使用数值方法积分以获得 PDF ，或无法求解 CDF 的逆函数的情况，拒绝法提供了一种解决方案。 拒绝法的核心是使用一个更加简单的采样方法指导对复杂分布的采样。对于复杂的分布 ppp ，拒绝法采样的流程如下： 找到一个简单的分布 q(x)q(x)q(x) 和一个尽量小的常数 ccc 使得 p(x)≤cq(x)p(x) \\leq cq(x)p(x)≤cq(x) 从简单分布中采样得到样本 YYY ，另从 U[0,1]U[0,1]U[0,1] 中采样样本 UUU 如果 p(Y)≥cq(Y)×Up(Y) \\geq c q(Y) \\times Up(Y)≥cq(Y)×U 则接受这一样本，否则重复步骤 2 直至找到接受的样本 一个最简单的例子就是使用均匀分布作为参照分布，选取 ccc 使得 cq(x)cq(x)cq(x) 的顶端和 ppp 的极值相等。几何上来说，任何在 ppp 函数曲线下方的采样点均被接受，结合二维概率即可知拒绝后的采样概率密度和目标密度相等。 13.4 Metropolis Sampling ⚠️ 这里讨论了另一种通用的对非负分布进行采样的方法。它不必对 CDF 求逆，而且每一次迭代均可以产生有效的样本。这一采样方式的缺点在于，生成的样本在统计学上存在着一定的先后关联性。需要在采样数量较大时才可以保证对整个采样域有良好的覆盖。 13.4.1 算法基础 Metropolis 算法可以生成一系列以映射 f:Ω=Rn→Rf:\\Omega = R^n \\to Rf:Ω=Rn→R 为出现权重的高维样本 XXX 。当第一个样本 X0X_0X0​ 被选择后，以递推的方式，根据前一个样本的内容，使用随机变换（random mutation）的方式生成下一个样本。这个随机的变换可能被拒绝，当它被拒绝时，Metropolis 算法直接返回上一个样本值；当它被接受时，则返回变换后的样本值。这种算法挑选的接受方式需要保证这些随机变换在采样数量取极限时能让样本分布收敛到 fff 的概率密度上。 为了确定何时接受或拒绝给定的变换，我们首先需要计算在已有的变换生成方法下，从状态 XXX 转移到状态 X′X&#x27;X′ 的转移概率密度 T(X→X′)T(X \\to X&#x27;)T(X→X′) 。接下来还需要找到一个转移的接受概率 a(X→X′)a(X \\to X&#x27;)a(X→X′) ，使得任意一个转移路径的概率都相等，即： f(X)T(X→X′)a(X→X′)=f(X′)T(X′→X)a(X′→X)f(X)T(X \\to X&#x27;)a(X \\to X&#x27;) = f(X&#x27;)T(X&#x27; \\to X)a(X&#x27; \\to X) f(X)T(X→X′)a(X→X′)=f(X′)T(X′→X)a(X′→X) 这一性质又被称为 detailed balance 。 由于 T,fT, fT,f 均为已知量，我们可以由此计算 aaa ： a(X→X′)=min⁡(1,f(X′)T(X′→X)f(X)T(X→X′))a(X \\to X&#x27;) = \\min\\left(1, {f(X&#x27;)T(X&#x27; \\to X) \\over f(X)T(X \\to X&#x27;)}\\right) a(X→X′)=min(1,f(X)T(X→X′)f(X′)T(X′→X)​) 将上述的内容结合起来，我们可以得到 Metropolis 算法的伪码： 1234567X = X0for i in range(n): X_ = mutate(X) a = accept(X, X_) if (random() &lt; a): X = X_ record(X) 由于 Metropolis 算法常常会忽略 fff 值较小的样本，为了获取更多这些区域的信息，我们可以更改样本的储存方式，为每个样本赋予一定的权重，并在每次采样中同时以 aaa 值为权重分割保存新旧两个样本，这一被称为 expected values 的策略伪码如下： 12345678X = X0for i in range(n): X_ = mutate(X) a = accept(X, X_) record(X, 1 - a) record(X_, a) if (random() &lt; a): X = X_ 13.4.2 选择递推变换的方式 一般而言，只需要转移概率 TTT 是可计算的，递推变换的选取方式是自由的。更进一步，只要这一转移概率是对称的，满足 T(X→X′)=T(X′→X)T(X \\to X&#x27;) = T(X&#x27; \\to X)T(X→X′)=T(X′→X)，它甚至都不需要满足可计算性。 一般而言，这一变换一般都倾向于选择大幅偏离源样本的新采样，这有助于随机算法快速覆盖尽可能多的样本域。另一方面，如果当前位置的 fff 值很大的话，有很大的可能性会出现连续多个采样被拒绝的情况，这也是采样算法希望尽可能避免的。总的来说，我们需要保证随机算法的遍历性，使得对于任意的 f(X),f(X′)&gt;0f(X), f(X&#x27;) &gt; 0f(X),f(X′)&gt;0 均有 T(X→X′)&gt;0T(X \\to X&#x27;) &gt; 0T(X→X′)&gt;0 。 一种可行的方式是对当前的样本 XXX 进行随机扰动。对于一个向量 X=(x0,x1,⋯ )X = (x_0, x_1, \\cdots)X=(x0​,x1​,⋯) ，我们可以随机对其中的一部分维度进行扰动，使得 xi′=(xi±sξ)mod1x_i&#x27; = (x_i\\pm s\\xi)\\mathrm{mod}1xi′​=(xi​±sξ)mod1 ，其中的 sss 是一个扰动的缩放系数。更简单地，我们也也可以进一步直接使 xi′=ξx_i&#x27; = \\xixi′​=ξ 完成采样。从结果而言，这两种采样方式均满足对称性，从而可以直接忽略 TTT 的计算。 另一种方法是使用一个与目标函数相近的 PDF 去采样新的 X′∼pX&#x27; \\sim pX′∼p ，在这种情况下有 T(X→X′)=p(X′)T(X \\to X&#x27;) = p(X&#x27;)T(X→X′)=p(X′) 13.4.3 初值 Bias 在之前的讨论中被忽视的一个重要组成部分是初值 X0X_0X0​ 的选取。初值将指导后续的值的选择，虽然其后选择的样本分布与原始分布是无偏的，但初值的选择本身可能带来 Bias 。 一种简易的解决方法是首先使用 Metropolis 算法在随机初值上先运行几轮迭代，再抛弃之前的采样，将 XkX_kXk​ 作为初值开始采样。但这种方法具有两方面的问题：其一是计算被抛弃的部分的代价比较高，再者我们并没有有效的方法来确定具体要迭代多少次才能使初值偏差的影响降低到可接受的范围内。 对于这一问题的终极解决方法是：使用另一种分布采样 X0∼pX_0 \\sim pX0​∼p ，对于 X0X_0X0​ ，我们会使用一个权值来平衡以这一初值开始的采样序列对总体的影响：w=f(X0)/p(X0)w = {f(X_0) / p(X_0)}w=f(X0​)/p(X0​) 。 这一方法带来了一个问题：当采样的初值 f(X0)=0f(X_0) = 0f(X0​)=0 时，这一系列的采样的权值都会设为零。这时我们可以采样多个初值候选 Y1,⋯ ,YnY_1, \\cdots, Y_nY1​,⋯,Yn​ ，并定义各个初值的权重 wiw_iwi​ ，接着根据权值从所有候选中选出 X0X_0X0​ ，并以之前的权重平均值 w‾\\overline ww 作为这一轮采样的权值。 13.4.4 一维下的一个例子 考虑以下的简单分布： f(x)={(x−0.5)2,0≤x≤10,otherwisef(x) = \\begin{cases} (x-0.5)^2 &amp; ,0 \\leq x \\leq 1\\\\ 0 &amp; ,otherwise \\end{cases}f(x)={(x−0.5)20​,0≤x≤1,otherwise​ 我们接着定义两种变换，对于一个随机数 ξ∼U[0,1]\\xi \\sim U[0, 1]ξ∼U[0,1] 第一种变换：将 ξ\\xiξ 直接赋值给新样本，因此得： mutate1(X)→ξT1(X→X′)=1\\mathrm{mutate}_1(X)\\to\\xi\\\\ T_1(X \\to X&#x27;) = 1mutate1​(X)→ξT1​(X→X′)=1 第二种变换：在原始样本附近 ±0.05\\pm 0.05±0.05 的范围内随机采样，可得： mutate2(X)→X+0.1(ξ−0.5)T2(X→X′)={10,∣X−X′∣≤0.050,otherwise\\mathrm{mutate}_2(X)\\to X + 0.1(\\xi - 0.5)\\\\ T_2(X \\to X&#x27;) = \\begin{cases} 10 &amp;, |X - X&#x27;| \\leq 0.05\\\\ 0 &amp;, otherwise \\end{cases}mutate2​(X)→X+0.1(ξ−0.5)T2​(X→X′)={100​,∣X−X′∣≤0.05,otherwise​ 对于第一个样本，我们只需简单地从 U[0,1]U[0,1]U[0,1] 中采样 X0X_0X0​ ，并将本序列的权值设为 w=f(X0)w = f(X_0)w=f(X0​) 即可。 最后，我们使用一种基于桶的可视化重建方法：首先将 [0,1][0,1][0,1] 区间等分为 大小相同的桶，并累加每个桶中的所有样本的权值之和。我们在每次试验中进行 10000 次迭代，并将结果用 50 个桶可视化如下： 在第一个实验中，我们全程使用第一种变换方式，可以发现这并不是一种非常有效的采样方法，会引入很大的噪声。这是因为它无法在发现高 fff 值的时候在该值附近进行更多的采样。但上图仍然可以说明这一方法可以收敛至正确的分布上。 在第二个实验中，我们以 1 : 9 的概率随机选择采样方式 1 和 2 。很显然，这种采样方法可以让我们在相同的迭代次数内获得更小的方差，对比第一个实验收敛速度有明显增加。第二种方法提供的更小的步长使得迭代时得以在更加平缓的位置内对高权值部分附近的区域多次采样。 然而并非步长越小效果就一定越好，在第三个试验中仅使用了第二种变换方式，能够发现这一采样大幅度偏离了目标分布，较小的步长使得样本很难跨过中间的低函数值区域，从而可能导致在函数的另一侧根本得不到任何采样。Metropolis 算法的特性决定了它会尝试远离低 fff 值的区域，但这并不代表这一算法不能收敛到正确的位置——它只不过是慢的离谱罢了。 13.4.5 使用 Metropolis 算法估算积分 此时我们回到基础的带概率密度的积分计算 ∫f(x)g(x)dΩ\\int f(x)g(x) \\mathrm{d}\\Omega∫f(x)g(x)dΩ ，如果我们将 ∫f(x)dΩ\\int f(x)\\mathrm{d}\\Omega∫f(x)dΩ 归一化，并视作 PDF ，并在此分布上使用 Metripolis 算法采样 X1,⋯ ,XNX_1, \\cdots, X_NX1​,⋯,XN​ 我们就能将积分转换为： ∫Ωf(x)g(x)dΩ≈1N∑i=1Nf(Xi)g(Xi)p(Xi)≈1N[∑i=1Ng(Xi)]∫Ωf(x)dΩ\\begin{aligned} \\int_\\Omega f(x)g(x) \\mathrm{d}\\Omega &amp;\\approx {1 \\over N}\\sum_{i=1}^N{f(X_i)g(X_i) \\over p(X_i)}\\\\ &amp;\\approx {1 \\over N} \\left[\\sum_{i=1}^Ng(X_i)\\right] \\int_\\Omega f(x)\\mathrm{d}\\Omega \\end{aligned}∫Ω​f(x)g(x)dΩ​≈N1​i=1∑N​p(Xi​)f(Xi​)g(Xi​)​≈N1​[i=1∑N​g(Xi​)]∫Ω​f(x)dΩ​ 13.5 Transforming between Distributions 在求逆法生成样本的过程中，我们引入了将 U[0,1]U[0,1]U[0,1] 样本转换为特定样本的方法。在这一节中，我们将讨论一个更一般的情况：当我们使用一个函数将样本从一个分布转换为另一个分布式，得到的新分布与原分布之间有何联系。 假设我们从原始 PDF px(x)p_x(x)px​(x) 中采样了一系列样本 XiX_iXi​ ，如果我们使用函数 Yi=y(Xi)Y_i = y(X_i)Yi​=y(Xi​) 将这些样本转化为一组新的样本，通常我们会希望得到新样本组的分布。 解决这一问题的前提在于，用于变换的函数 yyy 必须是可逆的（即导数必须是严格单调的）：如果多个不同的 XXX 值被映射到了同一个 YYY 上，那么我们也没有办法准确地描述特定 YYY 值的概率分布了。这种一一对应的性质带来了以下等式： P{Y≤y(x)}=P{X≤x}Py(y)=Py(y(x))=Px(x)P\\{Y\\leq y(x)\\} = P\\{X \\leq x\\}\\\\ P_y(y) = P_y(y(x)) = P_x(x)P{Y≤y(x)}=P{X≤x}Py​(y)=Py​(y(x))=Px​(x) 对 CDF 复合函数的两侧对 xxx 求导有： py(y)dydx=px(x)py(y)=(dydx)−1px(x)p_y(y){\\mathrm{d}y \\over \\mathrm{d}x} = p_x(x)\\\\ p_y(y) = \\left({\\mathrm{d}y \\over \\mathrm{d}x}\\right)^{-1} p_x(x)\\\\ py​(y)dxdy​=px​(x)py​(y)=(dxdy​)−1px​(x) 由于严格单调的性质，有： py(y)=∣dydx∣−1px(x)p_y(y) = \\left|{\\mathrm{d}y \\over \\mathrm{d}x}\\right|^{-1} p_x(x)\\\\ py​(y)=∣∣∣∣​dxdy​∣∣∣∣​−1px​(x) 如果我们希望从采集自分布 pxp_xpx​ 的样本得到符合分布 pyp_ypy​ 的样本，并希望 Py(y(x))=Px(x)P_y(y(x)) = P_x(x)Py​(y(x))=Px​(x) 时，则有： y(x)=Py−1(Px(x))y(x) = P_y^{-1}(P_x(x)) y(x)=Py−1​(Px​(x)) 13.5.1 高维情况下的变换 如果我们进一步将上述结论推广到更高维的样本空间 X∈RnX \\in R^nX∈Rn ，并使用双射 Y=T(X)Y = T(X)Y=T(X) 将原始样本转换到同维的另一个分布上，则有： py(y)=py(T(x))=px(x)abs(det⁡JT(x))p_y(y) = p_y(T(x)) = {p_x(x) \\over \\mathrm{abs(}\\det{J_T(x)})} py​(y)=py​(T(x))=abs(detJT​(x))px​(x)​ 其中的 JT(x)J_T(x)JT​(x) 是转换在 xxx 位置上的 Jacobian 矩阵： (∂T1/∂x1⋯∂T1/∂xn⋮⋱⋮∂Tn/∂x1⋯∂Tn/∂xn)\\left(\\begin{array}{ccc}\\partial T_{1} / \\partial x_{1} &amp; \\cdots &amp; \\partial T_{1} / \\partial x_{n} \\\\\\vdots &amp; \\ddots &amp; \\vdots \\\\\\partial T_{n} / \\partial x_{1} &amp; \\cdots &amp; \\partial T_{n} / \\partial x_{n}\\end{array}\\right) ⎝⎜⎛​∂T1​/∂x1​⋮∂Tn​/∂x1​​⋯⋱⋯​∂T1​/∂xn​⋮∂Tn​/∂xn​​⎠⎟⎞​ 13.5.2 极坐标系 对于极坐标系： x=rcos⁡θy=rsin⁡θx = r\\cos\\theta\\\\ y = r\\sin\\thetax=rcosθy=rsinθ 其 Jacobian 矩阵为： JT=(∂x∂r∂x∂θ∂y∂r∂y∂θ)=(cos⁡θ−rsin⁡θsin⁡θrcos⁡θ)J_{T}=\\left(\\begin{array}{cc}\\frac{\\partial x}{\\partial r} &amp; \\frac{\\partial x}{\\partial \\theta} \\\\\\frac{\\partial y}{\\partial r} &amp; \\frac{\\partial y}{\\partial \\theta}\\end{array}\\right)=\\left(\\begin{array}{cc}\\cos \\theta &amp; -r \\sin \\theta \\\\\\sin \\theta &amp; r \\cos \\theta\\end{array}\\right) JT​=(∂r∂x​∂r∂y​​∂θ∂x​∂θ∂y​​)=(cosθsinθ​−rsinθrcosθ​) 因此： p(r,θ)=rp(x,y)p(r,\\theta) = rp(x, y) p(r,θ)=rp(x,y) 13.5.2 球坐标系 对于极坐标系： x=rsin⁡θcos⁡ϕy=rsin⁡θsin⁡ϕz=rcos⁡θx = r\\sin\\theta\\cos\\phi\\\\ y = r\\sin\\theta\\sin\\phi\\\\ z = r\\cos\\thetax=rsinθcosϕy=rsinθsinϕz=rcosθ 将概率从 xyz 采样转换到球坐标系时的关系是： p(r,θ,ϕ)=r2sin⁡θp(x,y,z)p(r,\\theta,\\phi) = r^2\\sin\\theta p(x, y, z) p(r,θ,ϕ)=r2sinθp(x,y,z) 而利用立体角的导数公式 dω=sin⁡θdθdϕ\\mathrm{d}\\omega = \\sin\\theta\\mathrm{d}\\theta\\mathrm{d}\\phidω=sinθdθdϕ 可得，将概率从立体角采样转换到球坐标系时的关系是： p(θ,ϕ)dθdϕ=p(ω)dωp(θ,ϕ)=sin⁡θp(ω)\\begin{aligned} p(\\theta,\\phi)\\mathrm{d}\\theta\\mathrm{d}\\phi &amp; = p(\\omega)\\mathrm{d}\\omega\\\\ p(\\theta,\\phi) &amp; = \\sin\\theta p(\\omega) \\end{aligned}p(θ,ϕ)dθdϕp(θ,ϕ)​=p(ω)dω=sinθp(ω)​ 13.6 2D Sampling with Multidimensional Transformations 假设我们需要从一个二维的分布函数 p(x,y)p(x, y)p(x,y) 采样。 在一些情况下，二维的分布函数可被表示为两个一维的分布函数的乘积，即 p(x,y)=px(x)py(y)p(x,y) = p_x(x)p_y(y)p(x,y)=px​(x)py​(y) 。此时我们可以独立地从两个分布中采样得到样本并拼接为一个二维样本。但在大部分情况下，这两个维度一般都是不可分的。 在此，我们需要定义边缘分布函数和条件分布函数： px(x)=∫p(x,y)dypy(y)=∫p(x,y)dxp(x∣y)=p(x,y)p(x)p(y∣x)=p(x,y)p(y)\\begin{aligned} p_x(x) &amp;= \\int p(x,y)\\mathrm{d}y\\\\ p_y(y) &amp;= \\int p(x,y)\\mathrm{d}x\\\\ p(x|y) &amp;= {p(x,y) \\over p(x)}\\\\ p(y|x) &amp;= {p(x,y) \\over p(y)} \\end{aligned}px​(x)py​(y)p(x∣y)p(y∣x)​=∫p(x,y)dy=∫p(x,y)dx=p(x)p(x,y)​=p(y)p(x,y)​​ 一种一般的采样二维分布的方法就是首先从其中一个维度的边缘分布入手采样一个变量，再以该位置的条件分布采样另一个变量。 13.6.1 Uniformly Sampling a Hemisphere 半球面上进行均匀采样是常见的采样方式，它在各个立体角上以均匀的概率 p(ω)=1/2πp(\\omega) = 1 / 2\\pip(ω)=1/2π 采样。由上一节中的转换有：p(θ,ϕ)=sin⁡θ/2πp(\\theta,\\phi) = \\sin\\theta / 2\\pip(θ,ϕ)=sinθ/2π 。 假设我们首先采样 θ\\thetaθ ，计算其边缘分布可得 pθ(θ)=sin⁡θp_\\theta(\\theta) = \\sin\\thetapθ​(θ)=sinθ ，再计算对应的条件分布 p(ϕ∣θ)=1/2π=pϕ(ϕ)p(\\phi|\\theta) = 1 / 2\\pi = p_\\phi(\\phi)p(ϕ∣θ)=1/2π=pϕ​(ϕ) 。注意到这两个概率中均不存在另一个变量，因此这是一个可分解的分布，我们只需要分别以对应的 PDF 采样两个变量即可。 ϕ\\phiϕ 由于是一个均匀分布，只需简单地将从 U[0,1]U[0,1]U[0,1] 的样本乘以 2π2\\pi2π 即可得到，而对于 θ\\thetaθ 则有： P(θ)=∫0θsin⁡θ′dθ′=1−cos⁡θP(\\theta) = \\int_0^\\theta \\sin\\theta&#x27;\\mathrm{d}\\theta&#x27; = 1 - \\cos\\theta P(θ)=∫0θ​sinθ′dθ′=1−cosθ 结合 13.5 中讨论的采样域转换方法，可得将两个从 0-1 分布中采样的变量转换到在立体角上均匀分布的半球面的方法： θ=cos⁡−1(1−ξ1)⇔cos⁡−1ξ1ϕ=2πξ2\\theta = \\cos^{-1}(1-\\xi_1) \\Leftrightarrow \\cos^{-1}\\xi_1\\\\ \\phi = 2\\pi\\xi_2θ=cos−1(1−ξ1​)⇔cos−1ξ1​ϕ=2πξ2​ 13.6.2 Sampling a Unit Disk 对于平面上的单位圆内部进行采样的方式也是类似的： pr(r)=∫02πp(r,θ)dθ=2rp(θ∣r)=p(r,θ)pr(r)=12πp_r(r) = \\int_0^{2\\pi}p(r,\\theta)\\mathrm{d}\\theta = 2r\\\\ p(\\theta|r) = {p(r,\\theta) \\over p_r(r)} = {1\\over2\\pi} pr​(r)=∫02π​p(r,θ)dθ=2rp(θ∣r)=pr​(r)p(r,θ)​=2π1​ 因此： r=ξ1θ=2πξ2r = \\sqrt{\\xi_1}\\\\ \\theta = 2\\pi\\xi_2r=ξ1​​θ=2πξ2​ 虽然这一方法能够解决均匀采样的问题，但这种映射方法也使得在原分布下的方形被扭曲压缩得比较严重。 另一种更佳的映射方式会同轴地从 [−1,1]2[-1,1]^2[−1,1]2 映射到单位圆上，从而生成扭曲更少的结果： 它将一个范围在 [−1,1]2[-1,1]^2[−1,1]2 的方形经过压缩变形后映射到单位圆上，转换的方式如下： r=xθ=yxπ4r = x\\\\ \\theta = {y \\over x}{\\pi \\over 4}r=xθ=xy​4π​ 对于方形中的每个八分之一三角的区域均会被映射为圆上的一个扇形区域 13.6.3 Cosine-Weighted Hemisphere Sampling 由于 BSDF 中 cos⁡\\coscos 项的存在，我们经常会希望更多地在法线附近采样，即有 p(ω)∝cos⁡θp(\\omega) \\propto \\cos\\thetap(ω)∝cosθ 。通过归一化可得： ∫H2p(ω)dω=∫H2ccos⁡θdω=∫H2ccos⁡θsin⁡θdθdϕ=1p(θ,ϕ)=cos⁡θsin⁡θπ\\int_{H^2}p(\\omega)\\mathrm{d}\\omega = \\int_{H^2}c\\cos\\theta\\mathrm{d}\\omega = \\int_{H^2}c\\cos\\theta\\sin\\theta\\mathrm{d}\\theta\\mathrm{d}\\phi = 1\\\\ p(\\theta, \\phi) = {\\cos\\theta\\sin\\theta\\over\\pi}∫H2​p(ω)dω=∫H2​ccosθdω=∫H2​ccosθsinθdθdϕ=1p(θ,ϕ)=πcosθsinθ​ 虽然我们也可以像之前一样计算边缘概率分布和条件概率分布，但在此处我们可以使用一种称为 Malley’s method 的方法来解决这一问题，它背后的原理在于：如果我们在一个圆上均匀地采样，再将采样点投影到对应的单位球上，那么得到的结果天然地具有 cos⁡\\coscos 加权地性质。 为了证明这一点，我们需要从等式 (r,ϕ)=(sin⁡θ,ϕ)(r,\\phi) = (\\sin\\theta,\\phi)(r,ϕ)=(sinθ,ϕ) 完成从圆采样到半球面采样的转换，首先计算 Jacobian 矩阵的行列式： ∣JT∣=∣cos⁡θ001∣=cos⁡θ|J_T| = \\left|\\begin{matrix} \\cos\\theta &amp; 0\\\\ 0 &amp; 1 \\end{matrix}\\right| = \\cos\\theta∣JT​∣=∣∣∣∣​cosθ0​01​∣∣∣∣​=cosθ 即： p(θ,ϕ)=∣JT∣p(r,ϕ)=cos⁡θ×rπ=cos⁡θsin⁡θπp(\\theta,\\phi) = |J_T|p(r,\\phi) = \\cos\\theta\\times{r\\over\\pi} = {\\cos\\theta\\sin\\theta\\over\\pi} p(θ,ϕ)=∣JT​∣p(r,ϕ)=cosθ×πr​=πcosθsinθ​ 13.6.4 Sampling a Cone 对于基于球体的范围光源和聚光灯光源的采样而言，在一个圆锥体内均匀地采样一个方向也是有必要的。在这一情况中，ϕ,θ\\phi, \\thetaϕ,θ 依旧是可分离的。其中有 ϕ=1/2π\\phi = 1 / 2\\piϕ=1/2π ，由于： p(ω)=p(θ,ϕ)sin⁡θ=p(ϕ)×p(θ)sin⁡θ=cp(\\omega) = {p(\\theta,\\phi) \\over \\sin\\theta} = p(\\phi)\\times{p(\\theta) \\over \\sin\\theta} = c p(ω)=sinθp(θ,ϕ)​=p(ϕ)×sinθp(θ)​=c 1=∫Ωp(ϕ,θ)dϕdθ=∫0θmax⁡csin⁡θdθp(θ)=sin⁡θ1−cos⁡θmax⁡p(ω)=12π(1−cos⁡θmax⁡)\\begin{aligned} 1 &amp; = \\int_\\Omega p(\\phi,\\theta)\\mathrm{d}\\phi\\mathrm{d}\\theta\\\\ &amp; = \\int_0^{\\theta_{\\max}} c\\sin\\theta\\mathrm{d}\\theta\\\\ p(\\theta) &amp; = {\\sin\\theta \\over {1-\\cos\\theta_{\\max}}}\\\\ p(\\omega) &amp; = {1 \\over 2\\pi(1 - \\cos\\theta_{\\max})} \\end{aligned}1p(θ)p(ω)​=∫Ω​p(ϕ,θ)dϕdθ=∫0θmax​​csinθdθ=1−cosθmax​sinθ​=2π(1−cosθmax​)1​​ 由此我们可以得到从 U[0,1]U[0,1]U[0,1] 转换到角度的方法： ϕ=2πξ1cos⁡θ=(1−ξ2)+ξcos⁡θmax\\phi = 2\\pi \\xi_1\\\\ \\cos\\theta = (1-\\xi_2) + \\xi\\cos\\theta_{max}ϕ=2πξ1​cosθ=(1−ξ2​)+ξcosθmax​ 13.6.5 Sampling a Triangle 在三角形中均匀采样实际上比大部分人想象得复杂很多。为了简化问题，我们首先在一个腰长为 1 的等腰直角三角形中进行均匀采样。 还是老步骤，计算 PDF 、边缘分布和 CDF ，最后可得： u=1−ξ1v=ξ2ξ1u = 1 - \\sqrt{\\xi_1}\\\\ v = \\xi_2\\sqrt{\\xi_1}u=1−ξ1​​v=ξ2​ξ1​​ 13.6.6 Sampling Cameras ⚠️ 这一部分和 6.4 的内容有关，描述了如何采样一段时间内摄像机的某个像素收到的总能量公式： J=1z2∫Ap∫t0t1∫AeLi(p,p′,t′)∣cos⁡4θ∣dAedt′dApJ=\\frac{1}{z^{2}} \\int_{A_{\\mathrm{p}}} \\int_{t_{0}}^{t_{1}} \\int_{A_{\\mathrm{e}}} L_{\\mathrm{i}}\\left(\\mathrm{p}, \\mathrm{p}^{\\prime}, t^{\\prime}\\right)\\left|\\cos ^{4} \\theta\\right| \\mathrm{d} A_{\\mathrm{e}} \\mathrm{d} t^{\\prime} \\mathrm{d} A_{\\mathrm{p}} J=z21​∫Ap​​∫t0​t1​​∫Ae​​Li​(p,p′,t′)∣∣​cos4θ∣∣​dAe​dt′dAp​ 13.6.7 Piecewise-Constant 2D Distributions 从有限的离散 PDF 上采样也是一个非常有必要讨论的内容，考虑一个 nu×nvn_u \\times n_vnu​×nv​ 的二维离散常值分布函数 f[u,v]f[u,v]f[u,v] ，我们可以使用累加替代积分进行计算： p(u,v)=f(u,v)∬f(u,v)du dv=f[u~,v~]1/(nunv)∑i∑jf[ui,vj]p(v)=∫p(u,v)du=(1/nu)∑if[ui,v~]Ifp(u∣v)=p(u,v)p(v)=f[u~,v~]/Ifp[v~]\\begin{aligned} p(u, v)&amp;=\\frac{f(u, v)}{\\iint f(u, v) \\mathrm{d} u \\mathrm{~d} v}=\\frac{f[\\tilde{u}, \\tilde{v}]}{1 /\\left(n_{u} n_{v}\\right) \\sum_{i} \\sum_{j} f\\left[u_{i}, v_{j}\\right]}\\\\ p(v)&amp;=\\int p(u, v) \\mathrm{d} u=\\frac{\\left(1 / n_{u}\\right) \\sum_{i} f\\left[u_{i}, \\tilde{v}\\right]}{I_{f}}\\\\ p(u \\mid v)&amp;=\\frac{p(u, v)}{p(v)}=\\frac{f[\\tilde{u}, \\tilde{v}] / I_{f}}{p[\\tilde{v}]} \\end{aligned}p(u,v)p(v)p(u∣v)​=∬f(u,v)du dvf(u,v)​=1/(nu​nv​)∑i​∑j​f[ui​,vj​]f[u~,v~]​=∫p(u,v)du=If​(1/nu​)∑i​f[ui​,v~]​=p(v)p(u,v)​=p[v~]f[u~,v~]/If​​​ Distribution2D 类型负责了这类内容的采样。 13.7 Russian Roulette and Splitting 我们首先使用耗时 TTT 和方差 VVV 定义一个估计器的效能： ϵ[F]=1V[F]T[F]\\epsilon[F] = {1 \\over V[F]T[F]} ϵ[F]=V[F]T[F]1​ Russian Roulette 和 Splitting 是两种可以提高效能的算法，它们通过提高高贡献值的样本比例而在相同的时间内获得更小的方差。 13.7.1 Russian Roulette 考虑直接光照的积分： Lo(p,ωo)=∫S2fr(p,ωo,ωi)Ld(p,ωi)∣cos⁡θi∣dωiL_{\\mathrm{o}}\\left(\\mathrm{p}, \\omega_{\\mathrm{o}}\\right)=\\int_{\\mathrm{S}^{2}} f_{\\mathrm{r}}\\left(\\mathrm{p}, \\omega_{\\mathrm{o}}, \\omega_{\\mathrm{i}}\\right) L_{\\mathrm{d}}\\left(\\mathrm{p}, \\omega_{\\mathrm{i}}\\right)\\left|\\cos \\theta_{i}\\right| \\mathrm{d} \\omega_{\\mathrm{i}} Lo​(p,ωo​)=∫S2​fr​(p,ωo​,ωi​)Ld​(p,ωi​)∣cosθi​∣dωi​ 假设我们决定使用两个样本来估计这个积分，则有： Lo(p,ωo)≈12∑i=12fr(p,ωo,ωi)Ld(p,ωi)∣cos⁡θi∣p(ωi)L_o(p, \\omega_o) \\approx {1 \\over 2}\\sum_{i=1}^2 {f_{\\mathrm{r}}\\left(\\mathrm{p}, \\omega_{\\mathrm{o}}, \\omega_{\\mathrm{i}}\\right) L_{\\mathrm{d}}\\left(\\mathrm{p}, \\omega_{\\mathrm{i}}\\right)\\left|\\cos \\theta_{i}\\right| \\over p(\\omega_i)} Lo​(p,ωo​)≈21​i=1∑2​p(ωi​)fr​(p,ωo​,ωi​)Ld​(p,ωi​)∣cosθi​∣​ 在这一行为中，大部分的计算量来自于跟踪 shadow ray 以测试光源和着色点之间是否有遮挡物的操作。显而易见的，对于任何使得 fr(p,ωo,ωi)=0f_{\\mathrm{r}}\\left(\\mathrm{p}, \\omega_{\\mathrm{o}}, \\omega_{\\mathrm{i}}\\right) = 0fr​(p,ωo​,ωi​)=0 的方向，我们都应该跳过 shadow ray 的跟踪工作。Russian Roulette 让我们有机会掠过其它 frf_rfr​ 值较低的部分，从而将更多的计算量集中在贡献值更大的位置。 实现这一算法的步骤如下： 首先根据先验知识和经验设定一个截止概率 qqq 直接跳过任何在该概率以下权重的采样，并返回一个预设常数 ccc（通常是零） 对于其它样本，以 (F−qc)/(1−q)(F - qc) / (1-q)(F−qc)/(1−q) 为权重加权得到结果 统计学上，这是一种无偏的方法，但它仅仅能够在统计学上增加估计器的效能，甚至在选择了不正确的截止概率时，这一方法还会大大增加方差，从而反而降低效能。 13.7.2 Splitting 相对于减少不重要样本的采样的 Russian Roulette 方法，Splitting 方法通过更好地分配采样数以增加效能。 考虑对某个无 pixel filter 的像素的求解： P(x,y)=∫Ap∫S2Ld(x,y,ω)dApdωP(x,y)=\\int_{A_{\\mathrm{p}}} \\int_{S^2} L_{\\mathrm{d}}\\left(x,y,\\omega\\right) \\mathrm{d} A_{\\mathrm{p}} \\mathrm{d} \\omega P(x,y)=∫Ap​​∫S2​Ld​(x,y,ω)dAp​dω 一种很自然的方法是生成数组不同的光线采样，每组有各自的像素位置和方向。假设场景中有且只有一个面光源，且所有光线均击中了物体，那么如果我们发射100 条这样的光线，就需要 100 次 shadow ray 运算和 100 次 camera ray 运算。然而事实上我们可能并不需要如此多的 camera ray 以生成优质的图像，事实上，如果我们仅仅发射 5 根从相机出发的光线，并在其中每根光线上采样 20 次光源，这样我们就可以在光线追踪数量大幅减少的同时获得近似的效果。 13.8 Careful Sample Placement 为了减少采样的方差，一种方式是使用更加精心挑选的采样位置以使得样本能获取更多积分的特征。 13.8.1 Stratified Sampling Stratified Sampling 通过将积分域 Λ\\LambdaΛ 划分为 nnn 个不重复的区域，然后根据各区域内的密度函数分别取 nin_ini​ 个样本，则有： F=∑i=1nvi(1ni∑j=1nif(Xi,j)pi(Xi,j))F = \\sum_{i=1}^nv_i\\left( {1 \\over n_i}\\sum_{j=1}^{n_i}{f(X_{i,j}) \\over p_i(X_{i,j})} \\right) F=i=1∑n​vi​(ni​1​j=1∑ni​​pi​(Xi,j​)f(Xi,j​)​) 其中 ∑vi=1\\sum v_i = 1∑vi​=1 是各个区域的大小占总大小的比重。根据每一部分内的均值 μi\\mu_iμi​ 和方差 σi2\\sigma_i^2σi2​ 我们可以得到总方差： V[F]=V[∑viFi]=∑V[viFi]=∑vi2V[Fi]=∑vi2σi2ni\\begin{aligned}V[F] &amp;=V\\left[\\sum v_{i} F_{i}\\right] \\\\&amp;=\\sum V\\left[v_{i} F_{i}\\right] \\\\&amp;=\\sum v_{i}^{2} V\\left[F_{i}\\right] \\\\&amp;=\\sum \\frac{v_{i}^{2} \\sigma_{i}^{2}}{n_{i}}\\end{aligned} V[F]​=V[∑vi​Fi​]=∑V[vi​Fi​]=∑vi2​V[Fi​]=∑ni​vi2​σi2​​​ 特别地，当我们以区域大小作为区域采样数量的基准，即 ni=viNn_i = v_iNni​=vi​N 时： V[FN]=1N∑viσi2V[F_N] = {1 \\over N}\\sum v_i\\sigma_i^2 V[FN​]=N1​∑vi​σi2​ 为了将其与随机采样进行对比，我们设随机采样的采样方式实际上是首先随机选择一个区域 III ，再在区域中进行采样 XXX，通过条件概率的方差公式可得： V[F]=∑ivi(1vi∫Λi(f(x)−μ)2dx)=∑ivi(1vi(∫Λi(f(x)−μi)2dx+∫Λi(μi−μ)2dx))=1N[∑viσi2+∑vi(μi−μ)2]=ExViF+VxEiF\\begin{aligned} V[F] &amp;= \\sum_i v_i\\left({1\\over v_i}\\int_{\\Lambda_i}(f(x)-\\mu)^2\\mathrm{d}x\\right)\\\\ &amp;= \\sum_i v_i\\left({1\\over v_i}\\left(\\int_{\\Lambda_i}(f(x)-\\mu_i)^2\\mathrm{d}x + \\int_{\\Lambda_i}(\\mu_i - \\mu)^2\\mathrm{d}x\\right)\\right)\\\\&amp;=\\frac{1}{N}\\left[\\sum v_{i} \\sigma_{i}^{2}+\\sum v_{i}\\left(\\mu_{i}-\\mu\\right)^2\\right]\\\\ &amp;=E_{x} V_{i} F+V_{x} E_{i} F \\end{aligned}V[F]​=i∑​vi​(vi​1​∫Λi​​(f(x)−μ)2dx)=i∑​vi​(vi​1​(∫Λi​​(f(x)−μi​)2dx+∫Λi​​(μi​−μ)2dx))=N1​[∑vi​σi2​+∑vi​(μi​−μ)2]=Ex​Vi​F+Vx​Ei​F​ 这一公式向我们展示了 Stratified Sampling 的一个优势之处：它只会减少方差，无论再差的设置也顶多是和完全随机一样差罢了。但它也并非毫无缺点，最大的一点就在于它和其它采样方法一样会受到维度灾难的影响，随着维度数量增加、复杂度以指数上升。另一方面，Stratified Sampling 的效果也和用于 stratify 的维度有关。我们一般会 stratify 具有较强的相关性的维度，如之前的那个直接光照的例子中，stratify (x,y)(x, y)(x,y) 和 (θ,ϕ)(\\theta, \\phi)(θ,ϕ) 维度的效果就远远好于 stratify (x,ϕ)(x,\\phi)(x,ϕ) 一类的组合。 13.8.2 Quasi Monte Carlo 在第七章中提到的一些其它采样方法组成了 quasi Monte Carlo 算法的基础。与标准的蒙特卡洛算法使用随机数生成采样这一点不同的是，这一类算法会使用确定性算法事先确定采样的样本位置，从而在一些情况下获得更高的收敛速率。而且蒙特卡洛算法中的一些技术（如重要性采样）也可以直接使用这种方法生成的采样。 13.8.3 Warping Samples and Distortion 大部分采样算法均事先生成 U[0,1]nU[0,1]^nU[0,1]n 的样本，再通过算法转换到真正的采样域中，虽然在概率上分布依旧是均匀的，但由于空间的变换，原有 stratified 的样本的规律性会在这个过程中受损，如下图第一种方式是从一个 4×44 \\times 44×4 的来自 U[0,1]2U[0,1]^2U[0,1]2 的 stratified sampling 采样映射到长方形的结果，它明显得要比使用确定性算法生成的低偏差采样来的差。 和 13.6.2 中提出的另一种映射到圆上的方式类似，这些例子体现了选择更好的映射方式和采样方式对最终采样图案的影响。 13.9 Bias 另一种降低方差的方法是人为地引入偏差（bias）。一个估计器的偏差定义为：β=E[F]−∫f(x)dx\\beta = E[F]-\\int f(x)\\mathrm{d}xβ=E[F]−∫f(x)dx 一个引入偏差降低方差的例子是，考虑两个估计器 F1=1N∑i=1NXi, F2=12max⁡(X1,X2,⋯ ,Xn)F_1 = {1\\over N}\\sum_{i=1}^N X_i,\\ F_2 = {1\\over 2}\\max(X_1, X_2, \\cdots, X_n)F1​=N1​∑i=1N​Xi​, F2​=21​max(X1​,X2​,⋯,Xn​) ，虽然第一个估计器是无偏的，但它的方差是 O(N−1)O(N^{-1})O(N−1) ，而后者的方差却只有 O(N−2)O(N^{-2})O(N−2) 另一个例子是 7.8 中讨论的图像重建方法，我们的目标是使用一个 滤波函数 fff 在像素面积上对辐照度分布进行卷积： I(x,y)=∬f(x−x′,y−y′)L(x′,y′)dx′dy′I(x, y)=\\iint f\\left(x-x^{\\prime}, y-y^{\\prime}\\right) L\\left(x^{\\prime}, y^{\\prime}\\right) \\mathrm{d} x^{\\prime} \\mathrm{d} y^{\\prime} I(x,y)=∬f(x−x′,y−y′)L(x′,y′)dx′dy′ 一种无偏的方法是使用传统的蒙特卡洛方法： I(x,y)≈1N∑i=1Nf(x−xi,y−yi)L(xi,yi)p(xi,yi)I(x, y) \\approx {1 \\over N} \\sum_{i=1}^{N} {f\\left(x-x_{i}, y-y_{i}\\right) L\\left(x_{i}, y_{i}\\right) \\over p(x_i, y_i)} I(x,y)≈N1​i=1∑N​p(xi​,yi​)f(x−xi​,y−yi​)L(xi​,yi​)​ 但 PBRT 中实际使用的则是一个有偏的方法，其公式如下： I(x,y)≈∑i=1Nf(x−xi,y−yi)L(xi,yi)∑i=1Nf(x−xi,y−yi)I(x, y) \\approx {\\sum_{i=1}^{N} f\\left(x-x_{i}, y-y_{i}\\right) L\\left(x_{i}, y_{i}\\right) \\over \\sum_{i=1}^{N} f\\left(x-x_{i}, y-y_{i}\\right)} I(x,y)≈∑i=1N​f(x−xi​,y−yi​)∑i=1N​f(x−xi​,y−yi​)L(xi​,yi​)​ 考虑一种情况：整个图像上的亮度值均为常数 1 ，那么第二种方法会毫无疑问地给出常数 1 ，而前者则由于采样的随机性而不一定能够给出稳定的准确结果。 13.10 Importance Sampling 重要性采样是应用中最重要的减少方差的手段之一，如下的蒙特卡洛积分器： FN=1N∑i=1Nf(Xi)p(Xi)F_N = {1 \\over N} \\sum_{i=1}^N {f(X_i) \\over p(X_i)} FN​=N1​i=1∑N​p(Xi​)f(Xi​)​ 当我们选择样本的概率 ppp 接近被积函数 fff 时，其收敛的速度可以明显地加快。考虑一个简单的 diffuse 平面的采样，当我们完全随机地采样，即 p(x)=1p(x) = 1p(x)=1 时，在很多情况下我们可能采样到接近于法线平行的掠射角，从而生成一根对最终结果贡献甚微的光线。另一个例子是如果我们极端地使用完全正比于被积函数的概率采样样本，使用这种方式得到的结果就能拥有零方差，是完全准确的估计值。 p=f(x)∫f(x)dxf(Xi)p(Xi)=∫f(x)dx\\begin{aligned} p &amp;= {f(x) \\over \\int f(x)\\mathrm{d}x}\\\\ {f(X_i) \\over p(X_i)} &amp;= \\int f(x)\\mathrm{d}x \\end{aligned}pp(Xi​)f(Xi​)​​=∫f(x)dxf(x)​=∫f(x)dx​ 然而在另一方面，选择错误的采样概率，如和被积函数形状相差甚远的概率时反而会降低算法的收敛速度。 13.10.1 Multiple Importance Sampling 单纯的重要性采样给出了对单一函数 f(x)f(x)f(x) 进行快速积分估计的方法，但实际上我们可能还会遇到由多个函数的乘积组成的积分 ∫f(x)g(x)dx\\int f(x)g(x) \\mathrm{d}x∫f(x)g(x)dx ，如光线传输方程中的多项乘积、微表面模型中的各项乘积等。 多重重要性采样的方法提供了使用多个分布结合采样的指导思想。其基本思想在于，对于所有的分布同时进行采样，再接着从这些样本中挑选出真正使用的采样。MIS 提供了在多个采样之中选择所需采样的加权方法，这同时可以有效地降低估计器的方差。 在从两个分布的乘积中采样的 MIS 算法给出的估计公式如下： 1nf∑i=1nff(Xi)g(Xi)wf(Xi)pf(Xi)+1ng∑j=1ngf(Yj)g(Yj)wg(Yj)pg(Yj)\\frac{1}{n_{f}} \\sum_{i=1}^{n_{f}} \\frac{f\\left(X_{i}\\right) g\\left(X_{i}\\right) w_{f}\\left(X_{i}\\right)}{p_{f}\\left(X_{i}\\right)}+\\frac{1}{n_{g}} \\sum_{j=1}^{n_{g}} \\frac{f\\left(Y_{j}\\right) g\\left(Y_{j}\\right) w_{g}\\left(Y_{j}\\right)}{p_{g}\\left(Y_{j}\\right)} nf​1​i=1∑nf​​pf​(Xi​)f(Xi​)g(Xi​)wf​(Xi​)​+ng​1​j=1∑ng​​pg​(Yj​)f(Yj​)g(Yj​)wg​(Yj​)​ 其中 nf,ngn_f,n_gnf​,ng​ 是在各个分布中选择的样本数量，X,YX,YX,Y 分别是从不同分布中采样的样本，wf,wgw_f,w_gwf​,wg​ 是选用的特殊的加权函数以将估计值调整至无偏。这一加权函数需要考虑到所有可能的样本生成方式，而不只是关注于当前的样本。一种简单好用的是平衡地启发式加权函数： ws(X)=nsps(X)∑inipi(X)w_s(X) = {n_sp_s(X) \\over \\sum_i n_ip_i(X)} ws​(X)=∑i​ni​pi​(X)ns​ps​(X)​ 它代表了当前样本在当前分布下的概率密度占所有分布下得到概率密度之和的比例。在实际使用中，有时还会对这一权重做一次幂乘处理，变为： ws(X)=(nsps(X))β∑i(nipi(X))βw_s(X) = {(n_sp_s(X))^\\beta \\over \\sum_i (n_ip_i(X))^\\beta} ws​(X)=∑i​(ni​pi​(X))β(ns​ps​(X))β​ 这种处理可以增加对于某一分布而言优秀的样本的权重，在经验上选择 β=2\\beta = 2β=2 是一种可行的方法。 推广到 nnn 个分布的更一般的表述如下： F=∑i=1n1ni∑j=1niwi(Xi,j)×f(Xi,j)pi(Xi,j)F=\\sum_{i=1}^{n} \\frac{1}{n_{i}} \\sum_{j=1}^{n_{i}} w_{i}\\left(X_{i, j}\\right) \\times \\frac{f\\left(X_{i, j}\\right)}{p_{i}\\left(X_{i, j}\\right)} F=i=1∑n​ni​1​j=1∑ni​​wi​(Xi,j​)×pi​(Xi,j​)f(Xi,j​)​","categories":[{"name":"programming","slug":"programming","permalink":"https://blog.apassbydreg.work/categories/programming/"},{"name":"reading notes","slug":"programming/reading-notes","permalink":"https://blog.apassbydreg.work/categories/programming/reading-notes/"}],"tags":[{"name":"CG","slug":"CG","permalink":"https://blog.apassbydreg.work/tags/CG/"},{"name":"render","slug":"render","permalink":"https://blog.apassbydreg.work/tags/render/"},{"name":"PBRT","slug":"PBRT","permalink":"https://blog.apassbydreg.work/tags/PBRT/"}]},{"title":"PBRT 第十二章笔记 | Notes for PBRT Chapter 12 - Light Sources","slug":"PBRT-ch12","date":"2021-12-07T11:54:28.000Z","updated":"2021-12-07T11:59:55.957Z","comments":true,"path":"2021/12/PBRT-ch12/","link":"","permalink":"https://blog.apassbydreg.work/2021/12/PBRT-ch12/","excerpt":"","text":"若要使场景中的物体可见，场景中必定需要有向外辐射光子的光源。本节将首先讨论不同的发光物理过程，并引入基础的 Light 抽象类。紧接着讲解几种常用的光源类型。 12.1 Light Emission 所有非处在绝对零度的物体中均有运动的原子。而根据麦克斯韦定理，运动的电荷会向四周辐射电磁波。大部分室温下的物体辐射的波长均在红外波段，而辐射可见光波段的物体则需要具有更高的温度。当前市面上常见的物理光源有以下几种： 白炽灯：它使用一根钨丝通过大量电流产生热量从而发光。其发光的颜色（即能量在各个波长上的分布）取决于钨丝的温度。钨丝的外侧通常被一层磨砂玻璃包裹以吸收特定波长的光线，从而获得需要的 SPD 。白炽灯的大部分能量均集中在红外波段，也就是说输入它的能量大部分转换为了热量而非光能。 卤素灯：这种灯相当于在白炽灯的真空中填充了卤素气体。在普通白炽灯中，钨丝会在加热过程中逐渐升华、进而沉积在灯泡内壁上使得灯泡变暗。卤素灯中的卤素气体能通过将大部分气化的钨重新附着回灯丝上而延长灯泡的寿命。 气体放电灯：这种灯在气体中直接施加电流，使得这些气体根据原子的性质释放出特定波长的光线。在灯管的内侧常常涂有荧光材料以吸收有害的紫外线，并将能量转化到更多的波长范围上。 LED 灯：这一类灯基于电激发光的原理制造，它使用在通电时释放光子的特殊材料制作。 对于气体放电灯和 LED 灯具，其相通的底层物理原理均是电子与原子撞击时产生的外层电子层级跃迁现象。当外层电子回到低能级时就会将能量以光能释放。 对于物理光源，我们可以定义它的光转换效率： ∫Φe(λ)V(λ)dλ∫Φi(λ)dλ\\int\\Phi_e(\\lambda)V(\\lambda)\\mathrm{d}\\lambda \\over \\int\\Phi_i(\\lambda)\\mathrm{d}\\lambda ∫Φi​(λ)dλ∫Φe​(λ)V(λ)dλ​ 式中的 VVV 代表 5.4.3 中提到的观测者的光谱响应曲线，表示接收者对不同波段的光的敏感程度。另一方面，该式的分子部分也可以使用光具使用的总能量代替。它的量纲是 lm/W\\mathrm{lm / W}lm/W ，以白炽灯为例，它的转换率大约是 15 lm/W15 \\ \\mathrm{lm / W}15 lm/W 。 12.1.1 黑体辐射 黑体是一种完美的辐射体，它会吸收所有的能量，并只根据自身的温度发射电磁波。黑体发出的辐射 SPD 可以用一个关于波长和温度的公式描述，根据普朗克定律： Le(λ,T)=2hc2λ5(ehc/λkbT−1)L_e(\\lambda,T) = {2hc^2 \\over \\lambda^5(e^{hc/\\lambda k_b T} - 1)} Le​(λ,T)=λ5(ehc/λkb​T−1)2hc2​ 其中 hhh 是普朗克常数，ccc 是光速，kbk_bkb​ 是玻尔兹曼常数 1.3806488×10−23J/K1.3806488 \\times 10^{-23} \\mathrm{J/K}1.3806488×10−23J/K 玻尔兹曼公式给出了黑体上任意一点处的全频段辐出功率（单位是 W/m2\\mathrm{W/m^2}W/m2）： M(p)=σT4, σ=5.67032×10−8Wm−2K−4M(p) = \\sigma T^4, \\ \\sigma = 5.67032 \\times 10^{-8} Wm^{-2}K^{-4} M(p)=σT4, σ=5.67032×10−8Wm−2K−4 从黑体辐射公式我们也能很容易地知道能量最高的频率： λmax=bT, b=2.897721×10−3mK\\lambda_{max} = {b \\over T}, \\ b = 2.897721 \\times 10^{-3} \\mathrm{mK} λmax​=Tb​, b=2.897721×10−3mK 而对于非黑体而言，根据基尔荷夫公式可得：对于任何达到了热平衡的物体，给定其出射的方向和温度，其 SPD 应该正比于黑体辐射，且比例与该方向上的半球反照率有关。表示的公式如下： Le′(T,λ,ω)=Le(T,λ)(1−ρhx(ω))L_e&#x27;(T,\\lambda,\\omega) = L_e(T,\\lambda)(1 - \\rho_{hx}(\\omega)) Le′​(T,λ,ω)=Le​(T,λ)(1−ρhx​(ω)) 黑体辐射可以定义发光体的色温。如果某一发光体的 SPD 与某一温度 TTT 下的黑体辐射相似 ，我们可以称其色温为 TTT 。一般而言，卤素灯和白炽灯的色温一般在 2700∼3000K2700 \\sim 3000 \\mathrm{K}2700∼3000K 之间，而荧光灯的色温可以达到 3000∼6000K3000 \\sim 6000 \\mathrm{K}3000∼6000K 。人们可以通过色温高低区分颜色的冷暖。 12.1.2 Standard Illuminants 另一种用于区分发光能量分布的方式是将 SPD 与 CIE 标准光源的 SPD 作为代表，并归类到 AAA 至 FFF 的其中一类的标准发光体上。 Standard Illuminant A 于 1931 年引入，它最初的目的是为了体现大部分白炽灯的发光性能，因此设为了当时 2850K2850\\mathrm{K}2850K 的黑体辐射 SPD ，随着技术进步，数值精度的提高，现代的 Standard Illuminant A 相当于 2856K2856\\mathrm{K}2856K 的黑体辐射。 Standard Illuminant B 和 C 原本用于建模一天中的两个时段的天光，但目前已经不再使用。 Standard Illuminant D 则描述了天光的不同形态。它由一系列有关天光 SPD 的向量分析得出，具有一个固定部分和两个可变加权部分。两个可变部分分别代表了一个在黄蓝色域上的云量变量以及一个在粉绿色域上的大气含水量变量。特别地，D65 标准是一个类 6504K 的黑体辐射 SPD ，它表示了欧洲正午十分的光线。 Standard Illuminant E 表示了一个常数 SPD ，一般仅被用于和其它组分比较。 Standard Illuminant F 则表示了一系列不同的荧光 SPD ，它们的定义来自于对一系列常用荧光灯的 SPD 测量值。 12.2 Light Interface 12345678910111213141516171819202122232425262728class Light &#123; public: // Light Interface virtual ~Light(); Light(int flags, const Transform &amp;LightToWorld, const MediumInterface &amp;mediumInterface, int nSamples = 1); virtual Spectrum Sample_Li(const Interaction &amp;ref, const Point2f &amp;u, Vector3f *wi, Float *pdf, VisibilityTester *vis) const = 0; virtual Spectrum Power() const = 0; virtual void Preprocess(const Scene &amp;scene) &#123;&#125; virtual Spectrum Le(const RayDifferential &amp;r) const; virtual Float Pdf_Li(const Interaction &amp;ref, const Vector3f &amp;wi) const = 0; virtual Spectrum Sample_Le(const Point2f &amp;u1, const Point2f &amp;u2, Float time, Ray *ray, Normal3f *nLight, Float *pdfPos, Float *pdfDir) const = 0; virtual void Pdf_Le(const Ray &amp;ray, const Normal3f &amp;nLight, Float *pdfPos, Float *pdfDir) const = 0; // Light Public Data const int flags; const int nSamples; const MediumInterface mediumInterface; protected: // Light Protected Data const Transform LightToWorld, WorldToLight;&#125;; 所有的 Light 派生类均含有以下四个变量： flags 变量表示了基础的光源类型，其中包括了面光源、点光源、方向光源等。蒙特卡洛算法需要根据光源的不同类型做出不同的计算 一组表示了光源与世界坐标互相转化的变换，光源一般都定义在光源坐标的原点，并使用统一的方向 一个表示了光源所在介质的 MediumInterface nSamples 变量表示了面光源使用的采样数量 对光源而言，最重要的接口是 Sample_Li() 函数。它接受一个代表了目标点的世界坐标的 Interaction 参数，并返回在没有遮挡的情况下、从光源到达该位置的 radiance 量。值得注意的是，PBRT 中的光源并不支持动画，所有光源必须是静止的。 Sample_Li() 还负责初始化光源到着色点位置的射线 ωi\\omega_iωi​ 、以及使用阴影光线测试光源是否可见的 VisibilityTester 对象（虽然当返回值为黑色时这一对象不会被使用）。 另一个所有光源类需要实现的接口是返回其释放的所有能量之和的 Power() 函数。这一值对于一些光线传输算法（如找到贡献度最高的光源并计算阴影）而言具有一定意义，但它并不需要返回一个完全精确的值。 最后，所有光源还具有一个预处理接口，用于在渲染前使用场景信息事先生成一部分数据以供其后使用。 12.2.1 可见性测试 VisibilityTester 是一个闭包——它包裹了一部分数据和一部分需要完成的计算内容。将这一部分单独抽象出来使得光源类可以在无遮挡的假设下返回信息，而让 Integrator 决定该信息是否被使用。 这个类中储存了两个 Interaction 数据，代表了一条 shadow ray 的两端。Integrator 接下来可以使用任意一个函数 Unoccluded() 或 Tr() 来获得这条 shadow ray 上面的光线传输量。 第一个接口仅返回一个布尔值代表光源和着色点之间是否没有遮挡，而第二个接口则会沿途调用所有介质的 Tr() 接口，返回最终的传输率。 12.3 Point Lights 12.3.1 点光源 最基础的点光源向各个方向均匀地释放能量，它的位置固定在灯光坐标系的原点位置。描述点光源的物理量是一个常量 intensity ，表示单位立体角上从这个光源释放的能量。它的光源类型被设置为 LightFlags::DeltaPosition 。为了减少重复的变换计算，它储存了一个预计算量 pLight 表示点光源在世界坐标下的位置。 对于其 Sample_Li 接口，通过简单地将 intensity 除以距离的平方即可得到对应的 radiance ，而 Power 接口则可以由立体角积分得到解析解 Φ=∫S2Idω=4πI\\Phi = \\int_S^2I\\mathrm{d}\\omega = 4\\pi IΦ=∫S2​Idω=4πI 12.3.2 聚光灯 与点光源向所有方向发射能量不同，聚光灯指向光线坐标的 +z+z+z 方向的一个锥体内发射光线。这个锥体由两个角度 totalWidth 和 falloffStart 定义如下： 聚光灯 Sample_Li 的接口实际上就相当于将点光源乘以一个衰减项：光线从 falloffStart 角度开始衰减，直到 totalWidth 位置最终变为零。SpotLight 类型中负责计算这一衰减值的函数是 Falloff() 。 衰减函数的计算流程也并不困难：首先计算光线方向与聚光灯方向的 cos⁡\\coscos 夹角，再将这个夹角与 cosTotalWidth, cosFalloffStart 比较。若光线在衰减范围内，则使用一个四次方 cos⁡\\coscos 的插值作为衰减值，这部分代码如下： 1234// Compute falloff inside spotlight coneFloat delta = (cosTheta - cosTotalWidth) / (cosFalloffStart - cosTotalWidth);return (delta * delta) * (delta * delta); 给定锥体角度，其张成的立体角度为 2π(1−cos⁡θ)2\\pi(1 - \\cos\\theta)2π(1−cosθ) ，由于 Power 并不要求对衰减区域内的能量求精确解，我们可以直接使用一个无衰减的、立体角度 cos⁡\\coscos 为 cosTotalWidth, cosFalloffStart 的中值的圆锥体替代求解，即： 123Spectrum SpotLight::Power() const &#123; return I * 2 * Pi * (1 - .5f * (cosFalloffStart + cosTotalWidth));&#125; 12.3.3 材质投影光源 这类材质接收一个二维的图像作为映射，从一点按给定的 fov 投影到一个锥体上。 与透视相机类似地，材质投影光源也会计算一个投影矩阵。除此之外，他还会计算从中点到角点这一夹角的余弦值以确定包裹了这一投影的最小圆锥体。 在 Sample_Li() 的过程中，首先会调用投影矩阵获得着色点在材质上的 uv 位置，接着从材质上采样对应位置（PBRT 在这里并没有使用到偏导数纠正采样）。最后将颜色值乘以 intensity 并除以距离的平方即可得到 radiance 。 对于光线释放的总能量，由于 mipmap 的最高层级以将计算过整体材质颜色值的均值，我们直接通过对最高层查询即可得到它。接着会使用之前的最小包裹锥体的立体角替代方形锥体的立体角计算总能量。需要注意的是，这一近似在投影长宽比接近方形时才比较准确，否则可能带来较大的误差。 12.3.4 Goniophotometric Diagram Lights 这类光源使用一张球形贴图包裹点光源，使用对应方向上采样的亮度值模拟点光源发光的方向性，在采样光线时，根据光线的方向计算出球坐标的 uv ，将贴图采样值与 intensity 相乘、最后除以距离的平方即可得到 radiance 。在计算能量时，也只需要简单地将贴图的均值乘以点光源的能量即可。 12.4 Distant Lights 这种光源放置在极其遥远的位置，因此光线的方向近乎平行，又被称为方向光源。由于其距离极其遥远，我们通常认为它必定是在真空中，而不经过介质计算。但当采样光线时，这类光源需要知道场景的边界，以从场景的边界外的某一点出发采样光线，从而可以对场景内的介质做出反应。因此，DistantLight::Preprocess 接口会记录场景的包围球，并写入自身的成员变量中。 对光源的采样而言，我们只需要初始化一个从着色点开始，长度为场景包围球直径的 shadow ray ，并直接返回本光源对应的 radiance 即可。 当我们需要计算这类光源释放的总能量时，我们会将场景的包围球投影到与光线垂直的平面上，通过对 radiance 的积分得到总能量 2πr2×L2\\pi r^2 \\times L2πr2×L 12.5 Area Lights 面光源是使用至少一个几何体定义的发光表面。表面上的每一点又可能拥有各自的方向性辐射能量分布。总的来说，对面光源求解到达着色点的能量需要在整个光源上进行积分，但这实际上是几乎不可能做到的。高复杂度带来的是柔和的、更加贴近现实表现的软阴影，而不是像之前的光源一样的硬边界。 AreaLight 是继承于 Light 类的一个抽象类，它提供了一个新的接口 AreaLight::L() ，给定表面上的一点和出射方向，本接口会返回该条光线上的 radiance 。SurfaceInteraction::Le() 便调用了这一方法计算自发光的 radiance 。 DiffuseAreaLight 实现了一种面光源的一般形态，它向四周均匀地发射光线。它使用一个 Shape 指针指向发光的表面，并在法线正半球均匀发出光线。由于其发光的均匀性，在实现上述 L() 接口时只需要简单地测试出射光线是否在出射位置的法线正半球内即可。 计算面光源的 Sample_Li() 较为困难，这一部分将在 14 章中详细描述。 而 DiffuseAreaLight 的总能量则可以通过将表面的每个点视为一个点光源，并在表面上积分得到：Φ=L×Sπ\\Phi = L \\times S\\piΦ=L×Sπ 12.6 Infinite Area Lights 在一些情况下，我们需要一些来自无穷远的，包围整个场景的面积无穷大的光源（如天光等环境光照）。一种常用的表现方法时使用一个经纬度 radiance （又称 equirectangular projection ）贴图表示从各个方位而来的光线 radiance 。 与 DistantLight 类似，InfiniteAreaLight 也需要在预计算期间获得场景的包围球。由于其需要在一整块区域上采样光源，采样期间也需要蒙特卡洛方法的帮助。接下来会在 14 章中详细描述 PDF 的预计算以及光线采样的内容。 计算这类光源的总能量的方法和平行光类似，它同样使用场景的球面近似，近似方法为：Φ=Lˉ×πrscene2\\Phi = \\bar{L} \\times \\pi r_{scene}^2Φ=Lˉ×πrscene2​ 由于这种光源同样会对没有击中物体的光线产生影响，在 Light 抽象类中还有另外一个接口 Le() 用于处理没有发生相交的光线。","categories":[{"name":"programming","slug":"programming","permalink":"https://blog.apassbydreg.work/categories/programming/"},{"name":"reading notes","slug":"programming/reading-notes","permalink":"https://blog.apassbydreg.work/categories/programming/reading-notes/"}],"tags":[{"name":"CG","slug":"CG","permalink":"https://blog.apassbydreg.work/tags/CG/"},{"name":"render","slug":"render","permalink":"https://blog.apassbydreg.work/tags/render/"},{"name":"PBRT","slug":"PBRT","permalink":"https://blog.apassbydreg.work/tags/PBRT/"}]},{"title":"基于 Optix 的渲染器框架 v0.2 | Optix Based Renderer Framework v0.2","slug":"OptixBasedRendererFramework-v0-2","date":"2021-12-06T13:46:03.000Z","updated":"2022-02-26T02:41:22.909Z","comments":true,"path":"2021/12/OptixBasedRendererFramework-v0-2/","link":"","permalink":"https://blog.apassbydreg.work/2021/12/OptixBasedRendererFramework-v0-2/","excerpt":"","text":"简介 本项目是一个基于 Optix 7.3 的 GPU 光线追踪渲染框架，在保障了一定的可拓展性的同时，利用 NVIDIA 光线追踪技术提高了渲染的效率。 本页面仅为 v0.2 版本的介绍，旧版本介绍见此页面 渲染样例 更新日志 架构更新 修复了部分内存和显存的管理问题 使用智能指针代替裸指针 更改了 derived instances 储存的位置，现在由各个类管理它们各自的 instances 和 derived classes 使用 Spectrum 类替代 float4 储存 radiance ，在之后可以使用更广的光谱渲染结果 增加了 instancing 机制，您现在可以复用同一模型，描述文件的语法也因此发生了改变 配合 instancing 机制更改了渲染流程，现在 Hit Program 由单独的 Integrator 类管理，原来的 Mesh 则抽象出从一个 HitData 生成 SurfaceData 的接口，转移到 Direct Callable 中 内容更新 修复了数个渲染问题 将部分材质的常数参数接口改为贴图接口 增加了玻璃材质，使用非导体的菲涅尔函数计算反射与折射 附录 新的场景结构与渲染流程 注：其中的 MatrixMotionTransform 暂时还没有实现，目前可以通过指定 instance 的 transform 来实现不同 instance 的分离 相关链接 代码仓库：https://gitee.com/martin_z_he/optix-based-renderer 介绍文档：https://gitee.com/martin_z_he/optix-based-renderer/raw/master/doc/presentations/presentation-20210830.pdf","categories":[{"name":"programming","slug":"programming","permalink":"https://blog.apassbydreg.work/categories/programming/"},{"name":"projects","slug":"programming/projects","permalink":"https://blog.apassbydreg.work/categories/programming/projects/"}],"tags":[{"name":"CG","slug":"CG","permalink":"https://blog.apassbydreg.work/tags/CG/"},{"name":"render","slug":"render","permalink":"https://blog.apassbydreg.work/tags/render/"},{"name":"OBR","slug":"OBR","permalink":"https://blog.apassbydreg.work/tags/OBR/"}]},{"title":"PBRT 第十一章笔记 | Notes for PBRT Chapter 11 - Volume Scattering","slug":"PBRT-ch11","date":"2021-12-04T03:00:46.000Z","updated":"2021-12-04T03:05:38.529Z","comments":true,"path":"2021/12/PBRT-ch11/","link":"","permalink":"https://blog.apassbydreg.work/2021/12/PBRT-ch11/","excerpt":"","text":"11.1 Volume Scattering Processes 体积散射中有三个主要的过程： 吸收 Absorption 发光 Emission 散射 Scattering 而这其中的各个过程均有可能是同质（homogeneous）或异质（inhomogeneous）的。同质的体积中各个位置处的各个参数相等，而异质的体积中各个参数则可能不同。 11.1.1 Absorption 散射中的吸收代表了入射的 radiance 在经过单位体积后在相同方向上出射的能量减少的比例，既有：（注意 PBRT 中入射光的方向和光线的传播方向是相反的） dLo(p,ω)=−σa(p,ω)Li(p,−ω)dtLo(p+dω,ω)=Li(p,−ω)e−∫0dσa(p+tω,ω)dt\\mathrm{d}L_o(p, \\omega) = -\\sigma_a(p, \\omega)L_i(p, -\\omega)\\mathrm{d}t\\\\ L_o(p+d\\omega, \\omega) = L_i(p, -\\omega)e^{-\\int_0^d\\sigma_a(p+t\\omega, \\omega)\\mathrm{d}t}dLo​(p,ω)=−σa​(p,ω)Li​(p,−ω)dtLo​(p+dω,ω)=Li​(p,−ω)e−∫0d​σa​(p+tω,ω)dt 11.1.2 Emission 这一过程代表了单位体积中发光的粒子对输出 radiance 的贡献，即： dLo(p,ω)=Le(p,ω)dtLo(p+dω,ω)=∫0dLe(p+tω,−ω)dt\\mathrm{d}L_o(p, \\omega) = L_e(p, \\omega)\\mathrm{d}t\\\\ L_o(p+d\\omega, \\omega) = \\int_0^d L_e(p+t\\omega,-\\omega)\\mathrm{d}tdLo​(p,ω)=Le​(p,ω)dtLo​(p+dω,ω)=∫0d​Le​(p+tω,−ω)dt 11.1.3 Out-Scattering and Attenuation 向外的散射表示单位体积中光线击中粒子后向其他方向散射的能量比例。 dLo(p,ω)=−σs(p,ω)Li(p,−ω)dtLo(p+dω,ω)=Li(p,−ω)e−∫0dσs(p+tω,ω)dt\\mathrm{d}L_o(p, \\omega) = -\\sigma_s(p, \\omega)L_i(p, -\\omega)\\mathrm{d}t\\\\ L_o(p+d\\omega, \\omega) = L_i(p, -\\omega)e^{-\\int_0^d\\sigma_s(p+t\\omega, \\omega)\\mathrm{d}t}dLo​(p,ω)=−σs​(p,ω)Li​(p,−ω)dtLo​(p+dω,ω)=Li​(p,−ω)e−∫0d​σs​(p+tω,ω)dt 在对出射 radiance 的贡献上，他实际上和吸收系数是相同的，也因此会将他和吸收系数合成一个系数表示光线在单位体积内传输的衰减率： σt=σa+σsTr(p→p′)=e−∫0dσt(p+tω,ω)dt\\sigma_t = \\sigma_a + \\sigma_s\\\\ T_r(p \\to p&#x27;) = e^{-\\int_0^d\\sigma_t(p+t\\omega,\\omega)\\mathrm{d}t}σt​=σa​+σs​Tr​(p→p′)=e−∫0d​σt​(p+tω,ω)dt 利用 σt\\sigma_tσt​ 我们还可以定义很多其它有用的物理量，包括了： 体积的散射率 albedo ρ=σs/σt\\rho = {\\sigma_s / \\sigma_t}ρ=σs​/σt​ ，它表示了散射占所有衰减的比例 平均自由路径长度（mean free path）1/σt1 / \\sigma_t1/σt​ ，它表示了光线在体积中与粒子的两次交互之间（或从入射到与粒子交互之间）的平均距离 光学厚度 τ=∫0dσt(p+tω,ω)dt\\tau = \\int_0^d\\sigma_t(p+t\\omega,\\omega)\\mathrm{d}tτ=∫0d​σt​(p+tω,ω)dt 11.1.4 In-scattering 与外散射相对的内散射表示了单位体积中从其它方向经由散射进入光线出射方向的能量比例。为了描述散射的过程，我们一般会使用一个 phase function 来表示空间某点处从一个给定方向上入射的能量在各个方向上的散射的能量分布，它遵从能量守恒定律： ∫s2p(p,ω,ω′)dω′=1\\int_{s^2}p(p, \\omega,\\omega&#x27;)\\mathrm{d}\\omega&#x27; = 1 ∫s2​p(p,ω,ω′)dω′=1 内散和发光结合在一起组成了体积散射中的 source 项： Ls(p,ω)=Le(p,ω)+σs(p,ω)∫s2p(p,ωi,ω)Li(p,ωi)dωiL_s(p, \\omega) = L_e(p,\\omega) + \\sigma_s(p,\\omega)\\int_{s^2}p(p,\\omega_i, \\omega)L_i(p, \\omega_i)\\mathrm{d}\\omega_i Ls​(p,ω)=Le​(p,ω)+σs​(p,ω)∫s2​p(p,ωi​,ω)Li​(p,ωi​)dωi​ 这一项和表面散射函数非常类似，唯一的区别在于它并不需要一个 cos⁡\\coscos 项，因为这里操作的量纲均为 radiance 。 11.2 Phase Functions 体积散射中的 Phase Functions 就相当于表面散射中的 BSDF 。PhaseFunction 定义了这样的一个抽象接口。 123456class PhaseFunction &#123;public: virtual Float p(const Vector3f &amp;wo, const Vector3f &amp;wi) const = 0; virtual Float Sample_p(const Vector3f &amp;wo, Vector3f *wi, const Point2f &amp;u) const = 0;&#125;; 在大部分的介质中，phase function 均可以简化为一个一维函数 p(cos⁡θ)p(\\cos\\theta)p(cosθ) ，其中 θ\\thetaθ 表示的入射和出射方向的夹角。这样的 phase function 计算简单且具有可逆性，交换入射和出射方向不会改变函数值。具有这种特性的介质称为各项同性的介质。 在 PBRT 中最常用的一种 phase function 是 HG phase function。它因为是由 Henyey 和 Greenstein 设计而得名，其方程为： pHG(cos⁡θ)=14π1−g2(1+g2+2gcos⁡θ)3/2p_{HG}(\\cos\\theta) = {1\\over4\\pi}{1 - g^2 \\over (1 + g^2 + 2g\\cos\\theta)^{3/2}} pHG​(cosθ)=4π1​(1+g2+2gcosθ)3/21−g2​ 其中的 g 项是一个在 (−1,1)(-1, 1)(−1,1) 范围内的可调整的参数。负数的 g 值表示了光线总会向来源方向散射（如下图蓝线），而正的 g 值则表示了光线会更多地向光线前进方向散射（如下图黄线）。下图展示了两种 g 值在沿横轴正向入射的光线的散射能量分布剖面图： g 值的取值实际上源自于 phase function 在入射方向上的投影均值： g=∫S2p(−ω,ω′)(ω⋅ω′)dω′=2π∫0πp(−cos⁡θ)cos⁡θsin⁡θdθ.g=\\int_{\\mathrm{S}^{2}} p\\left(-\\omega, \\omega^{\\prime}\\right)\\left(\\omega \\cdot \\omega^{\\prime}\\right) \\mathrm{d} \\omega^{\\prime}=2 \\pi \\int_{0}^{\\pi} p(-\\cos \\theta) \\cos \\theta \\sin \\theta \\mathrm{d} \\theta . g=∫S2​p(−ω,ω′)(ω⋅ω′)dω′=2π∫0π​p(−cosθ)cosθsinθdθ. 当然，这种 phase function 并不能描述各种类型的介质。因此在 PBRT 中常常使用一系列参数不同的 phase fuction 加权组合为一个新的 phase function 以表示复杂的介质： p(ω,ω′)=∑i=1nwipi(ω→ω′)p(\\omega,\\omega&#x27;) = \\sum_{i=1}^nw_ip_i(\\omega \\to \\omega&#x27;) p(ω,ω′)=i=1∑n​wi​pi​(ω→ω′) 11.3 Media 123456789class Medium &#123;public: // Medium Interface virtual ~Medium() &#123;&#125; virtual Spectrum Tr(const Ray &amp;ray, Sampler &amp;sampler) const = 0; virtual Spectrum Sample(const Ray &amp;ray, Sampler &amp;sampler, MemoryArena &amp;arena, MediumInteraction *mi) const = 0;&#125;; Medium 基类提供了体积散射在空间区域中的表示方法。其中最重要的函数之一是计算透射率的 Tr 。它接收一根光线作为输入，计算该光线从原点到 tMax 位置的透射率（我们一般会假设这条光线没有受到任何遮挡，并且全段均在介质中）。 在 PBRT 中，两种不同散射介质之间的分界均会由一个 GeometricPrimitive 的表面表示，因此每个几何体中均会储存一个 MediumInterface 储存表面两侧的介质。 12345678struct MediumInterface &#123; MediumInterface(const Medium *medium) : inside(medium), outside(medium) &#123; &#125; MediumInterface(const Medium *inside, const Medium *outside) : inside(inside), outside(outside) &#123; &#125; bool IsMediumTransition() const &#123; return inside != outside; &#125; const Medium *inside, *outside;&#125;; 对大部分场景而言，通常并不需要对场景中的每个物体均设置其两侧的介质。为了降低复杂度，只有在摄像机、光源，以及透明且两侧介质不同的物体才会被设置介质值。GeometricPrimitive::Intersect() 方法会在光线和几何体相交时根据需求设置 SurfaceInteraction::mediumInterface 。 另外，为了不在透明的介质边界处（比如使用 box 表示的云）产生额外的 BSDF 计算负担，PBRT 允许一个表面拥有值为 nullptr 的 Material 和 bsdf 指针 根据以上内容设计的新相交方法 Scene::IntersectTr 会忽略空白的边界，并在第一个具有材质处汇报相交、返回 si 和对应的透射率 TrT_rTr​ 。 11.3.1 Medium Interactions MediumInteraction 类包装了一个 Interaction 类和一个指向 PhaseFunction 的指针。和 SurfaceInteraction 对应的，这个类表示了介质内一点处发生的散射作用。 123456789101112class MediumInteraction : public Interaction &#123;public: // MediumInteraction Public Methods MediumInteraction() : phase(nullptr) &#123;&#125; MediumInteraction(const Point3f &amp;p, const Vector3f &amp;wo, Float time, const Medium *medium, const PhaseFunction *phase) : Interaction(p, wo, time, medium), phase(phase) &#123;&#125; bool IsValid() const &#123; return phase != nullptr; &#125; // MediumInteraction Public Data const PhaseFunction *phase;&#125;; 11.3.2 Homogeneous Medium HomogeneousMedium 是最简单的介质，它表示了空间中一处拥有恒定的散射和吸收系数的介质，并使用 HG phase function 处理散射现象。 1234567891011class HomogeneousMedium : public Medium &#123;public: HomogeneousMedium(const Spectrum &amp;sigma_a, const Spectrum &amp;sigma_s, Float g) : sigma_a(sigma_a), sigma_s(sigma_s), sigma_t(sigma_s + sigma_a), g(g) &#123;&#125; Spectrum Tr(const Ray &amp;ray, Sampler &amp;sampler) const; Spectrum Sample(const Ray &amp;ray, Sampler &amp;sampler, MemoryArena &amp;arena, MediumInteraction *mi) const;private: const Spectrum sigma_a, sigma_s, sigma_t; const Float g;&#125;; 由于其内部的投射系数 σt\\sigma_tσt​ 是一个常值，对于其透射率的求值就变得异常简单了。我们只需要简单地利用光学密度 τ=σt×d\\tau=\\sigma_t \\times dτ=σt​×d 即可得到投射后剩余的能量。 11.3.3 3D Grids 除此之外，我们还可以使用一个 3D 的浮点数表来储存来自 3D 扫描、物理模拟等方式得到的数据。表格的每一项代表了一个体素位置上的介质的浓度（光学密度）。PBRT 中的 GridDensityMedium 实现了这一表示方法。它的构造函数输入作为基准值的 σs,σa\\sigma_s, \\sigma_aσs​,σa​ 、从世界坐标到单位网格 NDC 坐标的变换矩阵以及一个浮点数密度网格。每个体素位置的 σs,σa\\sigma_s, \\sigma_aσs​,σa​ 即可以通过使用基准值乘以该位置处由三线性插值获得的密度值得到。 11.4 The BSSRDF 在之前引入的 BSSRDF 可以表示从物体的任意入射位置和方向入射的射线，从另一个任意位置以任意方向出射的 radiance 变化比例。 Lo(p,ωo)=∫AdA∫H2(n)f(pi,po,ωo,ωi)Li(pi,ωi)∣cos⁡θi∣dωiL_o(p, \\omega_o) = \\int_A{\\rm dA}\\int_{H^2(n)}f(p_i,p_o,\\omega_o,\\omega_i)L_i(p_i,\\omega_i)|\\cos\\theta_i|{\\rm d}\\omega_i Lo​(p,ωo​)=∫A​dA∫H2(n)​f(pi​,po​,ωo​,ωi​)Li​(pi​,ωi​)∣cosθi​∣dωi​ 这一方程的求解与特性将使用 BSSRDF 类型表示： 123456789101112class BSSRDF &#123;public: BSSRDF(const SurfaceInteraction &amp;po, Float eta) : po(po), eta(eta) &#123;&#125; virtual ~BSSRDF() &#123;&#125; virtual Spectrum S(const SurfaceInteraction &amp;pi, const Vector3f &amp;wi) = 0; virtual Spectrum Sample_S(const Scene &amp;scene, Float u1, const Point2f &amp;u2, MemoryArena &amp;arena, SurfaceInteraction *si, Float *pdf) const = 0;protected: const SurfaceInteraction &amp;po; Float eta;&#125;; 它储存了一个出射位置和方向的 SurfaceInteraction po ，并根据入射光线的位置 pi 和入射角度 wi 计算这一情况下的 BSSRDF 函数值。和 BSDF 一样，它也提供了采样 - 求值函数以应对极端情况。 11.4.1 Separable BSSRDFs BSSRDF 的最大问题在于，出于它的一般性，它所需要存储数据的维度实在是太高了。即使在一个简单的平面上寻找 BSSRDF 就已经是十分困难的过程了，而 BSSRDF 需要能应用于任意复杂的模型之上。为了简化支持更一般的模型的能力，PBRT 中引入了 SeparableBSSRDF。这个接口将 BSSRDF 分为了三个互相独立的部分的乘积： S(po,ωo,pi,ωi)≈(1−Fr(cos⁡θo))Sp(po,pi)Sω(ωi)S(p_o,\\omega_o,p_i,\\omega_i) \\approx (1 - F_r(\\cos\\theta_o))S_p(p_o,p_i)S_{\\omega}(\\omega_i) S(po​,ωo​,pi​,ωi​)≈(1−Fr​(cosθo​))Sp​(po​,pi​)Sω​(ωi​) 这三个部分的含义如下： 第一项使用出射位置的菲涅尔项表示从出射点通过折射透过出射点的能量比例 第二项将两点的空间差异带来的影响单独建模提出为一项 第三项表示了从入射位置进入介质的能量比例，其中内含了另一个菲涅尔项 对于高 albedo 的介质，它们往往表现出更强的各向同性，此时菲涅尔传输项对最终的方向相关的结果影响更大，因此这一近似方法较为准确。而对于低 albedo 的介质则可能出现偏差。 该式的第三项在实际使用中往往会使用一个在半球面上归一化后的菲涅尔项： 1=∫H2Sω(ω)cos⁡θdω=∫H21−Fr(η,cos⁡θ)cπcos⁡θdω1 = \\int_{H^2}S_{\\omega}(\\omega)\\cos\\theta\\mathrm{d}\\omega = \\int_{H^2}{1 - F_r(\\eta, \\cos\\theta) \\over c\\pi}\\cos\\theta\\mathrm{d}\\omega1=∫H2​Sω​(ω)cosθdω=∫H2​cπ1−Fr​(η,cosθ)​cosθdω 将立体角积分展开有： c=∫02πdϕ∫0π/21−Fr(η,cos⁡θ)πsin⁡θcos⁡θdθ=1−2∫0π/2Fr(η,cos⁡θ)sin⁡θcos⁡θdθ\\begin{aligned} c &amp; = \\int_0^{2\\pi}\\mathrm{d}\\phi\\int_0^{\\pi/2}{1 - F_r(\\eta, \\cos\\theta) \\over \\pi}\\sin\\theta\\cos\\theta\\mathrm{d}\\theta\\\\ &amp; = 1 - 2\\int_0^{\\pi/2}F_r(\\eta, \\cos\\theta)\\sin\\theta\\cos\\theta\\mathrm{d}\\theta \\end{aligned}c​=∫02π​dϕ∫0π/2​π1−Fr​(η,cosθ)​sinθcosθdθ=1−2∫0π/2​Fr​(η,cosθ)sinθcosθdθ​ 其中后一项的积分被称为菲涅尔反射函数的一阶动量（first moment），其广义上的定义如下： Fˉr,i(η)=∫0π/2Fr(η,cos⁡θ)sin⁡θcos⁡iθdθ\\bar{F}_{r, i}(\\eta) = \\int_0^{\\pi/2}F_r(\\eta, \\cos\\theta)\\sin\\theta\\cos^i\\theta\\mathrm{d}\\theta Fˉr,i​(η)=∫0π/2​Fr​(η,cosθ)sinθcosiθdθ 而代表空间差异带来的传输衰减的中间项而言，我们通常会使用更加简单的、仅与两点的几何距离有关的一维函数代替： Sp(po,pi)≈Sr(∣∣po−pi∣∣)S_p(p_o, p_i) \\approx S_r(||p_o - p_i||) Sp​(po​,pi​)≈Sr​(∣∣po​−pi​∣∣) 这一近似需要要求整个介质都是相对均匀且表面较为平缓——任何的重大变化的距离均需要大于平均自由距离。 11.4.2 Tabulated BSSRDF 和 BSDF 一样，BSSRDF 也可以通过一个简单的表格表示出来。这也是 SeperableBSSRDF 接口的唯一实现。和 FourierBSDF 相似的，这一类型使用适应性的基于样条线的插值算法对距离相关的 SrS_rSr​ 项进行插值，并将插值参数与其它四个角度一并作为表格储存。 虽然上述的说明中 SrS_rSr​ 只是一个一维的函数，但实际上它会受到多个值的影响，完整的映射关系可以写成 Sr(η,g,ρ,σt,r)S_r(\\eta,g,\\rho,\\sigma_t,r)Sr​(η,g,ρ,σt​,r) 。为了降维，我们需要固定或合并其中的部分变量。 我们首先固定折射率参数 η\\etaη 和散射各向异性参数 ggg ，这两个参数一般不会随着介质空间变化。其次，注意到这个公式中有物理量纲的值只有两个：σt,r\\sigma_t, rσt​,r ，我们会将第一个透射率设为恒值 1 并将距离参数 rrr 转换为无量纲的光学距离 ropticalr_{optical}roptical​ 。经此改变，整个 SrS_rSr​ 函数就变成了仅与 albedo 和光学距离有关的二维函数了（需要注意转换单位时带来的额外系数项）。BSSRDFTable 储存了这样的一个表。 Sr(η,g,ρ,σt,r)=σt2Sr(η,g,ρ,1,roptical)S_r(\\eta,g,\\rho,\\sigma_t,r) = \\sigma_t^2 S_r(\\eta,g,\\rho,1,r_{optical}) Sr​(η,g,ρ,σt​,r)=σt2​Sr​(η,g,ρ,1,roptical​) 1234567891011121314struct BSSRDFTable &#123; // BSSRDFTable Public Data const int nRhoSamples, nRadiusSamples; std::unique_ptr&lt;Float[]&gt; rhoSamples, radiusSamples; std::unique_ptr&lt;Float[]&gt; profile; std::unique_ptr&lt;Float[]&gt; rhoEff; std::unique_ptr&lt;Float[]&gt; profileCDF; // BSSRDFTable Public Methods BSSRDFTable(int nRhoSamples, int nRadiusSamples); inline Float EvalProfile(int rhoIndex, int radiusIndex) const &#123; return profile[rhoIndex * nRadiusSamples + radiusIndex]; &#125;&#125;; 表格将一系列（大概率也是不均匀的）采样位置储存在 rhoSamples, radiusSamples 中，而采样值则储存在 profile 中。 从 BSSRDFTable 中获取 SrS_rSr​ 值的方式和 BSDFTable 大同小异，大致流程如下： 对于每一个通道，首先将距离使用 σt\\sigma_tσt​ 转换为光学距离 计算四个采样点的 Catmull Rom 权重 加权平均各个采样点以得到最终结果，并乘以缩放系数 在输出前 Clamp 掉插值中可能产生的负值错误 注意到 TabulatedBSSRDF::rho 实际储存的是单次散射后能量的衰减比例，这个值和表面材质的 albedo 还有一定的区别：表面的 albedo 会将多次散射也计入考量。后者被记为 effective albedo ρeff\\rho_\\mathrm{eff}ρeff​。由于这一值会在其它计算中频繁使用，它被预计算并储存于 BSSRDFTable::rhoEff 中。 ρeff=∫02πdϕ∫0∞rSr(r)dr=2π∫0∞rSr(r)dr\\rho_\\mathrm{eff} = \\int_0^{2\\pi}\\mathrm{d}\\phi\\int_0^{\\infty}rS_r(r)\\mathrm{d}r = 2\\pi\\int_0^{\\infty}rS_r(r)\\mathrm{d}r ρeff​=∫02π​dϕ∫0∞​rSr​(r)dr=2π∫0∞​rSr​(r)dr 这一值的具体计算过程将在 15 章中讨论，目前我们只需要知道它是一个关于 albedo 的严格单调递增函数即可。 11.4.3 Subsurface Scattering Materials 对于这些半透明的物体，PBRT 中有两种材质可以描述它们，分别是 SubsurfaceMaterial, KdSubsurfaceMaterial 它们的区别仅在于它们指定散射参数的方式有所不同。 SubsurfaceMaterial 将散射的参数作为纹理储存，使得表面的各个位置的参数值可能变化（这其实是一种对内部参数值变化的一种近似）。需要注意的是：这种变化会导致 BSSRDF 的可逆性被摧毁，因为材质总是在其中一个点上被采样，而交换出射入射点则会改变采样的位置，从而引起参数的改变。 SubsurfaceMaterial 会在出射点位置采样 σt,σs\\sigma_t, \\sigma_sσt​,σs​ ，进而使用这些信息初始化 TabulatedBSSRDF 。但这两个值的设置并不是艺术家友好的。它们对材质最后的表现的影响是非线性且非直觉的。为了解决这一问题，KdSubsurfaceMaterial 使用平均自由距离和漫反射率定义次表面散射的性质，通过 SubsurfaceFromDiffuse() 工具函数转换为标准的 BSSRDF 以供使用。这一部分将在 15 章中进一步讨论。","categories":[{"name":"programming","slug":"programming","permalink":"https://blog.apassbydreg.work/categories/programming/"},{"name":"reading notes","slug":"programming/reading-notes","permalink":"https://blog.apassbydreg.work/categories/programming/reading-notes/"}],"tags":[{"name":"CG","slug":"CG","permalink":"https://blog.apassbydreg.work/tags/CG/"},{"name":"render","slug":"render","permalink":"https://blog.apassbydreg.work/tags/render/"},{"name":"PBRT","slug":"PBRT","permalink":"https://blog.apassbydreg.work/tags/PBRT/"}]},{"title":"PBRT 第十章笔记 | Notes for PBRT Chapter 10 - Textures","slug":"PBRT-ch10","date":"2021-11-29T02:22:04.000Z","updated":"2022-02-15T09:41:41.310Z","comments":true,"path":"2021/11/PBRT-ch10/","link":"","permalink":"https://blog.apassbydreg.work/2021/11/PBRT-ch10/","excerpt":"","text":"10.1 Sampling and Antialiasing 从第七章引入了走样的概念以来，这种现象就是在现有的基于采样的方式中不可解决的。我们能做的只能使用一系列方法降低走样对视觉的影响。 值得庆幸的是，在材质这一方面上，我们可以在采样之前就提前去除材质中的高频信息，或是在采样过程中使用特殊方法避免引入高频信息，从而减小采样时的走样现象。对于应用于材质上的反走样方法，主要的研究问题有以下两点： 确认材质的采样率：给定场景的采样率，我们需要确定在某一物体上的材质对应的采样率 确定采样方法：在确定了材质的采样率后，需要寻求指导采样进行的算法以去除高于采样率的信息。 10.1.1 材质采样率的确定 考虑一个定义在某个表面上的一个材质函数 T(x)T(x)T(x) ，当我们忽略由于可见性导致的突变以外，这个材质函数其实也可以视作定义在图像平面上的另一个函数 T(f(x,y))T(f(x,y))T(f(x,y)) 。这种从像素位置和材质位置的映射，结合二者采样率的差异，是求解材质在屏幕空间上对应的最高采样率的核心。 对于大多数的场景几何情况、投影方法和材质映射，我们通常很难找到这一映射的解析解。但对于反走样算法而言，我们只需要找到像素采样位置的变化对材质采样位置的影响即可。我们通常使用一阶偏导数近似这一结果： f(x′,y′)≈f(x,y)+(x′−x)∂f∂x+(y′−y)∂f∂yf(x&#x27;,y&#x27;) \\approx f(x,y) + (x&#x27;-x){\\partial f \\over \\partial x} + (y&#x27;-y){\\partial f \\over \\partial y} f(x′,y′)≈f(x,y)+(x′−x)∂x∂f​+(y′−y)∂y∂f​ 这里使用的偏导数可以从 RayDifferential 中得到。我们会使用从图像坐标到世界坐标的函数 p(x,y)p(x,y)p(x,y) 的偏导数和从图像坐标到材质 uv 的函数 u(x,y),v(x,y)u(x,y), v(x,y)u(x,y),v(x,y) 的偏导数解决这一问题。在生成 SurfaceInteraction 时计算偏导数的具体方法如下： 首先，我们假定微分光线与表面的交点均在一个由法线和光线交点确定的平面上，利用微分光线与平面的交点位置和光线交点位置的差异可以估算一阶偏导数： ∂p∂x≈px−p, ∂p∂y≈py−p{\\partial p \\over \\partial x} \\approx p_x - p,\\ {\\partial p \\over \\partial y} \\approx p_y - p ∂x∂p​≈px​−p, ∂y∂p​≈py​−p 其次，利用该平面上 uv 的分布情况（可以直接在材质中得到），我们可以假定对于微分情况下，有近似： p′=p+Δu∂p∂u+Δv∂p∂v(px′−pxpy′−pypz′−pz)=(∂px/∂u∂px/∂v∂py/∂u∂py/∂v∂pz/∂u∂pz/∂v)×(ΔuΔv)p&#x27; = p + \\Delta_u{\\partial p \\over \\partial u} + \\Delta_v{\\partial p \\over \\partial v}\\\\ \\left(\\begin{matrix} p&#x27;_x-p_x\\\\ p&#x27;_y-p_y\\\\ p&#x27;_z-p_z \\end{matrix}\\right) = \\left(\\begin{matrix} {\\partial p_x / \\partial u} &amp; {\\partial p_x / \\partial v}\\\\ {\\partial p_y / \\partial u} &amp; {\\partial p_y / \\partial v}\\\\ {\\partial p_z / \\partial u} &amp; {\\partial p_z / \\partial v} \\end{matrix}\\right) \\times \\left(\\begin{matrix} \\Delta_u\\\\ \\Delta_v \\end{matrix}\\right)p′=p+Δu​∂u∂p​+Δv​∂v∂p​⎝⎛​px′​−px​py′​−py​pz′​−pz​​⎠⎞​=⎝⎛​∂px​/∂u∂py​/∂u∂pz​/∂u​∂px​/∂v∂py​/∂v∂pz​/∂v​⎠⎞​×(Δu​Δv​​) 此时令 p′=px,p′=pyp&#x27; = p_x, p&#x27; = p_yp′=px​,p′=py​ 带入就可以得到对应的 ∂u/∂x,∂u/∂y,∂v/∂x,∂v/∂y{\\partial u/\\partial x},{\\partial u/\\partial y},{\\partial v/\\partial x},{\\partial v/\\partial y}∂u/∂x,∂u/∂y,∂v/∂x,∂v/∂y 这里每组是两个浮点数，而输入的 ∂p/∂x,∂p/∂y{\\partial p/\\partial x},{\\partial p/\\partial y}∂p/∂x,∂p/∂y 则分别有三个自由度，因此这是一个使用三个方程求解两个未知量的方程，这说明这其中至少有一个方程是多余的。为了选定用于求解的方程组，一种求解方法是做 ∂p/∂u,∂p/∂v{\\partial p/\\partial u},{\\partial p/\\partial v}∂p/∂u,∂p/∂v 的叉乘，选择叉乘值中较小的两个维度输入线性方程组，而在 SurfaceInteraction 中，这个叉乘的值恰好就是法线 nnn 。 即便如此，在 ∂p/∂u,∂p/∂v{\\partial p/\\partial u},{\\partial p/\\partial v}∂p/∂u,∂p/∂v 共线时，也是无法求解线性方程的，此时 PBRT 会将对应的导数值设为零。 10.1.2 对材质进行滤波 为了去除超过了采样的纳什限制的频率，需要先对原始的材质进行 sincsincsinc 滤波： Tb′(x,y)=∫−∞∞∫−∞∞sinc⁡(x′)sinc⁡(y′)T′(f(x−x′,y−y′))dx′dy′T_{b}^{\\prime}(x, y)=\\int_{-\\infty}^{\\infty} \\int_{-\\infty}^{\\infty} \\operatorname{sinc}\\left(x^{\\prime}\\right) \\operatorname{sinc}\\left(y^{\\prime}\\right) T^{\\prime}\\left(f\\left(x-x^{\\prime}, y-y^{\\prime}\\right)\\right) \\mathrm{d} x^{\\prime} \\mathrm{d} y^{\\prime} Tb′​(x,y)=∫−∞∞​∫−∞∞​sinc(x′)sinc(y′)T′(f(x−x′,y−y′))dx′dy′ 接着对这个滤波后的函数在像素的范围内对一个权重函数（pixel filter）做卷积： Tf′(x,y)=∫−yWidthyWidth∫−xWidthxWidthg(x′,y′)Tb′(x−x′,y−y′)dx′dy′T_{f}^{\\prime}(x, y)=\\int_{-yWidth}^{yWidth} \\int_{-xWidth}^{xWidth} g\\left(x^{\\prime},y^{\\prime}\\right) T_{b}^{\\prime}\\left(x-x^{\\prime}, y-y^{\\prime}\\right) \\mathrm{d} x^{\\prime} \\mathrm{d} y^{\\prime} Tf′​(x,y)=∫−yWidthyWidth​∫−xWidthxWidth​g(x′,y′)Tb′​(x−x′,y−y′)dx′dy′ 在实际使用中，常常对这一过程进行一系列的简化，如在两步中均使用最简单的 box filter 计算算术均值。因为在采样后所有样本还需要经过图像重建的过程，就算使用一种简单的滤波方式得到的次优解也能提供优秀的视觉效果。 如果我们能够提前得知组成材质的各个频率组成部分，就可以通过 clamping 的方法，通过将更高频的部分替换为其均值以完成滤波。这一方法被广泛应用于程序生成的材质的反走样中。 最终还有一种最通用的方式完成对材质的反走样处理：超采样。这和图像空间上的超采样是大同小异的。这种方法仍被使用的原因在于，即使它相比于其它材质上的滤波方法而言消耗巨大，但与在图像空间上面进行超采样而言它的效率仍然是较高的。 10.1.3 镜面反射和折射情况下的光线微分 ⚠️ 由于光线微分在对材质滤波的过程中十分有效，我们很自然地会希望将它拓展到镜面反射和折射后的光线上。 这一过程首先开始于使用 ∂p/∂x, ∂p/∂y\\partial p / \\partial x,\\ \\partial p / \\partial y∂p/∂x, ∂p/∂y 估计微分光线的交点（也是出射微分光线的起始点），与计算这一值时采用的同平面假设不同，在计算镜面反射和折射的微分光线时考虑了法线在这一方向上的变化。 考虑镜面反射的光线方向方程： ωi+ωo=2(ωo⋅n)n\\omega_i + \\omega_o = 2(\\omega_o \\cdot \\mathbf{n})\\mathbf{n} ωi​+ωo​=2(ωo​⋅n)n 对 ωi\\omega_iωi​ 求偏导可以得到： ∂ωi∂x=∂∂x(−ωo+2(ωo⋅n)n)=−∂ωo∂x+2((ωo⋅n)∂n∂x+∂(ωo⋅n)∂xn)\\begin{aligned}\\frac{\\partial \\omega_{\\mathrm{i}}}{\\partial x} &amp;=\\frac{\\partial}{\\partial x}\\left(-\\omega_{\\mathrm{o}}+2\\left(\\omega_{\\mathrm{o}} \\cdot \\mathbf{n}\\right) \\mathbf{n}\\right) \\\\&amp;=-\\frac{\\partial \\omega_{\\mathrm{o}}}{\\partial x}+2\\left(\\left(\\omega_{\\mathrm{o}} \\cdot \\mathbf{n}\\right) \\frac{\\partial \\mathbf{n}}{\\partial x}+\\frac{\\partial\\left(\\omega_{\\mathrm{o}} \\cdot \\mathbf{n}\\right)}{\\partial x} \\mathbf{n}\\right)\\end{aligned} ∂x∂ωi​​​=∂x∂​(−ωo​+2(ωo​⋅n)n)=−∂x∂ωo​​+2((ωo​⋅n)∂x∂n​+∂x∂(ωo​⋅n)​n)​ 其中点乘的微分可以进一步分解如下： ∂(ω0⋅n)∂x=∂ω0∂x⋅n+ω0⋅∂n∂x\\frac{\\partial\\left(\\omega_{0} \\cdot \\mathbf{n}\\right)}{\\partial x}=\\frac{\\partial \\omega_{0}}{\\partial x} \\cdot \\mathbf{n}+\\omega_{0} \\cdot \\frac{\\partial \\mathbf{n}}{\\partial x} ∂x∂(ω0​⋅n)​=∂x∂ω0​​⋅n+ω0​⋅∂x∂n​ 考虑到对于一个微分光线的入射方向 ω\\omegaω （即从视点出发被反射的出射方向），就能很容易的得到新光线的微分情况： ω≈wi+∂ωi∂x=ωi−∂ωo∂x+2((ωo⋅n)∂n∂x+(∂ω0∂x⋅n+ω0⋅∂n∂x)n)\\begin{aligned} \\omega &amp; \\approx w_i + {\\partial\\omega_i \\over \\partial x}\\\\ &amp; = \\omega_i - \\frac{\\partial \\omega_{\\mathrm{o}}}{\\partial x} + 2\\left(\\left(\\omega_{\\mathrm{o}} \\cdot \\mathbf{n}\\right) \\frac{\\partial \\mathbf{n}}{\\partial x}+\\left(\\frac{\\partial \\omega_{0}}{\\partial x} \\cdot \\mathbf{n}+\\omega_{0} \\cdot \\frac{\\partial \\mathbf{n}}{\\partial x}\\right) \\mathbf{n}\\right) \\end{aligned}ω​≈wi​+∂x∂ωi​​=ωi​−∂x∂ωo​​+2((ωo​⋅n)∂x∂n​+(∂x∂ω0​​⋅n+ω0​⋅∂x∂n​)n)​ 对于镜面折射的情况只需要改变对应的光线方程即可得到类似的新微分光线。 10.2 Texture Coordinate Generation Texture 类型储存了一个指向了二维或三位的映射函数以在各个点上计算材质坐标。在 PBRT 中，材质坐标被使用 s,ts,ts,t 表示，以区分于属于表面属性的 uv 坐标。 最常用的 2D 材质映射基类 TextureMapping2D 中只含有一个接口函数 Point2f Map(const SurfaceInteraction &amp;si, Vector2f *dstdx, Vector2f *dstdy) 。它接收着色点的信息，并返回对应的材质坐标与偏导数信息。 10.2.1 二维 (u,v)(u,v)(u,v) 映射 最简单的映射方法即直接使用 SurfaceInteraction 中的 uv 信息作为材质的 st 坐标。UVMapping2D 类实现了一个简单的缩放和偏移映射，它在构建时传入各个方向上的缩放比例 su, sv 和偏移值 du, dv ，并以此计算偏导数和 st 坐标 10.2.2 球形映射 这种映射方法首先将物体从世界坐标变换到材质坐标系中，再投影到一个以原点为圆心的球面上以计算 st 值，球面的函数则简单地使用极坐标系下的 θ,ϕ\\theta, \\phiθ,ϕ 值完成存储。 然而这种映射方式的坐标系是不连续的，特别是在 t=1t = 1t=1 的位置上，这里的 ttt 值会在这条边界线上发生跳变，因此需要特别处理这种特殊情况。 10.2.3 圆柱映射 与球形映射不同的是这种方法会将物体投影到圆柱的侧面上，它也存在和球型映射相似的微分不连续问题。 10.2.4 平面映射 这种方法直接地使用一组向量作为基，将物体上的点投影在这一平面坐标系上，最后加上偏移值作为 st 坐标。 10.2.5 三维映射 除了 2D 的材质外，可能还会见到一些 3D 的体积材质，它使用了一个 WorldToTexture 变换将世界坐标转换为 3D 的材质内坐标。 10.3 Texture Interface and Basic Textures 材质接口是一个模板抽象类，它使用 T Evaluate(const SurfaceInteraction &amp;) 函数从给定的表面位置返回材质内容。 10.3.1 常数材质 这种材质无论在什么位置都返回一个预定义的常数 10.3.2 乘积材质 这个材质中包含了两类子材质，它们 Evaluate 的结果会被相乘，并返回与第二个材质类型匹配的值，相当于使用第一种材质作为第二种材质的缩放因数。 10.3.3 混合材质 这种材质使用一个浮点数材质（如噪声材质）混合两个同类的材质。 10.3.4 双线性插值材质 这是一类特殊的材质，它返回在四个角点上进行双线性插值的结果。 10.4 Image Texture ImageTexture 类保存了一个离散的二维图像，它使用这个图像在 st 坐标下重建可以在任意位置被采样的连续图像方程。 和其它材质类型不同的是，ImageTexture 类型需要两个模板参数，分别代表储存时的类型和输出的类型。例如它可以输入以 RGBSpectrum 储存的图像，并输出以 SampledSpectrum 储存的值。 在创建一个 ImageTexture 对象时，需要传入的信息包括了图像的文件名、颜色矫正和采样参数等。构造函数会使用这些参数初始化一个 MIPMap 对象以储存图像数据。这个对象也同时负责了重建图像和抗锯齿的功能。 10.4.1 ImageTexture 的内存管理 由于同一个材质可能会被多个物体引用多次，因此在储存时对于不同的材质只会分别储存一份，并通过静态接口 ImageTexture::GetTexture() 使用给定的材质描述块索引对应的 MIPMap 对象。 图像的读入通过 ReadImage() 接口完成，读入的 texel 会被 convertIn() 接口转换为储存类型，并完成 gamma 矫正等调整过程。 10.4.2 ImageTexture 的使用 此处基本上就是调用了数个接口： 12345678Treturn Evaluate(const SurfaceInteraction &amp;si) const &#123; Vector2f dstdx, dstdy; Point2f st = mapping-&gt;Map(si, &amp;dstdx, &amp;dstdy); Tmemory mem = mipmap-&gt;Lookup(st, dstdx, dstdy); Treturn ret; convertOut(mem, &amp;ret); return ret;&#125; 10.4.3 MIP Maps 图像上的材质已经被以固定的采样率采样完成了，当查找时的屏幕对应的频率小于图像频率时就会出现走样的问题。下图展示了一种可能的采样需求，它由采样点 (s,t)(s,t)(s,t) 和两个对于屏幕坐标的偏导数 dstdx, dstdy 组成： 和在图像上的反走样不同，材质上的反走样具有以下特点： 采样材质的开销远小于采样图像的开销 图像材质的最高频率是已知的 材质的采样率在图像的各个位置上变化很大，要求要对材质在不同位置以不同的采样率采样 PBRT 的 MIPMap 类型中实现了两种对材质的采样方式，分别是较快的三线性插值和质量较高的 Elliptically Weighted Averaging (EWA) 滤波法。这两种采样方式均使用了一种金字塔结构的图像层级加速结构，从全分辨率的底层开始，每一层的长宽都是上一层的一半。 为了便于生成图像的层级，如果用户输入的图像分辨率不是 2 的整数幂次方，PBRT 会使用两轮重采样方法，分别将它的长宽更改为比原始长宽大的第一个幂次方值（如 15×515\\times 515×5 的输入会被转换为 16×816 \\times 816×8 作为底层的分辨率），这是第七章中的一系列重采样方法的应用之一。对于金字塔结构的剩余层级的初始化则，则直接使用上一层对应的四个 texel 计算均值。 特别需要注意的是，PBRT 中处理连续域坐标和离散域坐标的方法是将离散坐标置于每个单位连续域区间的中心，即通过在离散值上加上 0.5 可以得到在连续区域上的位置，如图所示： 由于对于图像的采样是频繁且具有一定关联性的，这种金字塔结构使用了自定义的 BlockedArray 结构以增加 cache 命中率。 10.4.4 Isotropic Triangle Filter 这种最简单的滤波方法假设滤波的范围是一个正矩形区域（即 dstdx = dstdy ），如果输入的两个偏导数不同，则会使用较大的那个偏导数作为矩形的半边长。这种滤波方法的流程如下： 对于滤波区域的宽度 www 找到一个 mipmap 层级 lll ，使得采样范围可以覆盖 4 个采样点： 1w=2nTotalLevels−1−l{1 \\over w} = 2^{nTotalLevels - 1 - l} w1​=2nTotalLevels−1−l 对于上述解得的浮点数 lll 两侧的整数层级，分别使用双线性插值（即三角滤波）获得一个 texel 值 对于两个层级的 texel 值，用 lll 值再进行一次线性插值，最后返回插值的结果 这种滤波方式的最大问题在于它在滤波的滤波范围各向异性较为明显的位置（如球纹理映射的极点、倾斜视角的边缘附近）得到的结果会显得比较模糊。 10.4.5 Elliptically Weighted Average ⚠️ 这种算法使用一个椭圆拟合滤波的范围，椭圆的两个半长轴即为两个方向偏导数。与上述各向同性的滤波方法不同的是，这一方法使用较小的方向导数选择滤波 MIPMap 层级，但它也同样会在两个不同的层级之间做插值以增加精度。 在给定层级执行 EWA 滤波的主要方法是 MIPMap&lt;T&gt;::EWA() ，它的流程如下： 首先将 st 坐标系转换为对应层级中整数的 texel 坐标系上 计算椭圆在 texel 坐标系中的隐式方程 e(s,t)=As2+Bst+Ct2&lt;Fe(s,t) = As^2 + Bst + Ct^2 &lt; F e(s,t)=As2+Bst+Ct2&lt;F 找到这个椭圆在 texel 坐标系内的 AABB 遍历这个包围盒内的所有坐标，对于在椭圆内的 texel 使用高斯函数加权求平均，最后返回加权均值 10.5 Solid and Procedural Texturing 根据之前的定义，材质的坐标是由 (s,t)(s,t)(s,t) 这个二维的值所描述的，我们不难将其拓展到更高的维度上。 三维的材质也被称为 Solid Texture ，由于物体本身就定义在三维空间中，这种材质也是非常常见的。 三维的材质也带来了材质表示的问题：三维的表所需要的内存空间非常巨大，而且相比可以从图像中得到的二维材质而言更难获取。因此就引入了程序生成的材质的概念： 程序生成的材质相当于基于事先设定好的参数，利用材质坐标系上使用某种映射生成所需的图案。常见的映射包括了使用 uv 坐标、深度、法线等信息作为颜色，以及一些常见的几何形状如棋盘等。程序生成的材质通常有以下特点： 空间消耗极小，通常只需要储存不多的参数 可以拥有无穷的细节 时间消耗较大，也因此给反走样带来了困难 10.5.1 UV 材质 这是一种最简单的程序生成的材质，它可以通过简单地将 st 坐标分别作为 RG 通道的值，并将 B 通道设置为 0 实现。这种材质主要应用于 debugging 。 10.5.2 棋盘材质 这是一种等距间隔分布的棋盘状图形。为了方便实现，在 PBRT 中，这种材质里的每个矩形在 st 坐标下的边长均为 1 。PBRT 还另外提供了两个材质以填充棋盘图形的不同区域。 Chessboard 材质的反走样 在这一反走样策略中，采样区域被认为是采样点周围的一个与屏幕方向偏导有关的 AABB。这虽然增加了模糊程度，但在实现上更加友好，这种算法的实现过程非常简单： 如果 AABB 在同一材质内，直接采样当前材质即可 如果 AABB 跨越了不同材质，分别采样两种材质，并使用各个材质占 AABB 的面积比例作为权重加权平均 10.5.3 三维棋盘 这种材质将二维的棋盘材质拓展到了三维空间中 10.6 Noise 为了给材质增加更多的细节，可以引入一些可控、不均匀的微小变化，这就是噪声。噪声材质要求在材质坐标系内拥有连续可、计算且没有明显的重复性的函数。 噪声函数完成了这种从 Rn→[−1,1]R^n \\to [-1, 1]Rn→[−1,1] 的映射，它们往往拥有明确的频率区间，可以控制材质中的频率组分，因此便于滤波的进行。 一种最简单的噪声是 value noise 。它在三维空间中定义了一系列定位点，每个点储存了一个随机数值。在进行采样时，它会找到采样点周围的数个定位点，并使用任意插值方法（如三线性插值，或更复杂的多项式插值）混合它们的噪声值。 10.6.1 Perlin Noise Perlin noise 在任何整数点的位置上的值均为 0 ，并使用定义在各个整数点上的一个随机梯度决定噪声值。在 Perlin Nosie 上采样的步骤如下： 计算采样点周围的整数点坐标 计算梯度与指向采样点的向量的点乘，依次代表各个梯度对采样点的影响 将该权重进行平滑处理，这一操作使得结果具有了连续的一、二阶导数，插值前使用的平滑函数如下： wa=6(a−ai)5−15(a−ai)4+10(a−ai)3w_a = 6(a-a_i)^5 - 15(a-a_i)^4 + 10(a-a_i)^3 wa​=6(a−ai​)5−15(a−ai​)4+10(a−ai​)3 使用三线性插值混合这 8 个影响值 在实际实现中，PBRT 还为了提高速度加入了大量 trick ，包括使用预设定的随机数表 NoisePerm 多级索引噪声组成等方法。其中计算梯度贡献度的函数如下： 1234567inline Float Grad(int x, int y, int z, Float dx, Float dy, Float dz) &#123; int h = NoisePerm[NoisePerm[NoisePerm[x] + y] + z]; h &amp;= 15; Float u = h &lt; 8 || h == 12 || h == 13 ? dx : dy; Float v = h &lt; 4 || h == 12 || h == 13 ? dy : dz; return ((h &amp; 1) ? -u : u) + ((h &amp; 2) ? -v : v);&#125; 10.6.2 Random Polka Dots 这种材质将表面分为均等的子区域（类似棋盘），每个区域中均会有 50% 的概率出现一个半径为 0.35 的圆形。它的实现方式和棋盘材质其实大同小异，只不过在区分两类材质的覆盖位置时使用了增加了随机性的算法。 10.6.3 Noise Idioms and Spectral Synthesis 对于很多应用场景而言，将多种不同的噪声以某种权重组合起来是非常常见的做法。当我们直到某一噪声函数的频率组成部分时，当我们对输入乘以一个缩放常数之后，新的噪声的频率也能非常容易地得到。 fs(x)=∑iwif(six)f_s(x) = \\sum_i w_if(s_ix) fs​(x)=i∑​wi​f(si​x) Fractional Brownian Motion (FBM) 通常来说，缩放和权重均是按两倍的比例提升的，每增加一级噪声，其权重一般是上一级的一半，而频率是上一级的两倍。当这种策略应用于 Perlin Noise 上时，著名的分型杂色 fractional Brownian motion (fBm) 就诞生了。下图展示了层次数量为 3 和 6 情况下的一维分型杂色的图像。 由于分型噪声这种由多个频率依次递进的部分组成的性质，在抗锯齿的过程中，我们可以很容易地通过取最长的采样区间半径来确定实际上应该使用多少层噪声。完整的实现如下： 123456789101112131415161718192021Float FBm(const Point3f &amp;p, const Vector3f &amp;dpdx, const Vector3f &amp;dpdy, Float omega, int maxOctaves) &#123; // Compute number of octaves for antialiased FBm Float len2 = std::max(dpdx.LengthSquared(), dpdy.LengthSquared()); Float n = Clamp(-1 - .5f * Log2(len2), 0, maxOctaves); int nInt = std::floor(n); // Compute sum of octaves of noise for FBm Float sum = 0, lambda = 1, o = 1; for (int i = 0; i &lt; nInt; ++i) &#123; sum += o * Noise(lambda * p); lambda *= 1.99f; // 读者注：防止在整数点上的噪声值一直是零 o *= omega; &#125; // 读者注：加了一点点最后一级的内容，以便超过纳什频率的内容消失得比较自然 // 不过很奇怪这里加了之后难道不会超过 maxOctaves 吗... Float nPartial = n - nInt; sum += o * SmoothStep(.3f, .7f, nPartial) * Noise(lambda * p); // 读者注：这里好像也没有归一化，不过反正均值还是 0 就不管了？ return sum;&#125; Turbulence 和分型杂色相似的另一种噪声是 Turbulence() 噪声。它在加权的时候使用 Perlin Noise 的绝对值加权，在保证噪声值是正数的同时也引入了导数的不连续性。3 阶和 6 阶的一维 Turbulence() 噪声图像如下： 10.6.3 - 10.6.5 Noise 的应用 这里介绍了三种不同的噪声的应用场景，包括了： FBm 或 Turbulence 直接作为 Bump Mapping 的材质 使用两个 FBm 模拟风强和浪高的材质 这里比较奇怪的是，明明这个材质的 Evaluate 返回的是模板参数的类型，但实际上返回的是两个浮点数的乘积 使用 FBm 在采样前偏移材质坐标的材质","categories":[{"name":"programming","slug":"programming","permalink":"https://blog.apassbydreg.work/categories/programming/"},{"name":"reading notes","slug":"programming/reading-notes","permalink":"https://blog.apassbydreg.work/categories/programming/reading-notes/"}],"tags":[{"name":"CG","slug":"CG","permalink":"https://blog.apassbydreg.work/tags/CG/"},{"name":"render","slug":"render","permalink":"https://blog.apassbydreg.work/tags/render/"},{"name":"PBRT","slug":"PBRT","permalink":"https://blog.apassbydreg.work/tags/PBRT/"}]},{"title":"PBRT 第九章笔记 | Notes for PBRT Chapter 09 - Materials","slug":"PBRT-ch09","date":"2021-11-23T05:58:38.000Z","updated":"2021-11-23T06:03:24.456Z","comments":true,"path":"2021/11/PBRT-ch09/","link":"","permalink":"https://blog.apassbydreg.work/2021/11/PBRT-ch09/","excerpt":"","text":"9.1 BSDFs BSDF 类型统一了 BRDF 和 BTDF ，并提供了一个供其它系统使用的统一接口。为了生成一个这样的实例，你需要提供以下信息： 一个代表了几何体表面信息的 SurfaceInteraction si 一个代表了交界面位置反射率的差值的浮点数 eta 一个 BSDF 类型中会储存至多 8 个 BxDF 的指针（当然，你可以通过修改源码中的一个常量改变这一值）以表示不同的表面模型，在使用的时候，BSDF::f 函数会调用每一个 BxDF 对象，并返回它们的 BxDF::f 给出的值的和。由于 BxDF 在着色的时候使用的是局部坐标系，BSDF 中也需要提供一个在两个坐标系之间转换方法，即使用下面这个正交矩阵完成转换。 M=(sxsysztxtytznxnynz)=(stn)\\mathbf{M}=\\left(\\begin{array}{ccc}\\mathbf{s}_{x} &amp; \\mathbf{s}_{y} &amp; \\mathbf{s}_{z} \\\\\\mathbf{t}_{x} &amp; \\mathbf{t}_{y} &amp; \\mathbf{t}_{z} \\\\\\mathbf{n}_{x} &amp; \\mathbf{n}_{y} &amp; \\mathbf{n}_{z}\\end{array}\\right)=\\left(\\begin{array}{c}\\mathbf{s} \\\\\\mathbf{t} \\\\\\mathbf{n}\\end{array}\\right) M=⎝⎛​sx​tx​nx​​sy​ty​ny​​sz​tz​nz​​⎠⎞​=⎝⎛​stn​⎠⎞​ 在很多情况下，渲染的时候会使用与几何法线 ngn_gng​ 不同的表面法线 nsn_sns​ 来提高渲染质量，这些法线的值可能来自 bump map 、三角形插值等情况，但这也带来了一定的物理不正确。光线会因为不同法线方向带来的几何不一致问题发生漏光等问题。 9.1.1 BSDF 的内存管理 每当光线和场景中的几何体相交时，至少都会有一个 BSDF 对象被产生出来。而每个 BSDF 对象中又需要储存至少一个 BxDF 对象。如果每次都使用 new 和 delete 去动态地生成和管理这些对象的内存，整个系统会变得异常低效。PBRT 中会使用 MemoryArena 来管理这些小块的内存，其写法如下： 12BSDF *b = ARENA_ALLOC(arena, BSDF);BxDF *lam = ARENA_ALLOC(arena, LambertianReflection)(Spectrum(0.5f)); ARENA_ALLOC 宏使用了 C++ 中的 placement new 特性以在自定义的内存位置上构建对象。 1#define ARENA_ALLOC(arena, Type) new (arena.Alloc(sizeof(Type))) Type 为了避免在自定义的内存上删除由自定义方法申请的对象，BSDF 的析构函数被设置为 private ，这保证了任何对他的 delete 操作均会在编译期间报错。 9.2 Material Interface and Implementations 123456789101112131415// TransportMode Declarationsenum class TransportMode &#123; Radiance, Importance &#125;;// Material Declarationsclass Material &#123; public: // Material Interface virtual void ComputeScatteringFunctions(SurfaceInteraction *si, MemoryArena &amp;arena, TransportMode mode, bool allowMultipleLobes) const = 0; virtual ~Material(); static void Bump(const std::shared_ptr&lt;Texture&lt;Float&gt;&gt; &amp;d, SurfaceInteraction *si);&#125;; 抽象类 Material 定义了各种材质的接口，这里面最重要的接口函数是 ComputeScatteringFunctions() 。它负责了初始化 SurfaceInteraction::bsdf/bssrdf 成员以供评估光线的传播。其中部分参数的意义在于： TransportMode mode ：体现了这一条光线的来源是光源还是摄像机（会在 16.1 节中详细讨论） bool allowMultipleLobes ：在不同的 Integrator 中提供的值不同，将它设置为 true 允许了随机采样的方法得到更加优秀的结果，但会在不使用随机采样的积分器中引入噪声。 计算散射函数的过程开始于 SurfaceInteraction::ComputeScatteringFunctions ，它会首先计算光线的微分，再调用 GeometricPrimitive::ComputeScatteringFunctions() 寻找几何体对应的材质，最后对相应的材质调用 Material::ComputeScatteringFunctions() 。 9.2.1 Matte Material 这是一种最简单的材质，描述了一种存粹的漫反射表面，它需要使用三个材质： 表示颜色的 Kd 表示粗糙度的 sigma ：当粗糙度为零时材质会使用 Lambertian 表面模型，其他情况下则会使用 OrenNayar 表面模型 提供表面细节的 bumpMap ，这是一个可选项 它的 ComputeScatteringFunctions 方法将上述内容结合到一起： 123456789101112131415161718void MatteMaterial::ComputeScatteringFunctions(SurfaceInteraction *si, MemoryArena &amp;arena, TransportMode mode, bool allowMultipleLobes) const &#123; // Perform bump mapping with _bumpMap_, if present if (bumpMap) Bump(bumpMap, si); // Evaluate textures for _MatteMaterial_ material and allocate BRDF si-&gt;bsdf = ARENA_ALLOC(arena, BSDF)(*si); Spectrum r = Kd-&gt;Evaluate(*si).Clamp(); Float sig = Clamp(sigma-&gt;Evaluate(*si), 0, 90); if (!r.IsBlack()) &#123; if (sig == 0) si-&gt;bsdf-&gt;Add(ARENA_ALLOC(arena, LambertianReflection)(r)); else si-&gt;bsdf-&gt;Add(ARENA_ALLOC(arena, OrenNayar)(r, sig)); &#125;&#125; 9.2.2 Plastic Material 塑料材质可以被描述为 diffuse 和 glossy 散射函数的一种组合。它利用 Kd, Ks 描述漫反射的颜色和高光的颜色，并使用 roughness 描述表面的粗糙度，它将影响高光的范围。 在本材质中，漫反射项由 Lambertian 材质提供，高光项则由粗糙度定义的微表面材质提供。 9.2.3 Mix Material 这种模型可以使用给定的权重混合任意两种材质，它会首先复制一份 SurfaceInteraction ，接着在两个 SI 上使用两种材质生成原始的 BSDF ，最后使用权重在原始的 SI 上重新生成 ScaledBSDF。 12345678910111213141516171819void MixMaterial::ComputeScatteringFunctions(SurfaceInteraction *si, MemoryArena &amp;arena, TransportMode mode, bool allowMultipleLobes) const &#123; // Compute weights and original _BxDF_s for mix material Spectrum s1 = scale-&gt;Evaluate(*si).Clamp(); Spectrum s2 = (Spectrum(1.f) - s1).Clamp(); SurfaceInteraction si2 = *si; m1-&gt;ComputeScatteringFunctions(si, arena, mode, allowMultipleLobes); m2-&gt;ComputeScatteringFunctions(&amp;si2, arena, mode, allowMultipleLobes); // Initialize _si-&gt;bsdf_ with weighted mixture of _BxDF_s int n1 = si-&gt;bsdf-&gt;NumComponents(), n2 = si2.bsdf-&gt;NumComponents(); for (int i = 0; i &lt; n1; ++i) si-&gt;bsdf-&gt;bxdfs[i] = ARENA_ALLOC(arena, ScaledBxDF)(si-&gt;bsdf-&gt;bxdfs[i], s1); for (int i = 0; i &lt; n2; ++i) si-&gt;bsdf-&gt;Add(ARENA_ALLOC(arena, ScaledBxDF)(si2.bsdf-&gt;bxdfs[i], s2));&#125; 9.2.4 Fourier Material 这种材质根据提供的数据源文件名生成 FourierBSDF 并应用在 SI 上。 9.2.5 其它材质 除此之外，PBRT中还实现了大量如金属材质、次表面材质、Disney BSDF 材质等内容，此处就不一一详述。 9.3 Bump Mapping Bump Mapping 实际上在每一个位置上从对应材质上采样了一个浮点数 d(p)d(p)d(p) ，并将该位置沿着法线方向向外扩张 d(p)d(p)d(p) 单位，以此来计算用于着色的法线。这一技术可以以很低的成本增加场景中的细节，因此被广泛地应用于各种渲染流程中。 Material::Bump() 方法提供了一种通用的 bump mapping 计算方法，它输入一个 Bump 材质和一个 SurfaceInteraction 指针，利用 SI 中的信息采样材质，并将对应的表面信息写入用于着色的 ShadingGeometry 之中。它通过 SI 中的微分信息在着色点和 du,dv 位置采样三次 bump map，并将得到的表面信息写入 SI 。 1234567891011121314151617181920212223242526272829303132333435363738void Material::Bump(const std::shared_ptr&lt;Texture&lt;Float&gt;&gt; &amp;d, SurfaceInteraction *si) &#123; // Compute offset positions and evaluate displacement texture SurfaceInteraction siEval = *si; // Shift _siEval_ _du_ in the $u$ direction Float du = .5f * (std::abs(si-&gt;dudx) + std::abs(si-&gt;dudy)); // The most common reason for du to be zero is for ray that start from // light sources, where no differentials are available. In this case, // we try to choose a small enough du so that we still get a decently // accurate bump value. if (du == 0) du = .0005f; siEval.p = si-&gt;p + du * si-&gt;shading.dpdu; siEval.uv = si-&gt;uv + Vector2f(du, 0.f); siEval.n = Normalize((Normal3f)Cross(si-&gt;shading.dpdu, si-&gt;shading.dpdv) + du * si-&gt;dndu); Float uDisplace = d-&gt;Evaluate(siEval); // Shift _siEval_ _dv_ in the $v$ direction Float dv = .5f * (std::abs(si-&gt;dvdx) + std::abs(si-&gt;dvdy)); if (dv == 0) dv = .0005f; siEval.p = si-&gt;p + dv * si-&gt;shading.dpdv; siEval.uv = si-&gt;uv + Vector2f(0.f, dv); siEval.n = Normalize((Normal3f)Cross(si-&gt;shading.dpdu, si-&gt;shading.dpdv) + dv * si-&gt;dndv); Float vDisplace = d-&gt;Evaluate(siEval); Float displace = d-&gt;Evaluate(*si); // Compute bump-mapped differential geometry Vector3f dpdu = si-&gt;shading.dpdu + (uDisplace - displace) / du * Vector3f(si-&gt;shading.n) + displace * Vector3f(si-&gt;shading.dndu); Vector3f dpdv = si-&gt;shading.dpdv + (vDisplace - displace) / dv * Vector3f(si-&gt;shading.n) + displace * Vector3f(si-&gt;shading.dndv); si-&gt;SetShadingGeometry(dpdu, dpdv, si-&gt;shading.dndu, si-&gt;shading.dndv, false);&#125;","categories":[{"name":"programming","slug":"programming","permalink":"https://blog.apassbydreg.work/categories/programming/"},{"name":"reading notes","slug":"programming/reading-notes","permalink":"https://blog.apassbydreg.work/categories/programming/reading-notes/"}],"tags":[{"name":"CG","slug":"CG","permalink":"https://blog.apassbydreg.work/tags/CG/"},{"name":"render","slug":"render","permalink":"https://blog.apassbydreg.work/tags/render/"},{"name":"PBRT","slug":"PBRT","permalink":"https://blog.apassbydreg.work/tags/PBRT/"}]},{"title":"PBRT 第八章笔记 | Notes for PBRT Chapter 08 - Reflection Models","slug":"PBRT-ch08","date":"2021-11-21T09:02:43.000Z","updated":"2022-02-15T09:41:41.310Z","comments":true,"path":"2021/11/PBRT-ch08/","link":"","permalink":"https://blog.apassbydreg.work/2021/11/PBRT-ch08/","excerpt":"","text":"8.1 Basic Interface 在 PBRT 中，BRDF 和 BTDF 这两种反射模型均使用 BxDF 接口： 1234567891011121314151617181920class BxDF &#123; public: // BxDF Interface virtual ~BxDF() &#123;&#125; BxDF(BxDFType type) : type(type) &#123;&#125; bool MatchesFlags(BxDFType t) const &#123; return (type &amp; t) == type; &#125; virtual Spectrum f(const Vector3f &amp;wo, const Vector3f &amp;wi) const = 0; virtual Spectrum Sample_f(const Vector3f &amp;wo, Vector3f *wi, const Point2f &amp;sample, Float *pdf, BxDFType *sampledType = nullptr) const; virtual Spectrum rho(const Vector3f &amp;wo, int nSamples, const Point2f *samples) const; virtual Spectrum rho(int nSamples, const Point2f *samples1, const Point2f *samples2) const; virtual Float Pdf(const Vector3f &amp;wo, const Vector3f &amp;wi) const; virtual std::string ToString() const = 0; // BxDF Public Data const BxDFType type;&#125;; PBRT 支持的 BxDF 类型如下： 123456789enum BxDFType &#123; BSDF_REFLECTION = 1 &lt;&lt; 0, BSDF_TRANSMISSION = 1 &lt;&lt; 1, BSDF_DIFFUSE = 1 &lt;&lt; 2, BSDF_GLOSSY = 1 &lt;&lt; 3, BSDF_SPECULAR = 1 &lt;&lt; 4, BSDF_ALL = BSDF_DIFFUSE | BSDF_GLOSSY | BSDF_SPECULAR | BSDF_REFLECTION | BSDF_TRANSMISSION,&#125;; BxDF 接口中最重要的函数是 Spectrum BxDF::f(const Vector3f &amp;wo, const Vector3f &amp;wi) 它返回从 wiw_iwi​ 方向入射的光线能量转移到 wow_owo​ 方向上的比例。它假设不同波长的光线互相独立，因此返回值是一个 Spectrum 值，通过直接将它于入射光的 radiance 相乘即可得到出射光的 radiance 。 不是所有的 BxDF 都可以使用上面的函数采样。例如：完美光滑的镜面反射对于任意出射角度只有一个角度会贡献能量，这造成了对于几乎所有的入射光线调用 BxDF::f 的返回结果都是零。因此在这个接口中还提供了结合了采样和评估影响的结合函数 BxDF::Sample_f 。这个函数通过给定的出射角度、采样类型和生成的随机样本采样入射角，并将本次采样的 pdf 和对应的 f 值返回。 8.1.1 反射率 根据与出射方向是否相关这一点，可以引申出两种反射率的定义：与出射方向无关的 hemispherical-hemispherical reflectance 和与出射方向有关的 hemispherical-directional reflectance 。它们表示了所有的入射能量经过表面反射后出射的比例。 ρhd(wo)=∫H2(n)fr(p,ωo,ωi)∣cos⁡θi∣dωiρhh=1π∫H2(n)∫H2(n)fr(p,ωo,ωi)∣cos⁡θocos⁡θi∣dωodωi\\rho_{\\mathrm{hd}}(w_o)=\\int_{\\mathrm{H}^{2}(\\mathbf{n})} f_{\\mathrm{r}}\\left(\\mathrm{p}, \\omega_{\\mathrm{o}}, \\omega_{\\mathrm{i}}\\right)\\left|\\cos \\theta_{\\mathrm{i}}\\right| \\mathrm{d} \\omega_{\\mathrm{i}}\\\\ \\rho_{\\mathrm{hh}}=\\frac{1}{\\pi} \\int_{\\mathrm{H}^{2}(\\mathbf{n})} \\int_{\\mathrm{H}^{2}(\\mathbf{n})} f_{\\mathrm{r}}\\left(\\mathrm{p}, \\omega_{\\mathrm{o}}, \\omega_{\\mathrm{i}}\\right)\\left|\\cos \\theta_{\\mathrm{o}} \\cos \\theta_{\\mathrm{i}}\\right| \\mathrm{d} \\omega_{\\mathrm{o}} \\mathrm{d} \\omega_{\\mathrm{i}}ρhd​(wo​)=∫H2(n)​fr​(p,ωo​,ωi​)∣cosθi​∣dωi​ρhh​=π1​∫H2(n)​∫H2(n)​fr​(p,ωo​,ωi​)∣cosθo​cosθi​∣dωo​dωi​ BxDF::rho 函数提供了计算这两个反射率的方法，如果其中提供了一个出射方向则计算 ρhd\\rho_{hd}ρhd​ ，反之则计算 ρhh\\rho_{hh}ρhh​ 。 8.1.2 BxDF Scaling Adapter 在实际应用中，可能会出现将不同的 BxDF 以不同的比例结合到一起的情况。此时需要将 BxDF 的 f 值进行一定程度的缩放。ScaledBxDF 类完成了这一操作，它在 BxDF 的基础上额外加入了一个缩放参数，并在计算 f, Sample_f 的基础上在返回前将贡献值乘以该参数。 8.2 Specular Reflection and Transmission 本章中讨论了镜面反射和折射，它们的入射、出射关系分别为： θi=θoηisin⁡θi=ηtsin⁡θt\\theta_i = \\theta_o \\\\ \\eta_i\\sin\\theta_i = \\eta_t\\sin\\theta_tθi​=θo​ηi​sinθi​=ηt​sinθt​ 8.2.1 菲涅尔反射系数 (Fresnel Reflectance) 菲涅尔方程定义了光线在物体表面反射和折射（对于不透明物体即吸收）的能量比例，它是麦克斯韦方程在光滑表面上的解。给定入射光线与法线的夹角以及两种介质的折射率，菲涅尔方程可以得到光线在两个不同的极化方向上入射光的折射率。PBRT 中并不考虑光的极性，因此将最终的折射率简单地认为是两个方向上的折射率的平方均值。 在现实中计算菲涅尔方程时，通常需要考虑三种材质： dielectrics（电介质）：它们不导电，折射率通常是一个 1 - 3 之间的实数 conductors（导体）：这类材质中具有自由电子，它们通常是不透明的且会将大部分能量反射出去。没有被反射的光子通常在进入导体后的 0.1μm0.1\\mathrm{\\mu m}0.1μm 就被迅速吸收，因此在 PBRT 中并不考虑这种材质的折射情况。与 dielectrics 不同的是，这类材质的折射率是一个复数 ηˉ=η+ik\\bar{\\eta} = \\eta + ikηˉ​=η+ik 除了上述两种材质外还有半导体材质，PBRT 并不考虑这一类物体 dielectrics 的折射系数 电介质的菲涅尔公式的计算方法如下： r∥=ηtcos⁡θi−ηicos⁡θtηtcos⁡θi+ηicos⁡θtr⊥=ηicos⁡θi−ηtcos⁡θtηicos⁡θi+ηtcos⁡θt\\begin{aligned}r_{\\|} &amp;=\\frac{\\eta_{\\mathrm{t}} \\cos \\theta_{\\mathrm{i}}-\\eta_{\\mathrm{i}} \\cos \\theta_{\\mathrm{t}}}{\\eta_{\\mathrm{t}} \\cos \\theta_{\\mathrm{i}}+\\eta_{\\mathrm{i}} \\cos \\theta_{\\mathrm{t}}} \\\\r_{\\perp} &amp;=\\frac{\\eta_{\\mathrm{i}} \\cos \\theta_{\\mathrm{i}}-\\eta_{\\mathrm{t}} \\cos \\theta_{\\mathrm{t}}}{\\eta_{\\mathrm{i}} \\cos \\theta_{\\mathrm{i}}+\\eta_{\\mathrm{t}} \\cos \\theta_{\\mathrm{t}}}\\end{aligned} r∥​r⊥​​=ηt​cosθi​+ηi​cosθt​ηt​cosθi​−ηi​cosθt​​=ηi​cosθi​+ηt​cosθt​ηi​cosθi​−ηt​cosθt​​​ 对于非极性的光线，最终的菲涅尔反射系数计算方法为： Fr=12(r∥2+r⊥2)F_r = {1 \\over 2}(r_{\\parallel}^2 + r_{\\perp}^2) Fr​=21​(r∥2​+r⊥2​) 考虑能量守恒，折射系数即为 Ft=1−FrF_t = 1 - F_rFt​=1−Fr​ PBRT 中计算菲涅尔反射系数的函数是 Float FrDielectric(Float cosThetaI, Float etaI, Float etaT) ，它使用预先计算的入射光线与法线的夹角的余弦值和两种介质的折射率得到反射系数。需要注意的是，当光线与法线夹角为负数时，说明是从反向入射，此时需要做一点转换，交换介质的折射系数并将夹角取绝对值。 在准备工作完成后，整个计算工作分为两步： 计算折射角度：这一步中不需要计算角度值，只需要计算 sin⁡θt\\sin\\theta_tsinθt​ 即可。当由折射公式得到的 sin⁡θt\\sin\\theta_tsinθt​ 大于 1 时，说明发生了全反射，此时直接让函数返回 1 即可 使用 sin⁡θt\\sin\\theta_tsinθt​ 得到 cos⁡θt\\cos\\theta_tcosθt​ 并计算反射系数。 conductor 的折射系数 导体的折射系数分为实部和虚部两个部分，其中的虚部 kkk 一般称为吸收系数，因为部分入射光的能量会在导体中被吸收并最终转换为热能。下图展示了金的折射系数随波长变化的曲线（实线表示虚部、虚线表示实部）： 由于一般不考虑导体的折射情况，因此只需要考虑电介质与导体的交界处的反射情况，因此只需要输入一个虚部。导体的菲涅尔反射系数的计算方法如下： r⊥=a2+b2−2acos⁡θ+cos⁡2θa2+b2+2acos⁡θ+cos⁡2θr∥=r⊥cos⁡2θ(a2+b2)−2acos⁡θsin⁡2θ+sin⁡4θcos⁡2θ(a2+b2)+2acos⁡θsin⁡2θ+sin⁡4θa2+b2=(η2−k2−sin⁡2θ)2+4η2k2a2=b2+(η2−k2−sin⁡2θ)\\begin{aligned}r_{\\perp}&amp;=&amp; \\frac{a^{2}+b^{2}-2 a \\cos \\theta+\\cos ^{2} \\theta}{a^{2}+b^{2}+2 a \\cos \\theta+\\cos ^{2} \\theta} \\\\ r_{\\|}&amp;=&amp; r_{\\perp} \\frac{\\cos ^{2} \\theta\\left(a^{2}+b^{2}\\right)-2 a \\cos \\theta \\sin ^{2} \\theta+\\sin ^{4} \\theta}{\\cos ^{2} \\theta\\left(a^{2}+b^{2}\\right)+2 a \\cos \\theta \\sin ^{2} \\theta+\\sin ^{4} \\theta} \\\\ a^{2}+b^{2}&amp;=&amp;\\sqrt{\\left(\\eta^{2}-k^{2}-\\sin ^{2} \\theta\\right)^{2}+4 \\eta^{2} k^{2}}\\\\ a^2&amp;=&amp; b^2 + (\\eta^{2}-k^{2}-\\sin ^{2} \\theta) \\end{aligned}r⊥​r∥​a2+b2a2​====​a2+b2+2acosθ+cos2θa2+b2−2acosθ+cos2θ​r⊥​cos2θ(a2+b2)+2acosθsin2θ+sin4θcos2θ(a2+b2)−2acosθsin2θ+sin4θ​(η2−k2−sin2θ)2+4η2k2​b2+(η2−k2−sin2θ)​ 代码实现 所有菲涅尔项的计算均继承于基类 Fresnel ： 1234567class Fresnel &#123; public: // Fresnel Interface virtual ~Fresnel(); virtual Spectrum Evaluate(Float cosI) const = 0; virtual std::string ToString() const = 0;&#125;; 运行时，首先会通过构造函数构造一个界面，它接收 Spectrum 类型的 η,k\\eta, kη,k 值（如果需要的话），最后使用 Evaluate 函数从入射光的余弦得到反射系数。 FresnelConductor, FresnelDielectric 类实现了上述的两个公式，另外有无论从任何地方的入射光均会返回 1 的一种特殊情况由 FresnelNoOp 实现。 8.2.2 镜面反射 由于镜面反射只在一个角度上发生，积分可以使用一个 δ\\deltaδ 冲激函数简化为一个位置处的值，即： Lo(ωo)=Fr(ωr)Li(ωr)L_o(\\omega_o)=F_r(\\omega_r)L_i(\\omega_r) Lo​(ωo​)=Fr​(ωr​)Li​(ωr​) 转换为 BRDF 的表达方式为（注意要抵消掉渲染公式中额外的 cos⁡θ\\cos\\thetacosθ 项）： fr(ωi,ωo)=Fr(ωr)δ(ωi−ωr)∣cos⁡θr∣f_r(\\omega_i, \\omega_o) = {F_r(\\omega_r)\\delta(\\omega_i-\\omega_r) \\over |\\cos\\theta_r|} fr​(ωi​,ωo​)=∣cosθr​∣Fr​(ωr​)δ(ωi​−ωr​)​ 这种冲激函数的性质导致了在实际采样中恰好采样到 0 位置的可能性为零，因此它不适用 BxDF::f 接口（在本类中这个函数返回常值 0 ），而需要使用 BxDF::Sample_f 接口，首先用反射方法采样一个 pdf 为 1 的入射角度，再返回上述 BRDF 的值。 除此之外，本类中还含有一个 Spectrum R 成员变量，用来表示在反射的过程中有多少能量没有被吸收。 8.2.3 镜面折射 与反射不同，在不同介质之间折射的情况下 radiance 的变化还需要乘以一个折射率的平方比例，直觉上可以将这一项缩放系数理解为光线在折射后固体角发生了拉伸或者压缩。详细的推导过程如下： 首先从能量角度看： dΦo=(1−Fr(ωi))dΦi\\mathrm{d\\Phi_o} = (1 - F_r(\\omega_i))\\mathrm{d\\Phi_i} dΦo​=(1−Fr​(ωi​))dΦi​ 展开为 radiance 的样式 Locos⁡θodAdωo=(1−Fr(ωi))Licos⁡θidAdωiL_o\\cos\\theta_o\\mathrm{dA}\\mathrm{d\\omega_o} = (1 - F_r(\\omega_i))L_i\\cos\\theta_i\\mathrm{dA}\\mathrm{d\\omega_i} Lo​cosθo​dAdωo​=(1−Fr​(ωi​))Li​cosθi​dAdωi​ 再将固体角展开 Locos⁡θodA(sin⁡θodθodϕo)=(1−Fr(ωi))Licos⁡θidA(sin⁡θidθidϕi)L_o\\cos\\theta_o\\mathrm{dA}(\\sin\\theta_o\\mathrm{d\\theta_o}\\mathrm{d\\phi_o}) = (1 - F_r(\\omega_i))L_i\\cos\\theta_i\\mathrm{dA}(\\sin\\theta_i\\mathrm{d\\theta_i}\\mathrm{d\\phi_i}) Lo​cosθo​dA(sinθo​dθo​dϕo​)=(1−Fr​(ωi​))Li​cosθi​dA(sinθi​dθi​dϕi​) 注意到折射的公式： ηosin⁡θo=ηisin⁡θiηocos⁡θodθo=ηicos⁡θidθi\\eta_o\\sin\\theta_o = \\eta_i\\sin\\theta_i\\\\ \\eta_o\\cos\\theta_o\\mathrm{d\\theta_o} = \\eta_i\\cos\\theta_i\\mathrm{d\\theta_i}ηo​sinθo​=ηi​sinθi​ηo​cosθo​dθo​=ηi​cosθi​dθi​ 将上述公式带入固体角展开的公式，并注意到 ϕi=ϕo+π\\phi_i= \\phi_o + \\piϕi​=ϕo​+π Lo=(1−Fr(ωi))ηo2ηi2L_o = (1 - F_r(\\omega_i)){\\eta_o^2 \\over \\eta_i^2} Lo​=(1−Fr​(ωi​))ηi2​ηo2​​ 由此得到 BRDF 的表达式： fr(ωo,ωi)=(1−Fr(ωi))ηo2ηi2⋅δ(ωi−ωt)∣cos⁡θr∣f_r(\\omega_o, \\omega_i) = (1 - F_r(\\omega_i)){\\eta_o^2 \\over \\eta_i^2}\\cdot{\\delta(\\omega_i-\\omega_t) \\over |\\cos\\theta_r|} fr​(ωo​,ωi​)=(1−Fr​(ωi​))ηi2​ηo2​​⋅∣cosθr​∣δ(ωi​−ωt​)​ 折射情况下和反射的代码实现大同小异，其中含的成员变量 Spectrum T 和上一节中的 Spectrum R 类似，用来表示在折射的过程中有多少能量没有被吸收。 8.2.4 Fresnel-Modulated Specular Reflection and Transmission FresnelSpecular 类型统一了 dielectrics 的折射和反射（因为我们不考虑导体的折射）。 该接口在调用 Sample_f 时会首先计算菲涅尔反射系数，并将这个系数和随机数的第一个元素比对。当随机数在反射系数范围内时，采样反射光线、否则采样折射光线。它会将采样的类型写入 BxDFType *sampledType 中。 8.3 Lambertian Reflection 与镜面反射相对的另一种理想材质是 Lambertian Reflection，它代表了完美的漫反射。从任意角度入射的光线能量会被均匀地分布到整个半球面上。其 BRDF 可以简单地表示为： fr(ωi,ωo)=C=1πf_r(\\omega_i, \\omega_o) = C = {1 \\over \\pi} fr​(ωi​,ωo​)=C=π1​ 这个公式可以通过将常数值带入 ρhd\\rho_{hd}ρhd​ 的公式求解。需要注意的是将固体角积分转换为极坐标积分时有另一个额外的 cos⁡\\coscos 项。它在实现上异常简单： 1234567891011121314class LambertianReflection : public BxDF &#123; public: // LambertianReflection Public Methods LambertianReflection(const Spectrum &amp;R) : BxDF(BxDFType(BSDF_REFLECTION | BSDF_DIFFUSE)), R(R) &#123;&#125; Spectrum f(const Vector3f &amp;wo, const Vector3f &amp;wi) const &#123; return R * InvPi; &#125; Spectrum rho(const Vector3f &amp;, int, const Point2f *) const &#123; return R; &#125; Spectrum rho(int, const Point2f *, const Point2f *) const &#123; return R; &#125; std::string ToString() const; private: // LambertianReflection Private Data const Spectrum R;&#125;; 与反射项相似的可以定义 Lambertian Transmission ，其实现过程和本类相似。 8.4 Microfacet Models 微表面模型将一个粗糙表面视作由大量凹凸不平的微小平滑表面组成，光线在这些以某种统计学分布的微表面上以某种方式被散射出去。这种模型的对光的影响分为以下几类： Masking：反射的光线被微表面遮挡 Shadowing：入射的光线被微表面遮挡 Interreflection：光线经过多个微表面的反射到达观察者 8.4.1 Oren-Nayar Diffuse Reflection Oren 和 Nayar 从对现实世界的观测中发现：现实世界中粗糙表面通常会在当入射角度接近观测角度时变得更明亮。他们由此提出了一种简单的「V」形微表面模型，其中的微表面发现分布由单一参数 σ\\sigmaσ 的球形高斯分布控制。这种模型最终的 BRDF 计算方式如下： fr(ωi,ωo)=Rπ(A+Bmax⁡(0,cos⁡(ϕi−ϕo))sin⁡αtan⁡β)f_{\\mathrm{r}}\\left(\\omega_{\\mathrm{i}}, \\omega_{\\mathrm{o}}\\right)=\\frac{R}{\\pi}\\left(A+B \\max \\left(0, \\cos \\left(\\phi_{\\mathrm{i}}-\\phi_{\\mathrm{o}}\\right)\\right) \\sin \\alpha \\tan \\beta\\right) fr​(ωi​,ωo​)=πR​(A+Bmax(0,cos(ϕi​−ϕo​))sinαtanβ) 其中 σ\\sigmaσ 由弧度表示，A,B,α,βA,B,\\alpha,\\betaA,B,α,β 的定义如下： A=1−σ22(σ2+0.33)B=0.45σ2σ2+0.09α=max⁡(θi,θo)β=min⁡(θi,θo)\\begin{aligned}A &amp;=1-\\frac{\\sigma^{2}}{2\\left(\\sigma^{2}+0.33\\right)} \\\\B &amp;=\\frac{0.45 \\sigma^{2}}{\\sigma^{2}+0.09} \\\\\\alpha &amp;=\\max \\left(\\theta_{\\mathrm{i}}, \\theta_{\\mathrm{o}}\\right) \\\\\\beta &amp;=\\min \\left(\\theta_{\\mathrm{i}}, \\theta_{\\mathrm{o}}\\right)\\end{aligned} ABαβ​=1−2(σ2+0.33)σ2​=σ2+0.090.45σ2​=max(θi​,θo​)=min(θi​,θo​)​ 这类模型的实现见 OrenNayar 8.4.2 微表面分布函数 为了表示微表面模型的几何特征，我们需要一种方法表示它的分布函数。MicrofacetDistribution 类提供了这一层抽象。这个类型的主要目的是计算微表面的分布函数 D(ωh)D(\\omega_h)D(ωh​) ，它表示表面法线在各个方向上的微分面积的比例。它必须被归一化： ∫H2(n)D(ωh)cos⁡θhdωh=1\\int_{H^2(n)}D(\\omega_h)\\cos\\theta_h\\mathrm{d\\omega_h} = 1 ∫H2(n)​D(ωh​)cosθh​dωh​=1 如上图，微表面分布函数体现了不同角度的面的面积，这些面积在乘以 cos⁡θh\\cos\\theta_hcosθh​ 后需要可以被归一化到于直射相同的微分面积上。 Beckmann–Spizzichino 微表面模型 Beckmann–Spizzichino 模型的函数分布如下： D(ωh)=e−tan⁡2θh(cos⁡2ϕh/αx2+sin⁡2ϕh/αy2)παxαycos⁡4θhD\\left(\\omega_{\\mathrm{h}}\\right)=\\frac{\\mathrm{e}^{-\\tan ^{2} \\theta_{\\mathrm{h}}\\left(\\cos ^{2} \\phi_{\\mathrm{h}} / \\alpha_{x}^{2}+\\sin ^{2} \\phi_{\\mathrm{h}} / \\alpha_{y}^{2}\\right)}}{\\pi \\alpha_{x} \\alpha_{y} \\cos ^{4} \\theta_{\\mathrm{h}}} D(ωh​)=παx​αy​cos4θh​e−tan2θh​(cos2ϕh​/αx2​+sin2ϕh​/αy2​)​ 其中 αx,αy\\alpha_x, \\alpha_yαx​,αy​ 分别是 uv 方向上的各向异性参数，对于各向同性的材质，αx=αy=2σ\\alpha_x = \\alpha_y = \\sqrt{2}\\sigmaαx​=αy​=2​σ ，其中 σ\\sigmaσ 是微表面的 RMS slope。 Trowbridge–Reitz (GGX) 微表面模型 Trowbridge–Reitz 模型的函数分布如下： D(ωh)=1παxαycos⁡4θh(1+tan⁡2θh(cos⁡2ϕh/αx2+sin⁡2ϕh/αy2))2D\\left(\\omega_{\\mathrm{h}}\\right)=\\frac{1}{\\pi \\alpha_{x} \\alpha_{y} \\cos ^{4} \\theta_{\\mathrm{h}}\\left(1+\\tan ^{2} \\theta_{\\mathrm{h}}\\left(\\cos ^{2} \\phi_{\\mathrm{h}} / \\alpha_{x}^{2}+\\sin ^{2} \\phi_{\\mathrm{h}} / \\alpha_{y}^{2}\\right)\\right)^{2}} D(ωh​)=παx​αy​cos4θh​(1+tan2θh​(cos2ϕh​/αx2​+sin2ϕh​/αy2​))21​ 这种模型具有更加平滑的尾部（又称长尾效应），且可以提供一种快速地从范围在 [0,1][0,1][0,1] 的粗糙度参数转换为各向异性参数 α\\alphaα 的方法 TrowbridgeReitzDistribution::RoughnessToAlpha(Float roughness) 。PBRT 中使用了四阶泰勒展开计算这一值。 8.4.3 Masking and Shadowing 本节中讨论了之前提到的 Masking 和 Shadowing 两种影响。这主要是由于从视点或光线方向看到物体的表面上会有一部分的微表面因为被别的微表面遮挡二不可见的情况，它们通常使用 masking-shadowing 函数 G1(ω,ωh)G_1(\\omega, \\omega_h)G1​(ω,ωh​) 表示，即给定观测方向和一种微表面的法线方向，这类微表面对于该观测方向的可见度。在更理想的情况下，这个值通常对于所有的微表面法线均相同，可以将这个函数简化为 G(ω)G(\\omega)G(ω) 。 使用投影定理不难得到这个函数的一个限制条件： cos⁡θ=∫H2(n)G1(ω,ωh)max⁡(0,ω⋅ωh)D(ωh)dωh\\cos \\theta=\\int_{\\mathrm{H}^{2}(\\mathbf{n})} G_{1}\\left(\\omega, \\omega_{\\mathrm{h}}\\right) \\max \\left(0, \\omega \\cdot \\omega_{\\mathrm{h}}\\right) D\\left(\\omega_{\\mathrm{h}}\\right) \\mathrm{d} \\omega_{\\mathrm{h}} cosθ=∫H2(n)​G1​(ω,ωh​)max(0,ω⋅ωh​)D(ωh​)dωh​ 由于微表面形成了一个高度场，每一个背光的表面均会在面向光源的一面上投影相同的阴影，我们用 A±(ω)A^{\\pm}(\\omega)A±(ω) 分别表示面光的投影面积和逆光的投影面积，有： cos⁡θ=A+(ω)−A−(ω)G1(ω)=A+(ω)−A−(ω)A+(ω)\\begin{aligned} \\cos\\theta &amp;= A^+(\\omega) - A^-(\\omega)\\\\ G_1(\\omega) &amp;= {A^+(\\omega) - A^-(\\omega) \\over A^+(\\omega)} \\end{aligned}cosθG1​(ω)​=A+(ω)−A−(ω)=A+(ω)A+(ω)−A−(ω)​​ masking-shadowing 函数通常会使用一个中间量 Λ\\LambdaΛ 书写，它表示了背光的投影面积占总体投影面积的比例，由 MicrofacetDistribution::Lambda(const Vector3f &amp;w) 接口实现： Λ(ω)=A−(ω)A+(ω)−A−(ω)=A−(ω)cos⁡θG1(ω)=11+Λ(ω)\\Lambda(\\omega) = {A^-(\\omega) \\over A^+(\\omega) - A^-(\\omega)} = {A^-(\\omega) \\over \\cos\\theta}\\\\ G_1(\\omega) = {1 \\over 1 + \\Lambda(\\omega)}Λ(ω)=A+(ω)−A−(ω)A−(ω)​=cosθA−(ω)​G1​(ω)=1+Λ(ω)1​ 最后，要计算入射和出射方向上的 masking-shadowing 函数时，一种简单的方法是直接将两个方向上的函数值相乘，即 G(ωi,ωo)=G1(ωi)G1(ωo)G(\\omega_i, \\omega_o) = G_1(\\omega_i)G_1(\\omega_o)G(ωi​,ωo​)=G1​(ωi​)G1​(ωo​) 但这要求各个方向上的可见性是完全独立的，但这并不现实，如当 ωi=ωo\\omega_i = \\omega_oωi​=ωo​ 时显然应该有 G(ωi,ωo)=G1(ωi)=G1(ωo)G(\\omega_i, \\omega_o) = G_1(\\omega_i) = G_1(\\omega_o)G(ωi​,ωo​)=G1​(ωi​)=G1​(ωo​) ，因此人们通常会使用另一种计算双向 masking-shadowing 函数的方法： G(ωi,ωo)=11+Λ(ωi)+Λ(ωi)G(\\omega_i, \\omega_o) = {1 \\over 1 + \\Lambda(\\omega_i) + \\Lambda(\\omega_i)} G(ωi​,ωo​)=1+Λ(ωi​)+Λ(ωi​)1​ Beckmann–Spizzichino 分布下的 Λ\\LambdaΛ 函数 Λ(ω)=12(erf⁡(a)−1+e−a2aπ)\\Lambda(\\omega)=\\frac{1}{2}\\left(\\operatorname{erf}(a)-1+\\frac{\\mathrm{e}^{-a^{2}}}{a \\sqrt{\\pi}}\\right) Λ(ω)=21​(erf(a)−1+aπ​e−a2​) 其中： a=1tan⁡θαx2cos⁡2ϕ+αy2sin⁡2ϕerf(x)=2π∫0xe−t2dt\\begin{aligned} a &amp; ={1 \\over \\tan\\theta\\sqrt{\\alpha_x^2\\cos^2\\phi + \\alpha_y^2\\sin^2\\phi}}\\\\ \\mathrm{erf}(x) &amp; = {2 \\over \\sqrt{\\pi}}\\int_0^xe^{-t^2}\\mathrm{dt} \\end{aligned}aerf(x)​=tanθαx2​cos2ϕ+αy2​sin2ϕ​1​=π​2​∫0x​e−t2dt​ Trowbridge–Reitz 分布下的 Λ\\LambdaΛ 函数 Λ(ω)=−1+1+α2tan⁡2θ2\\Lambda(\\omega)=\\frac{-1 + \\sqrt{1 + \\alpha^2\\tan^2\\theta}}{2} Λ(ω)=2−1+1+α2tan2θ​​ 其中： α2=αx2cos⁡2ϕ+αy2sin⁡2ϕ\\alpha^2 = \\alpha_x^2\\cos^2\\phi + \\alpha_y^2\\sin^2\\phi α2=αx2​cos2ϕ+αy2​sin2ϕ 8.4.4 Torrance–Sparrow 模型 Torrance–Sparrow 模型认为每一个微表面都是光滑的镜面，光线在这些微表面上满足菲涅尔反射定理。即有： ωh=ωi+ωo^\\omega_h = \\widehat{\\omega_i + \\omega_o} ωh​=ωi​+ωo​​ 从某个方向入射的能量可以表示为： dΦh=Li(ωi)dωdA⊥(ωh)=Li(ωi)dωcos⁡θhdA(ωh)\\mathrm{d} \\Phi_{\\mathrm{h}}=L_{\\mathrm{i}}\\left(\\omega_{\\mathrm{i}}\\right) \\mathrm{d} \\omega \\mathrm{d} A^{\\perp}\\left(\\omega_{\\mathrm{h}}\\right)=L_{\\mathrm{i}}\\left(\\omega_{\\mathrm{i}}\\right) \\mathrm{d} \\omega \\cos \\theta_{\\mathrm{h}} \\mathrm{d} A\\left(\\omega_{\\mathrm{h}}\\right) dΦh​=Li​(ωi​)dωdA⊥(ωh​)=Li​(ωi​)dωcosθh​dA(ωh​) 其中对该方向的投影面积微分可以转化到对微表面的面积微分： dA(ωh)=D(ωh)dωhdA\\mathrm{dA(\\omega_h)} = D(\\omega_h)\\mathrm{d\\omega_hdA} dA(ωh​)=D(ωh​)dωh​dA 另一方面，认为每个微表面分布独立地以菲涅尔系数反射光线： dΦo=Fr(ωo)dΦh\\mathrm{d\\Phi_o} = F_r(\\omega_o)\\mathrm{d\\Phi_h} dΦo​=Fr​(ωo​)dΦh​ 再利用出射 radiance 的定义有： L(ωo)=Fr(ωo)Li(ωi)dωiD(ωh)dωhdAcos⁡θhdωodAcos⁡θoL\\left(\\omega_{\\mathrm{o}}\\right)=\\frac{F_{\\mathrm{r}}\\left(\\omega_{\\mathrm{o}}\\right) L_{\\mathrm{i}}\\left(\\omega_{\\mathrm{i}}\\right) \\mathrm{d} \\omega_{\\mathrm{i}} D\\left(\\omega_{\\mathrm{h}}\\right) \\mathrm{d} \\omega_{\\mathrm{h}} \\mathrm{d} A \\cos \\theta_{\\mathrm{h}}}{\\mathrm{d} \\omega_{\\mathrm{o}} \\mathrm{d} A \\cos \\theta_{\\mathrm{o}}} L(ωo​)=dωo​dAcosθo​Fr​(ωo​)Li​(ωi​)dωi​D(ωh​)dωh​dAcosθh​​ 此时需要用到一个在 14.1.1 中会证明的先验知识： dωh=dωo4cos⁡θh\\mathrm{d\\omega_h} = {\\mathrm{d\\omega_o} \\over 4\\cos\\theta_h} dωh​=4cosθh​dωo​​ 通过消元，我们最终得到了这一微表面模型下的 BRDF ： fr(ωi,ωo)=Fr(ωo)G(ωo,ωi)D(ωh)4cos⁡θocos⁡θif_r(\\omega_i, \\omega_o) = {F_r(\\omega_o)G(\\omega_o,\\omega_i)D(\\omega_h) \\over 4\\cos\\theta_o\\cos\\theta_i} fr​(ωi​,ωo​)=4cosθo​cosθi​Fr​(ωo​)G(ωo​,ωi​)D(ωh​)​ 这正是 PBRT 的 MicrofacetReflection 类使用的 BRDF。该类通过一个反射系数 R 、一个微表面分布（通过多态实现）和一个菲涅尔项作为输入，计算最终的 BRDF： 123456789101112131415161718192021class MicrofacetReflection : public BxDF &#123; public: // MicrofacetReflection Public Methods MicrofacetReflection(const Spectrum &amp;R, MicrofacetDistribution *distribution, Fresnel *fresnel) : BxDF(BxDFType(BSDF_REFLECTION | BSDF_GLOSSY)), R(R), distribution(distribution), fresnel(fresnel) &#123;&#125; Spectrum f(const Vector3f &amp;wo, const Vector3f &amp;wi) const; Spectrum Sample_f(const Vector3f &amp;wo, Vector3f *wi, const Point2f &amp;u, Float *pdf, BxDFType *sampledType) const; Float Pdf(const Vector3f &amp;wo, const Vector3f &amp;wi) const; std::string ToString() const; private: // MicrofacetReflection Private Data const Spectrum R; const MicrofacetDistribution *distribution; const Fresnel *fresnel;&#125;; 同样的，MicrofacetTransmission 也以相似的方式实现。 8.5 Fresnel Incidence Effects 之前讨论的问题均没有考虑多层结构，以及由于菲涅尔效应导致的下层受光减少的现象。本节中讨论的 FresnelBlend 类型描述了一个多层结构：一个薄光滑表面下方加上另一个漫反射表面的反射表现。它利用入射角度混合两个表面的颜色。 这个模型中使用了一种著名的 Fresnel 函数近似方法： Fr(cos⁡θ)=R+(1−R)(1−cos⁡θ)5F_r(\\cos\\theta) = R + (1 - R)(1 - \\cos\\theta)^5 Fr​(cosθ)=R+(1−R)(1−cosθ)5 其中 RRR 表示竖直入射时的反射率。 本例中的镜面反射项和漫反射项的计算公式分别如下： fspecular(p,ωi,ωo)=D(ωh)F(ωo)4(ωh⋅ωi)(max⁡((n⋅ωo),(n⋅ωi)))fdiffuse(p,ωi,ωo)=28Rd23π(1−Rs)(1−(1−(n⋅ωi)2)5)(1−(1−(n⋅ωo)2)5)f_{specular}\\left(\\mathrm{p}, \\omega_{\\mathrm{i}}, \\omega_{\\mathrm{o}}\\right)=\\frac{D\\left(\\omega_{\\mathrm{h}}\\right) F\\left(\\omega_{\\mathrm{o}}\\right)}{4\\left(\\omega_{\\mathrm{h}} \\cdot \\omega_{\\mathrm{i}}\\right)\\left(\\max \\left(\\left(\\mathbf{n} \\cdot \\omega_{\\mathrm{o}}\\right),\\left(\\mathbf{n} \\cdot \\omega_{\\mathrm{i}}\\right)\\right)\\right)}\\\\ f_{diffuse}\\left(\\mathrm{p}, \\omega_{\\mathrm{i}}, \\omega_{\\mathrm{o}}\\right)=\\frac{28 R_{\\mathrm{d}}}{23 \\pi}\\left(1-R_{\\mathrm{s}}\\right)\\left(1-\\left(1-\\frac{\\left(\\mathbf{n} \\cdot \\omega_{\\mathrm{i}}\\right)}{2}\\right)^{5}\\right)\\left(1-\\left(1-\\frac{\\left(\\mathbf{n} \\cdot \\omega_{\\mathrm{o}}\\right)}{2}\\right)^{5}\\right)fspecular​(p,ωi​,ωo​)=4(ωh​⋅ωi​)(max((n⋅ωo​),(n⋅ωi​)))D(ωh​)F(ωo​)​fdiffuse​(p,ωi​,ωo​)=23π28Rd​​(1−Rs​)(1−(1−2(n⋅ωi​)​)5)(1−(1−2(n⋅ωo​)​)5) 将这两项的结果相加即可得到最终的 BRDF 。 Fourier Basis BSDFs 虽然之前描述的模型能满足大部分需求，但仍让有很大部分的 BRDF 形状无法用此前的模型描述（如更复杂的多层结构）。对于这些 BRDF ，最简单的解决方案就是直接使用特殊设备在现实中进行采样，并使用一个 3D 或 4D 的查找表储存 BRDF 在不同的情况下的取值，但这无疑会占用大量空间。为了解决这种问题，本节引入了傅里叶变换来压缩 BRDF 的表示。 Fourier Basis BSDFs 使用了一系列三角函数作为基函数，只需储存基函数的参数，在使用时将各个基函数累加起来即可得到重建的 BRDF 值。本节中不会讨论 BRDF 是如何从原始数据转化为基函数的参数，而只关注其应用方法。 首先，BRDF 可以表示为一个四维的函数： f(ωi,ωo)=f(μi,ϕi,μo,ϕo)f(\\omega_i, \\omega_o) = f(\\mu_i,\\phi_i,\\mu_o,\\phi_o) f(ωi​,ωo​)=f(μi​,ϕi​,μo​,ϕo​) 特别地，如果我们认为表面表现为各项同性，有： f(ωi,ωo)=f(μi,μo,ϕi−ϕo)=f(μi,μo,ϕo−ϕi)f(\\omega_i, \\omega_o) = f(\\mu_i,\\mu_o,\\phi_i-\\phi_o) = f(\\mu_i,\\mu_o,\\phi_o-\\phi_i) f(ωi​,ωo​)=f(μi​,μo​,ϕi​−ϕo​)=f(μi​,μo​,ϕo​−ϕi​) 这样就可以将参数维度降低到 3 维。接下来我们在含有 cos⁡\\coscos 项的 BRDF 在第三个维度 ϕ\\phiϕ 处使用傅里叶展开： f(μi,μo,ϕo−ϕi)∣μi∣=∑kak(μi,μo)cos⁡(k(ϕo−ϕi))f(\\mu_i,\\mu_o,\\phi_o-\\phi_i)|\\mu_i| = \\sum_{k}a_k(\\mu_i,\\mu_o)\\cos(k(\\phi_o-\\phi_i)) f(μi​,μo​,ϕo​−ϕi​)∣μi​∣=k∑​ak​(μi​,μo​)cos(k(ϕo​−ϕi​)) 其中 ak(μi,μo)a_k(\\mu_i,\\mu_o)ak​(μi​,μo​) 的值会使用一个 n×nn \\times nn×n 的表格储存（其中的 μ\\muμ 取值并不一定需要是等间距的，使用时会通过二分查找定位对应位置），如果使用 mmm 个 cos⁡\\coscos 项，整个傅里叶表示法需要 m×n×nm \\times n \\times nm×n×n 的空间储存参数。 FourierBSDFTable 储存了一个这样的表： 1234567891011121314151617 struct FourierBSDFTable &#123; Float eta; // 介质的 roi int mMax; // 傅里叶阶数 int nChannels; // 光谱通道数 int nMu; // μ 的采样数量 Float *mu; // μ 的取值位置 int *m; // 用于储存不同 μ 对使用的傅里叶阶数 int *aOffset; // 用于从两个 μ 的位置查询 a 的偏移量 Float *a; // a[aOffset[offset]] 以及后 m*ch 个位置储存了傅里叶系数 Float *a0; Float *cdf; Float *recip; static bool Read(const std::string &amp;filename, FourierBSDFTable *table); const Float *GetAk(int offsetI, int offsetO, int *mptr) const; bool GetWeightsAndOffset(Float cosTheta, int *offset, Float weights[4]) const;&#125;; FourierBSDF 类型封装了这种类型的 BRDF ，它保存了一个指向数据表的常引用。由于 aka_kak​ 是使用离散的值储存的，因此有必要对他进行插值。在实践中，会从角度周围的 4 * 4 个采样点处加权插值得到 aka_kak​ ： ak=∑a=03∑b=03ak(offseti+a,offseto+b)wi(a)wo(b)a_k = \\sum_{a=0}^3\\sum_{b=0}^3 a_k(offset_i+a,offset_o+b)w_i(a)w_o(b) ak​=a=0∑3​b=0∑3​ak​(offseti​+a,offseto​+b)wi​(a)wo​(b) 这里不使用 offset 左侧的样本加权主要是因为在 GetWeightsAndOffset 中就已经把 offset 设置在最左侧的样本位置上了 最后使用三角基函数计算拟合的 BSDF 值： f(ϕ)=∑k=0m−1akcos⁡(kϕ)f(\\phi) = \\sum_{k=0}^{m-1}a_k\\cos(k\\phi) f(ϕ)=k=0∑m−1​ak​cos(kϕ) 当阶数较多时，反复计算三角函数可能带来较多的开销，此时可以使用三角函数中的倍角公式利用递推的方法减少计算量： cos⁡(kϕ)+cos⁡((k−2)ϕ)=cos⁡((k−1)ϕ+ϕ)+cos⁡((k−1)ϕ−ϕ)=2cos⁡ϕcos⁡((k−1)ϕ)\\cos(k\\phi) + \\cos((k-2)\\phi)\\\\ =\\cos((k-1)\\phi + \\phi) + \\cos((k-1)\\phi-\\phi)\\\\ =2\\cos\\phi\\cos((k-1)\\phi)cos(kϕ)+cos((k−2)ϕ)=cos((k−1)ϕ+ϕ)+cos((k−1)ϕ−ϕ)=2cosϕcos((k−1)ϕ) 8.6.1 Spline Interpolation 这部分介绍了如何使用基于样条线（spline-based）的插值算法重建 aka_kak​ 参数。PBRT 中使用了 Catmull–Rom 样条线，它含有四个控制点，通过加权和计算曲线的值。这条曲线会经过所有控制点，并提供一段较为平缓的插值。 想要理解这一插值的方法，我们首先需要由一个三次多项式的角度逼近。 我们希望利用 p(x)=ax3+bx2+cx+dp(x) = ax^3 + bx^2 + cx + dp(x)=ax3+bx2+cx+d 去拟合某一段曲线在 x0,x1x_0, x_1x0​,x1​ 的范围内的片段，即有 ： p(x0)=f(x0), p(x1)=f(x1)p′(x0)=f′(x0), p′(x1)=f′(x1)p(x_0) = f(x_0),\\ p(x_1) = f(x_1)\\\\ p&#x27;(x_0) = f&#x27;(x_0),\\ p&#x27;(x_1) = f&#x27;(x_1)p(x0​)=f(x0​), p(x1​)=f(x1​)p′(x0​)=f′(x0​), p′(x1​)=f′(x1​) 把这几个有关原函数的值作为未知数，并将整个区间归一化到 [0,1][0,1][0,1] 范围内，我们就能解得上述多项式的系数： a=f′(x0)+f′(x1)+2f(x0)−2f(x1)b=3f(x1)−3f(x0)−2f′(x0)−f′(x1)c=f′(x0)d=f(x0)\\begin{aligned} a &amp;=f^{\\prime}\\left(x_{0}\\right)+f^{\\prime}\\left(x_{1}\\right)+2 f\\left(x_{0}\\right)-2 f\\left(x_{1}\\right) \\\\ b &amp;=3 f\\left(x_{1}\\right)-3 f\\left(x_{0}\\right)-2 f^{\\prime}\\left(x_{0}\\right)-f^{\\prime}\\left(x_{1}\\right) \\\\ c &amp;=f^{\\prime}\\left(x_{0}\\right) \\\\ d &amp;=f\\left(x_{0}\\right) \\end{aligned}abcd​=f′(x0​)+f′(x1​)+2f(x0​)−2f(x1​)=3f(x1​)−3f(x0​)−2f′(x0​)−f′(x1​)=f′(x0​)=f(x0​)​ 然而一个不可忽视的现实情况是：BSDF 的导数常常不能直接得到，因此我们需要用离散的差值去逼近它： f′(xi)≈f(xi+1)−f(xi−1)xi+1−xi−1f&#x27;(x_i) \\approx {f(x_{i+1}) - f(x_{i-1}) \\over x_{i+1} - x_{i-1}} f′(xi​)≈xi+1​−xi−1​f(xi+1​)−f(xi−1​)​ 使用此不等式带入之前的方程即可得到： p(x)=w0f(x−1)+w1f(x0)+w2f(x1)+w3f(x2)\\quad p(x)=w_{0} f\\left(x_{-1}\\right)+w_{1} f\\left(x_{0}\\right)+w_{2} f\\left(x_{1}\\right)+w_{3} f\\left(x_{2}\\right) p(x)=w0​f(x−1​)+w1​f(x0​)+w2​f(x1​)+w3​f(x2​) 其中： w0=x3−2x2+xx−1−1w1=2x3−3x2+1−x3−x2x2=(2x3−3x2+1)−w3w2=−2x3+3x2+x3−2x2+x1−x−1=(−2x3+3x2)−w0w3=x3−x2x2\\begin{aligned} &amp;w_{0}=\\frac{x^{3}-2 x^{2}+x}{x_{-1}-1} \\\\ &amp;w_{1}=2 x^{3}-3 x^{2}+1-\\frac{x^{3}-x^{2}}{x_{2}}=\\left(2 x^{3}-3 x^{2}+1\\right)-w_{3} \\\\ &amp;w_{2}=-2 x^{3}+3 x^{2}+\\frac{x^{3}-2 x^{2}+x}{1-x_{-1}}=\\left(-2 x^{3}+3 x^{2}\\right)-w_{0} \\\\ &amp;w_{3}=\\frac{x^{3}-x^{2}}{x_{2}} \\end{aligned}​w0​=x−1​−1x3−2x2+x​w1​=2x3−3x2+1−x2​x3−x2​=(2x3−3x2+1)−w3​w2​=−2x3+3x2+1−x−1​x3−2x2+x​=(−2x3+3x2)−w0​w3​=x2​x3−x2​​ 需要注意的是，当使用这种方法进行插值的时候，可能会在边界情况下出现超出范围的参数访问，此时 PBRT 会将对应的权重设为 0 以避免这些影响。","categories":[{"name":"programming","slug":"programming","permalink":"https://blog.apassbydreg.work/categories/programming/"},{"name":"reading notes","slug":"programming/reading-notes","permalink":"https://blog.apassbydreg.work/categories/programming/reading-notes/"}],"tags":[{"name":"CG","slug":"CG","permalink":"https://blog.apassbydreg.work/tags/CG/"},{"name":"render","slug":"render","permalink":"https://blog.apassbydreg.work/tags/render/"},{"name":"PBRT","slug":"PBRT","permalink":"https://blog.apassbydreg.work/tags/PBRT/"}]},{"title":"《深度探索C++对象模型》笔记合集 | Notes Collection for Inside Cpp Object Model","slug":"InsideCppObjectModel-Archive","date":"2021-11-17T17:31:01.000Z","updated":"2021-11-17T17:59:31.352Z","comments":true,"path":"2021/11/InsideCppObjectModel-Archive/","link":"","permalink":"https://blog.apassbydreg.work/2021/11/InsideCppObjectModel-Archive/","excerpt":"","text":"终于完整地读完了一整本书，这里做个合集整理一下方便跳转： 章节目录 第一章：关于对象（Object Lessons） 第二章：构造函数语义学（The Semantics of Constructors） 第三章：数据语义学（The Semantics of Data） 第四章：函数语义学（The Semantics of Functions） 第五章：构造、析构、拷贝语义学（Semantics of Construction, Destruction and Copy） 第六章：执行期语义学（Runtime Semantics） 第七章：站在对象模型的尖端（On the Cusp of the Object Model） 原书 PDF 下载链接","categories":[{"name":"programming","slug":"programming","permalink":"https://blog.apassbydreg.work/categories/programming/"},{"name":"reading notes","slug":"programming/reading-notes","permalink":"https://blog.apassbydreg.work/categories/programming/reading-notes/"}],"tags":[{"name":"OOP","slug":"OOP","permalink":"https://blog.apassbydreg.work/tags/OOP/"},{"name":"C++","slug":"C","permalink":"https://blog.apassbydreg.work/tags/C/"},{"name":"深度探索C++对象模型","slug":"深度探索C-对象模型","permalink":"https://blog.apassbydreg.work/tags/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"}]},{"title":"《深度探索C++对象模型》第七章笔记 | Notes for Inside Cpp Object Model Chapter 07","slug":"InsideCppObjectModel-ch07","date":"2021-11-17T09:03:18.000Z","updated":"2021-11-17T17:39:57.770Z","comments":true,"path":"2021/11/InsideCppObjectModel-ch07/","link":"","permalink":"https://blog.apassbydreg.work/2021/11/InsideCppObjectModel-ch07/","excerpt":"","text":"本章中讨论了三个著名的 C++ 语言扩充性质：template、exception handling (EH) 和 runtime type identification (RTTI) 7.1 Template C++ 程序设计的风格自 cfront 3.0 中引入 template 开始就发生了深远的变化，这一功能本来是对 container classes 的一项支持，但它如今已经成为了通用程序设计的基础、用于属性混合、互斥机制等多处的参数化技术中。 Template 的实例化 在 C++ 中，任何一个 class object 的定义（不包括指针），无论是编译器内部使用的临时对象还是用户定义的对象都会导致 template class 的实例化。然而，template class 中的内容必须要与一个实例化的类型绑定，如下例： 12345678template &lt;class T&gt;Class Sample&#123;public: enum Status &#123;stat1, stat2&#125; static int val; void foo(T bar);&#125;; 虽然该类中的 Status 枚举类和静态变量并不需要与任何类型参数绑定，但它仍然需要通过某个类型的实体才能访问，这将不得不产生多余的实体，即： 123Sample::Status e; // 错误的访问方法Sample&lt;int&gt;::Status x; // 必须这样使用Sample&lt;float&gt;::Status y; // 和上一行不同的实体 实例化的另一个特性是：只实例化需要使用的成员函数（虽然当前的编译器并不都遵循这项要求）。 对于不同的类型标识符，模板在实例化时可能会出现不同的结果。对于基础操作符，如一些系统中即使 int 和 long 是等价的，但 Sample&lt;int&gt;::val 和 Sample&lt;long&gt;::val 产生的是两个不同的实体。但如 size_t 和 unsigned long long 这种使用 typedef 或者宏定义别名的类型却只会产生一种实体。但这只是一种行业默认的做法，并未在 C++ 标准中有明确的强制规定。 Template 的错误信息 考虑一个具有很多错得离谱的类型声明： 1234567891011template &lt;class T&gt;class Sample&#123;public$ Sample(T t = 1024) : _t(t) &#123; if (tt != t) throw ex ex; &#125;private: T tt;&#125; 这里面隐藏了许多需要在模板类实例化后才能检测出的问题，包括了： L5 中是否可以使用 1024 赋值给一个 T 类型的对象 L7 中 T 类型是否定义了 operator!= 这些问题在 nontemplate class 的声明中可以很轻易地在编译期就被找到。但对于 template class ，他们必须在每个实例化发生之后才能被检测出来。如 Sample&lt;int&gt; 中上两行的写法是合法的，而在 Sample&lt;int *&gt; 中则是非法的。 在处理 template 的声明时，只有语汇（lexing）错误和解析（parsing）错误会被找到，而类型检查需要在每一个实例化发生时才会发生。对于上一节例中的函数声明，即使下面这个写法错得离谱，只要没有被实例化（对于函数而言，直到函数被使用时才被实例化），那么它在各个编译器的编译过程中均不会报错。 1234template &lt;class T&gt; void T1&lt;T&gt;::foo(T bar)&#123; this-&gt;xxx = 0; // xxx 不是上述类中的 data member&#125; Template 中的名称决议（Name Resolution） 在模板中的函数类型确认同样也被推迟到了实例化发生的地点。编译器会从实例化发生时的语境中选择最适合模板类中的函数的具名函数链接到对于语句上，而并非只考虑在 template 定义时的语境。 这一部分里面的内容和我的试验结果有差异，在 clang 和 msvc 上与书中结果相同，但在 gcc 上不同。测试中使用的代码如下： 1234567891011121314151617181920212223242526/* main.cpp */#include &quot;common.h&quot;using namespace std;void foo(float v) &#123; cout &lt;&lt; &quot;float foo&quot; &lt;&lt; endl; &#125;Sample&lt;float&gt; obj;int main(int argc, char const *argv[])&#123; obj.intCall(); obj.typeCall(); return 0;&#125;/* common.h */#pragma once#include &lt;iostream&gt;using namespace std;void foo(int v) &#123; cout &lt;&lt; &quot;int foo&quot; &lt;&lt; endl; &#125;template &lt;class T&gt; class Sample&#123;public: void intCall() &#123; foo(v1); &#125; T typeCall() &#123; foo(v2); &#125;private: int v1; T v2;&#125;; 上述代码在 clang 和 msvc 会分别调用 int foo 和 float foo，而在 gcc 上却只调用 int foo Member Functions 的实例化 为了实现对模板函数的支持，编译器的设计者需要考虑以下三个主要问题： 编译器如何找出函数的定义？ 其中一种解决方法是要求一个文件命名规则，如在 Example.h 中声明的模板函数的函数体必须在对应的 Example.c 或 Example.cpp 中定义。 编译器如何只实例化程序中用到的函数？ 目前的实现方法主要是两种，一是无视这一需求实例化所有可能用到的函数，另一种是在编译期间进行仿真链接操作以找到可能用到的函数。 编译器如何阻止同一个 member function 在多个 .o 文件中被实例化？ 这一问题的解决方法和上一个类似，要么忽略它转而在链接过程中完成去重的过程，要么在编译期间利用仿真链接操作去重。 上述这些问题与相应的解决方案都会造成编译时间的大量增加。为了解决这一问题，Edison Design Group 开发了一套第二代的 directed-instantiation 机制，其主要过程为： 在编译期间不会产生任何 template 实体，只将相关信息储存在 object files 中 在连接前使用 prelinker 检查 object files 以寻找 template 实体的相互参考和定义 对于每个有 template 实体参考但是找不到定义的情况，将必要的程序实例化操作指定给对应的文件，并注册在 .ii 文件中 prelinker 重新执行编译器以重新编译每一个 .ii 文件发生了变化的文件 重复上述过程知道所有必要的实例化操作完成，最后执行链接器产生可执行文件 但这也并不能完美地解决问题，在实现层面上，这似乎是 template 实例化所带来的对自动化和效率的一大瓶颈。当程序十分复杂且巨大的话，在个别的位置手动完成预先实例化的操作仍然是唯一的有效率的方法。 7.2 异常处理（Error Handling） 为了支持 EH ，编译器的主要工作就是找到 catch 语句以处理被抛出的 exception 。这需要跟踪程序堆栈中每个函数的作用域、并提供查询 exception object 类型的方法。最后，编译器还需要某种机制以管理被抛出的 exception object 。 Exception Handling 的结构 C++ 中的 exception handling 主要有三个语汇组件构成： 一个 try 区段以包裹一系列语句，这些语句可能会抛出异常 一个 throw 子句，它在程序中的某个位置发出 exception 至少一个 catch 子句以处理不同类型的 exception 当一个 exception 被抛出时，在找到对应的 catch 子句前，堆栈中的每个函数调用都会被 pop 出去，并在离开前调用所有 local objects 的析构函数。如果没有找到符合的 catch 语句，默认的 terminate() 处理方法就会被调用结束程序。 1234567void example()&#123; foo(); SomeClass object = 0; bar(); return;&#125; EH 的引入需要程序记录更多的执行期语句，如上述函数片段中的两次函数调用的位置具有了不同的执行期语义：后者在退出前需要调用 object 的析构函数。这种信息的记录通常使用一个储存了需要析构的对象的链表实现。 EH 带来的另一问题是，如果 exception 在某些关键操作（如共享内存的上锁与解锁）之间发生，可能会造成资源的错误配置。这种时候一个最明确的方式就是对资源申请后直到释放前的使用额外的 try catch 保护。或者也可以将资源的申请和释放包裹在 class 的 constructor 和 destructor 中，这样就可以让程序在退出函数时自动释放已经申请的资源了。 Exception Handling 的支持 当一个 exception 发生时，编译系统需要完成以下事情： 检查发生 throw 的函数 确定 throw 是否发生在 try 中，这通常可以通过比较当前的程序计数器（pc）和编译时得到的 try 区段表得到 如果在 try 中，则需要将 exception type 和每个 catch 比对类型，如果比对吻合则将流程控制交给 catch 字句中 如果不在 try 中或没有符合的 catch 语句，则： 析构所有的 active local objects 从堆栈中将当前函数 unwind 出取 进入堆栈中的下一个函数中，重复以上 2 - 4 步 当一个 exception 被抛出时，一个 exception object 会被产生并放置在对应的数据堆栈中。这个对象的地址和其类型描述器（或提供类型描述器的函数）会被传给 catch 字句。 在 exeption handling 的 catch 部分中依旧支持虚拟机制。在以下的例子中的表现和将一个 object 传入与 catch 对应的函数非常类似： 123456789101112try&#123; throw Derived(); &#125;catch (Base e)&#123; // 这个区段中使用的 e 发生了裁切，丢失了派生类的内容 throw; // 在不指定 exception 抛出时，实际抛出的是原始的派生类型，之前的修改都会被抛弃&#125;// 或者可以使用引用catch (Base &amp;e)&#123; // 在这个区段中虚拟机制在起作用&#125; Exception Handling 的代价 程序文件大小的差异 编译器 无EH 有EH 增加的百分比 Borland 86822 89510 3% Microsoft 60146 67071 13% Symantec 69786 74826 8% 程序运行时间的差异 编译器 无EH 有EH 增加的百分比 Borland 78s 83s 6% Microsoft 83s 87s 5% Symantec 94s 96s 4% 7.3 执行期类型识别（RTTI） 由于真正的 exception 是在执行期被处理的，其 object 必须带有自己的类型信息。Runtime Type Identification (RTTI) 便是支持这一特性所获得的副产物。这一功能用于在程序中实现安全的 downcast 或 dynamic cast 。 类型安全的 downcast 只有在类型可以被适当转型的情况下才能执行 downcast 。一个类型安全的 downcast 必须在执行期查看指针或引用所指的对象的真正类型，这需要额外的空间储存类型信息和额外的时间决定执行期的类型。 C++ 的 RTTI 机制提供一个安全的 downcast 操作，但这种机制只对使用了继承和动态绑定的类型有效。为了让编译器分辨这些类型，编译器通常使用的策略是经由声明一个或多个 virtual function 以区分 class 声明。更进一步的，通常会直接将类型对应的 RTTI object 的指针放入 vtbl 之中。 类型安全的 dynamic cast dynamic_cast 运算符可以在执行期决定真正的类型。如果这个 downcast 是安全的，运算符就会返回被转型后的指针，否则就返回空指针。这通常是利用上述在 vtbl 中插入的 type_info 类型描述器完成的。 Reference 和 Pointer 的区别 当 dynamic_cast 应用与指针上时，它可以返回一个 0 值以表示这个转换是不安全的，但一个引用并不能指向一个空对象。因此，当 dynamic_cast 被施加于一个引用上时，会发生以下的事情： 如果 downcast 是安全的，它会被正常地执行 如果 downcast 是不安全的，那么它会抛出一个 bad_cast exception typeid 运算符 无论是静态地对实体或类型使用，还是在运行期动态地对指针或引用使用 typeid 运算符就可以得到对应类型的 type_info 的一个 const reference。 对于每一个描述块，编译器需要提供的最小信息包括了比较函数与 class 的真实名称。C++ Standard 中定义的类型如下： 1234567891011class type_info &#123;public: virtual ~type_info(); constexpr bool operator==(const type_info&amp; rhs) const noexcept; bool before(const type_info&amp; rhs) const noexcept; size_t hash_code() const noexcept; const char* name() const noexcept; type_info(const type_info&amp;) = delete; // cannot be copied type_info&amp; operator=(const type_info&amp;) = delete; // cannot be copied&#125;; RTTI 不仅仅适用于用户定义的类型，它还适用于一些基础的类型。你同样可以通过 typeid(int) 取得 int 类型的描述块。 7.4 效率和弹性 传统的 C++ 对象模型提供了较为高效的执行期支持。这种效率加上与 C 的兼容性保证了 C++ 的广泛接受度。然而，在动态函数库（Dynamic Shared Libraries）、共享内存（Shared Memory）以及分布式对象（Distributed Object）方面，这个对象模型的弹性还是不够。 动态函数库（Dynamic Shared Libraries） 理想上，一个动态链接的 shared library 的调用应该是透明的，已经链入的动态库的版本改变不应该对旧有的应用程序产生影响。然而在 C++ 的对象布局中，如果新版库中的 class object 的布局有所改变，那么对应的 member 偏移量也会变化，最后导致整个应用程序需要重新编译。 共享内存（Shared Memory） 当一个共享库被加载时，它在内存中的位置由 runtime linker 决定，一般而言与执行中的进程无关。然而当它之中包含了一个需要支持在共享内存中的虚函数的 class object 时，对与其它的进程而言，除非这个动态函数库被放置于完全相同的内存位置上，要不然就会产生严重的虚函数调用问题。这是因为虚函数在 vtbl 中的位置以及被写死了。 这一切问题的出现都主要是因为 C++ 对象模型对高效性和 C 兼容性的坚持带来的的包袱。但这也正是 C++ 广泛的适用性的来源。","categories":[{"name":"programming","slug":"programming","permalink":"https://blog.apassbydreg.work/categories/programming/"},{"name":"reading notes","slug":"programming/reading-notes","permalink":"https://blog.apassbydreg.work/categories/programming/reading-notes/"}],"tags":[{"name":"OOP","slug":"OOP","permalink":"https://blog.apassbydreg.work/tags/OOP/"},{"name":"C++","slug":"C","permalink":"https://blog.apassbydreg.work/tags/C/"},{"name":"深度探索C++对象模型","slug":"深度探索C-对象模型","permalink":"https://blog.apassbydreg.work/tags/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"}]},{"title":"PBRT 第七章笔记（基础篇） | Notes for PBRT Chapter 07 - Sampling and Reconstruction (basis)","slug":"PBRT-ch07","date":"2021-11-15T13:53:39.000Z","updated":"2022-02-15T09:41:41.309Z","comments":true,"path":"2021/11/PBRT-ch07/","link":"","permalink":"https://blog.apassbydreg.work/2021/11/PBRT-ch07/","excerpt":"","text":"7.1 Sampling Theory 一个数字图像一般使用一个矩形区域的离散位置的颜色值表示。由于这些离散的值是从一个连续的区域中采样重建得到的，因此一般需要额外注意走样（aliasing）的问题。 另一个需要注意的是，数字图像中的像素一般指的是图像连续函数在某一位置的值，而显示像素则表示了以某种分布发光的某种物理实体。 7.1.1 频域和傅里叶变换 为了评估重建的函数和原图像函数的区别，一般会使用傅里叶分析的方法。傅里叶变换将时空上的函数转换到频域上。傅里叶变换和反变换的公式分别如下： F(ω)=∫−∞∞f(x)e−i2πωxdxf(x)=∫−∞∞F(ω)ei2πωωdωF(\\omega) = \\int_{-\\infty}^\\infty f(x)e^{-i2\\pi\\omega x}\\mathrm{d}x\\\\ f(x) = \\int_{-\\infty}^\\infty F(\\omega)e^{i2\\pi\\omega \\omega}\\mathrm{d}\\omega F(ω)=∫−∞∞​f(x)e−i2πωxdxf(x)=∫−∞∞​F(ω)ei2πωωdω 7.1.2 理想的采样与重建 首先定义冲击采样函数： IIIT(x)=T∑i=−∞+∞δ(x−iT){III}_T(x) = T\\sum_{i=-\\infty}^{+\\infty}\\delta(x - iT) IIIT​(x)=Ti=−∞∑+∞​δ(x−iT) 其中 δ(x)\\delta(x)δ(x) 是单位冲击函数。上述的函数实际上描述了在空间中等间距分布的一群冲激函数。将这个函数与图像函数 fff 相乘就可以得到理想的采样值。最后，使用一个重建的核函数 r(x)r(x)r(x) 与前述采样值做卷积操作即可得到重建的结果： f~=(IIIT(x)f(x))⊛r(x)=T∑i=−∞+∞f(iT)r(x−iT)\\tilde{f} = (III_T(x)f(x)) \\circledast r(x) = T\\sum_{i=-\\infty}^{+\\infty}f(iT)r(x-iT) f~​=(IIIT​(x)f(x))⊛r(x)=Ti=−∞∑+∞​f(iT)r(x−iT) 下图展示了一个函数经过 T=1T=1T=1 的采样和三角重建核函数重建后的结果： 在理想状态下，如果原始图像函数 fff 是有可数的多个频率构成的，如一系列有最小宽度的矩形函数。在这种情况下，可以利用傅里叶正反变换的性质得到对应的采样结果函数的。 7.1.3 走样 对于由数量极多，甚至无限种频率构成的图像函数，我们常常不能得到完全准确的采样结果。在这种情况下，重建产生的偏差就形成了走样现象。 7.1.4 反走样技术 非均匀采样：用于采样的位置会在均匀采样的基础上做出大小不一的随机偏移。这种技术将走样现象转化为噪声，从而减少视觉上的怪异感。 适应性超采样：当某一区域的信号复杂度较高时，可以适应性地增加采样率，从而在较少的性能消耗换取更好的重建表现。 预滤波：在采样前先使用某种方式（如模糊滤波）去除目标函数中高频的部分 7.1.5 采样与图像合成 图像合成的过程实际上就是在一个二维的函数 f(x,y)=Lf(x,y) = Lf(x,y)=L 上进行采样。然而，一般的渲染器比较难以直接对目标函数进行预滤波，所以实现上一般使用超采样和随机采样结合的方法减少走样现象。 7.1.6 渲染中的走样因素 几何体的边缘和阴影是走样的最重要的贡献因素，它在亮度空间上形成了一个阶跃函数——这是一类无法用有限的频率描述的无限维特征。 极小的物体也会造成走样：当一个物体体积小到比两次采样的间距还小时，它可能在屏幕上反复出现和消失。 物体的材质和贴图也会引入高频信息，从而造成走样。 7.2 Sampling Interface 所有的采样器均继承于同一个抽象接口。它的工作是从 [0,1)n\\left[0,1\\right)^n[0,1)n 空间中生成一系列 n 维的采样，其中的每个采样向量被用于一次图像的采样，而具体采样的维度数量则取决于不同的需求。取得的采样向量通常有以下特征： 前五位会被相机使用，包括两位 subpixel jitter ，一位时间和两位透镜 uv 位置。 更加细致地设计的算法通常会生成更好的采样结果，在向量中，一般更好的采样结果会在更前面 7.2.1 评估采样结果 ⚠️ 这部分内容描述了如何评价一组采样的好坏，恕我以后再看。 7.2.2 基础的 Sampler 接口 这个接口的定义如下： 1234567891011121314151617181920212223242526272829303132333435363738class Sampler &#123; public: // Sampler Interface virtual ~Sampler(); Sampler(int64_t samplesPerPixel); virtual void StartPixel(const Point2i &amp;p); virtual Float Get1D() = 0; virtual Point2f Get2D() = 0; CameraSample GetCameraSample(const Point2i &amp;pRaster); void Request1DArray(int n); void Request2DArray(int n); virtual int RoundCount(int n) const &#123; return n; &#125; const Float *Get1DArray(int n); const Point2f *Get2DArray(int n); virtual bool StartNextSample(); virtual std::unique_ptr&lt;Sampler&gt; Clone(int seed) = 0; virtual bool SetSampleNumber(int64_t sampleNum); std::string StateString() const &#123; return StringPrintf(&quot;(%d,%d), sample %&quot; PRId64, currentPixel.x, currentPixel.y, currentPixelSampleIndex); &#125; int64_t CurrentSampleNumber() const &#123; return currentPixelSampleIndex; &#125; // Sampler Public Data const int64_t samplesPerPixel; protected: // Sampler Protected Data Point2i currentPixel; int64_t currentPixelSampleIndex; std::vector&lt;int&gt; samples1DArraySizes, samples2DArraySizes; std::vector&lt;std::vector&lt;Float&gt;&gt; sampleArray1D; std::vector&lt;std::vector&lt;Point2f&gt;&gt; sampleArray2D; private: // Sampler Private Data size_t array1DOffset, array2DOffset;&#125;; 在构建采样器时，需要传入每个像素采样的最大次数 samplesPerPixel 。紧接着，当渲染器需要对某一像素进行评估时，它会将该像素位置传入本接口的 StartPixel 函数以初始化随机状态。紧接着就可以使用 Get1D 等方法获取接下来的一个或者数个不同维度的采样结果，需要注意的是，如果在渲染中需要一次性获取多个维度的，需要在渲染开始前就首先调用 Request[12]DArray 接口以告知该需求。最后，使用 StartNextSample 方法结束本轮采用，下一轮采样将会从头开始。 7.2.4 Pixel Sampler 接口 这个接口在 Sampler 接口的基础上增加了有关 12345678910111213141516class PixelSampler : public Sampler &#123; public: // PixelSampler Public Methods PixelSampler(int64_t samplesPerPixel, int nSampledDimensions); bool StartNextSample(); bool SetSampleNumber(int64_t); Float Get1D(); Point2f Get2D(); protected: // PixelSampler Protected Data std::vector&lt;std::vector&lt;Float&gt;&gt; samples1D; std::vector&lt;std::vector&lt;Point2f&gt;&gt; samples2D; int current1DDimension = 0, current2DDimension = 0; RNG rng;&#125;; 这种采样器一次性生成所有的样本，由于渲染过程中需要的采样次数并不能提前确定，它需要一个最大的采样数目。当需要的数目超过该值时，这类采样器只会返回 uniform 的采样结果。 对于每个预生成的维度，这种采样器会生成两组大小为 nSampledDimensions * samplesPerPixel 的一维、二维采样序列。在使用时，对于同一个 sample index ，从头开始读取预计算的值，并在改变 sample index 或开始新采样时重设维度偏移量。 7.2.4 Global Sampler 接口 在实际实现中，一些并不基于像素的采样器会连续地生成分布在整个空间中的采样结果，每一次采样结果都可能会代表不同的像素。对于多线程分片渲染而言，这种采样方法是有必要的。GlobalSampler 为这种需求抽象出了一个接口，它将 Sampler 接口封装为两个最主要的虚函数： GetIndexForSample ：实现从采样到实际像素位置的重映射 SampleDimension ：采样给定序号下的给定维度 7.3 Stratified Sampling 分层采样的核心是将像素切分为不重叠的更小的子区域，并从每个子区域中获取一个样本。这种方法通常通过在每个子区域内做随机偏移以将走样转化为噪声，但它也提供了无偏的模式以供参考。 分层抽样的最大问题在于，当采样的维度增加时，需要的采样数量会以指数级别膨胀，这种情况被称为维数灾难。其中一种缓解方法在于独立地为各个维度生成采样，然后随机地将这些采样关联起来，如下例中从三个位置分别取了 4 个采样共 12 此采样，接着使用随机关联的方式将其联系成四组不同的采样，进而得到收敛上较为优秀的采样结果。 1234567891011121314151617class StratifiedSampler : public PixelSampler &#123; public: // StratifiedSampler Public Methods StratifiedSampler(int xPixelSamples, int yPixelSamples, bool jitterSamples, int nSampledDimensions) : PixelSampler(xPixelSamples * yPixelSamples, nSampledDimensions), xPixelSamples(xPixelSamples), yPixelSamples(yPixelSamples), jitterSamples(jitterSamples) &#123;&#125; void StartPixel(const Point2i &amp;); std::unique_ptr&lt;Sampler&gt; Clone(int seed); private: // StratifiedSampler Private Data const int xPixelSamples, yPixelSamples; const bool jitterSamples;&#125;; 由于对一个空间的采样次数有时可能并不能被分割到一组合理的阵列中，本类中使用了 Latin Hypercube Sampling (LHS) 技术从任意多的采样个数中获得均匀分布的样本。其做法是：将空间的每一个维度分割为等量维度（通常是是样本数）、接着随机交换不同维度中的顺序，从而可以生成优秀的采样结果。 LHS 在采样数目较小时可以生成较为优秀的分布，但当采样数量增加时，它的效果会越来越差，并不如原始的 stratified sampling 方法。 7.4 The Halton Sampler ⚠️ 这部分说明了一种特别的采样方式，待我以后再看。 7.5 (0, 2)-Sequence Sampler ⚠️ 这部分说明了一种特别的采样方式，待我以后再看。 7.6 Maximized Minimal Distance Sampler ⚠️ 这部分说明了一种特别的采样方式，待我以后再看。 7.7 Sobol’ Sampler ⚠️ 这部分说明了一种特别的采样方式，待我以后再看。 7.8 Image Reconstruction 给定一系列样本和它们的 radiance ，我们需要将它转换为像素值。这中间有三个流程： 从样本重建一个连续的图像函数 L~\\tilde{L}L~ 对该重建函数做一次滤波以去除任何超过了像素空间中纳什限制的频率 在像素的位置采样 L~\\tilde{L}L~ 以得到最终的像素值 实现上，为了计算一个点 (x,y)(x, y)(x,y) 处的像素值，通常会考虑和它在一定距离内的所有采样点，并使用一个二维滤波函数 f(x−xi,y−yi)f(x-x_i,y-y_i)f(x−xi​,y−yi​) 加权平均。一个考虑了每个样本的相机权重 www 的完整的公式如下： I(x,y)=∑i[f(x−xi,y−yi)w(xi,yi)L(xi,yi)]∑if(x−xi,y−yi)I(x,y) = \\frac{\\sum_i\\left[f(x-x_i,y-y_i)w(x_i,y_i)L(x_i,y_i)\\right]}{\\sum_if(x-x_i,y-y_i)} I(x,y)=∑i​f(x−xi​,y−yi​)∑i​[f(x−xi​,y−yi​)w(xi​,yi​)L(xi​,yi​)]​ 7.8.1 滤波函数 1234567891011class Filter &#123; public: // Filter Interface virtual ~Filter(); Filter(const Vector2f &amp;radius) : radius(radius), invRadius(Vector2f(1 / radius.x, 1 / radius.y)) &#123;&#125; virtual Float Evaluate(const Point2f &amp;p) const = 0; // Filter Public Data const Vector2f radius, invRadius;&#125;; 代表滤波函数的接口内容包括一个 Evaluate 虚函数和代表截止半径的一个值，任何超过截止半径的输入均会返回零。 Box Filter 简单的阶梯函数，代表在截止半径内的所有样本权重都一样 Triangle Filter 比 BoxFilter 稍微复杂一点，用简单的直线表示越边缘的样本权值越低 Gaussian Filter 使用高斯函数表示样本对中心的贡献值。这种滤波方式与其它相比会对图像带来少量的模糊，但这些模糊也可以帮助减少走样的视觉影响。 在实际实现中，高斯函数被建模为以下形式： f(x,y)=max⁡(0,e−αx2−e−αrx2)⋅max⁡(0,e−αy2−e−αry2)f(x,y) = \\max(0, e^{-\\alpha x^2} - e^{-\\alpha r_x^2}) \\cdot \\max(0, e^{-\\alpha y^2} - e^{-\\alpha r_y^2}) f(x,y)=max(0,e−αx2−e−αrx2​)⋅max(0,e−αy2−e−αry2​) Mitchell Filter 为了平衡滤波中的模糊和幻影问题，Mitchell 和 Netravali 发明了一种参数化的滤波函数。这种函数的特别之处在于在接近截止位置边缘的地方它的权值是负的，这一特性使得它可以在图像中的边缘位置获得更加锐利的结果。 一维的 Mitchell 函数表达式如下，它由两个参数调控，并且需要保证 C0,C1C^0,C^1C0,C1 连续性： f(x)=16×{(12−9B−6C)∣x∣3+(−18+12B+6C)∣x∣2+(6−2B)∣x∣&lt;1(−B−6C)∣x∣3+(6B+30C)∣x∣2+(−12B−48C)∣x∣+(8B+24C)1≤∣x∣&lt;20 otherwise. f(x) = \\frac{1}{6} \\times \\begin{cases}(12-9 B-6 C)|x|^{3}+(-18+12 B+6 C)|x|^{2}+(6-2 B) &amp; |x|&lt;1 \\\\ (-B-6 C)|x|^{3}+(6 B+30 C)|x|^{2}+(-12 B-48 C)|x|+(8 B+24 C) &amp; 1 \\leq|x|&lt;2 \\\\ 0 &amp; \\text { otherwise. }\\end{cases} f(x)=61​×⎩⎪⎨⎪⎧​(12−9B−6C)∣x∣3+(−18+12B+6C)∣x∣2+(6−2B)(−B−6C)∣x∣3+(6B+30C)∣x∣2+(−12B−48C)∣x∣+(8B+24C)0​∣x∣&lt;11≤∣x∣&lt;2 otherwise. ​ 最终的求值函数如下： 123Float MitchellFilter::Evaluate(const Point2f &amp;p) const &#123; return Mitchell1D(p.x * invRadius.x) * Mitchell1D(p.y * invRadius.y);&#125; Windowed Sinc Filter Windowed Sinc 函数（下图蓝线）实际上是一个 sin⁡\\sinsin 函数与一个窗口函数相乘的滤波函数，其中一种窗口函数 Lanczos Window 其实就是另一个缩放到区域上的 sin⁡\\sinsin 函数（如下图黄线），其表达式为： w(x)=sin⁡(πx/τ)πx/τw(x) = {\\sin(\\pi x / \\tau) \\over \\pi x / \\tau} w(x)=πx/τsin(πx/τ)​ 7.9 Film and the Imaging Pipeline 在 PBRT 中，Film 类型建模了模拟相机的接收设备。在得到了每个光线样本的 radiance 后，它负责确定各个光线对成像平面上的各个像素的贡献。这个类同样在渲染流程结束后负责将最终图像储存到图片中。 7.9.1 Pixel 和 Film 类 一张图像是由数个像素构成的，一个 Pixel 结构体中包含了这一像素中的 XYZ 颜色值（加权和）、滤波权值之和、一个不加权的样本面元 XYZ 颜色值之和，以及一个用于将结构体大小对齐至整数个 cache line 大小的 pad 元素。 在构建 Film 实例时，需要传入的内容包括： 图像分辨率与着色剪切区域（这二者会用于计算生成对应数量的 pixel 数组） 滤波函数指针，感受器的物理大小 储存的文件名与储存时数据的缩放比例 由于在对光线进行滤波的时候每次都计算对应位置的滤波函数值会带来很大的消耗，在本类的构造函数中同样会初始化一个储存了预计算的滤波值的表。 7.9.2 将像素值传入 Film 实例 Film 类型定义了一个用于给不同线程提供部分的区域进行渲染的方法。各个线程会将像素值首先写入对应的 FilmTile 代表的区块中，并在结束后统一合并至 Film 中。具体流程为： 渲染前，每个线程会使用自身的渲染区域、结合滤波函数的截止宽度使用 Film::GetFilmTile 确定一块临时的图像区域 渲染中，使用 FilmTile::AddSample 向这个线程中的图像子区域写入像素的 radiance 值，这个函数完成滤波的步骤 渲染后，使用 Film::MergeFilmTile 将子区域合并入最终结果中。 一些光线传输方法（如 BDPT ）需要将一个样本的贡献不经加权地分摊到任意的像素点上。因此 Film 中也提供了可供多线程共享访问的 Pixel::splatXYZ 和 Film::AddSplat 方法以供这些算法操作。 7.9.3 输出图像 在主渲染流程结束后，Integrator 中的渲染函数就会调用 Film::WriteImage 方法。这个方法主要包括两个部分： 将图像转换为 RGB 颜色空间并计算最终的颜色值，具体而言，对于每个像素有： 将 XYZ 颜色转换为 RGB 颜色 使用权值和归一化颜色值 将 splat 信息转换颜色空间并使用参数 splatScale 累积到 RGB 颜色中 使用 scale 值缩放颜色值 将图像写入文件","categories":[{"name":"programming","slug":"programming","permalink":"https://blog.apassbydreg.work/categories/programming/"},{"name":"reading notes","slug":"programming/reading-notes","permalink":"https://blog.apassbydreg.work/categories/programming/reading-notes/"}],"tags":[{"name":"CG","slug":"CG","permalink":"https://blog.apassbydreg.work/tags/CG/"},{"name":"render","slug":"render","permalink":"https://blog.apassbydreg.work/tags/render/"},{"name":"PBRT","slug":"PBRT","permalink":"https://blog.apassbydreg.work/tags/PBRT/"}]},{"title":"《深度探索C++对象模型》第六章笔记 | Notes for Inside Cpp Object Model Chapter 06","slug":"InsideCppObjectModel-ch06","date":"2021-11-13T17:33:09.000Z","updated":"2021-11-17T17:39:57.770Z","comments":true,"path":"2021/11/InsideCppObjectModel-ch06/","link":"","permalink":"https://blog.apassbydreg.work/2021/11/InsideCppObjectModel-ch06/","excerpt":"","text":"本章中将会讨论在执行中程序员书写的表达式会发生的一些转换，讨论包括临时对象等问题。 6.1 对象的构建和析构 常规对象 常规对象（主要是代码段中声明并使用的对象）的构建发生在对象被声明出来的地方，而析构则发生在区段的退出位置前。如果一个区段有多个退出位置，则会发生在每个退出位置前。在这种情况下，通过将 object 尽可能的声明在使用它的区间附近可以节省不必要的对象构建和解构操作。 全局静态对象 对于全局静态对象，它们均储存在程序的 data segment 中，C++ 保证会在它们第一次被使用前被构造，并在程序结束前将其析构。一般称这种操作为静态的初始化和内存释放。对于使用表达式初始化的静态变量，一般的解决方案是： 对所有文件中的全局变量生成 __sti_filename_variablename() 函数用于使用表达式初始化它们 对所有文件中的全局变量生成 __std_filename_variablename() 函数用于析构它们 将所有 __sti, __std 函数分别放入两个集合函数中，并在 main 函数的开始和退出位置插入集合函数的调用 局部静态对象 这类对象包括类中的静态对象等。由于它们并不一定会在程序运行中被用到，一般只在它们被使用前才被构建，而其析构则发生在对应的 __std_xxx 函数中。 对象数组 对于这类对象的处理取决于这些对象的类型中的构造函数和析构函数的实现情况。如果该类型没有实现任何构造函数和析构函数，那么就直接申请内存即可，并不需要进行额外的操作。对于其他的情况，编译器通常会合成一个用于初始化的函数，形如： 1234567void* vec_new ( void *array, size_t elem_size, int elem_cont, void (*constructor)(void*), void (*destructor)(void*, char)); 特别地，当需要申请的是不记名数组的位置（如使用 new 运算符的情况），则传入的 array 地址就会设为 0 ，由函数在堆上动态分配内存。其它参数则指定了每个元素的大小、元素的数量、需要运行在每个元素上的构造函数以及出现错误时需要运行的析构函数。同样地会有相应的删除对象数组的函数被合成出来： 123456void* vec_delete ( void *array, size_t elem_size, int elem_cont, void (*destructor)(void*, char)); 不同编译器实现的方式不完全相同，有的编译器会使用不同的函数处理含 virtual base class 的类和不含的类，有的编译器会额外提供参数，以引导构造函数或析构函数的逻辑。 另外，当程序员显式的提供了初始化值时，被提供了初值的对象将会被单独初始化，只有剩余的对象会被传入形如上述 vec_new 的函数中。 Default Constructor 和数组 在上述使用的 vec_new 函数中的一大问题是，在运行期经由指针调用 constructor （事实上 C++ 并不支持由程序员使用指向构造函数的指针）初始化数组的一大问题是无法访问 default argument values（参数缺省值）。一种解决方案是构造一个只在数组初始化阶段使用的临时构造函数，并在该临时函数中调用使用了缺省值的构造函数。 6.2 new 和 delete 运算符 针对单一对象的语义 new 运算符实际上由两个步骤组成，包括了： 通过适当的函数实体配置需要的内存 为对象设置初始值 delete 运算符也类似，包括了： 检查是否是空指针 析构指向的对象 删除内存（如将内存标记为空闲） 特别地，语言要求每次 new 的调用均需要返回一个第一无二的指针，而且允许类似 new T[0] 的写法。在这种情况下，编译器一般会返回一个 byte 的区块。 针对数组的语义 这一部分和之前的比较类似，当需要使用构造函数初始化对象时，会使用和之前相同的接口 vec_new 申请内存并初始化，区别主要在于传入的目标指针是 NULL 值，由函数申请内存并返回地址。 一个需要注意的地方在于，当使用一个基类类型的指针传入 delete 函数以删除一个派生类时，如果没有使用 virtual 的析构函数，那么实际调用的是基类的析构函数。这个情况下很可能会造成内存的泄漏。 另一个对于数组而言的重要特性是，在使用 delete 运算符时，需要确认数组的大小以正确地释放对应的内存。这需要为指针赋予额外的信息。如配置一个额外的 word 或维护一个关联数组来将指针和数组对应。这种方式称为 cookie 。 Placement Operator new 这是一个预定义的重载的 new 运算符，通过传入一个指向内存中预分配的区块的指针，在需要的情况下将对应数量的规定类型的 constructor 应用于该段内存上。 这种操作可以将内存管理与内容初始化分离，但需要注意的是：当有重复利用内存块的需要时，应该使用对应的 Placement Operator delete 调用对应的析构函数，这会阻止系统将该块内存标记为空闲。又或者，当使用已经被同类型的object 占用的内存位置指针 new 新的内容时，编译器会自动调用对应的析构函数让出空间。 和上述针对数组的语义一样，使用已经包含其他类型的内容的内存区块初始化新内容的行为是未定义的。 6.3 临时对象 在运算中，常常会需要使用临时对象储存表达式的值等内容。一段语句是否会产生临时对象取决于编译器实现上的激进程度和该语句的上下文。C++ 标准允许编译器对于临时对象的和使用有完全的自由。 使用中，临时对象的生命周期的实现方法的不同可能带来灾难性的结果。如果一个临时对象被析构得过早，后续的调用可能会错误地引用到已被删除的地址上。下例展示了一种不合理的临时对象的使用方式： 123456789// 原始的代码String s1 = &quot;a&quot;, s2 = &quot;b&quot;;printf(&quot;%s&quot;, s1 + s2);// 合法但不正确的编译器拓展方式String temp1 = String::operator+(s1, s2);const char *temp2 = temp1.operator const char*();temp1.~String(); // 过早的析构使得上述地址无效化printf(&quot;%s&quot;, temp2); // 使用了无效的地址 因此，C++ 标准规定临时对象的析构必须是对完整表达式（包括了临时对象的最外围的表达式）求值过程中的最后一个步骤。但这无法避免形如下例的错误： 12String s1 = &quot;a&quot;, s2 = &quot;b&quot;;const char *p = s1 + s2; // 这里也指向了非法的地址 临时对象的生命规则有两个例外，包括了： 临时对象被用于作为 constructor 的参数初始化另一个对象时，在对象完成初始化前不能被析构（但这也无法避免上述无效指针的问题） 临时对象被一个 refernce 绑定时也不能在该 refernce 无效前析构对象，这一点是受 C++ 规则保护的","categories":[{"name":"programming","slug":"programming","permalink":"https://blog.apassbydreg.work/categories/programming/"},{"name":"reading notes","slug":"programming/reading-notes","permalink":"https://blog.apassbydreg.work/categories/programming/reading-notes/"}],"tags":[{"name":"OOP","slug":"OOP","permalink":"https://blog.apassbydreg.work/tags/OOP/"},{"name":"C++","slug":"C","permalink":"https://blog.apassbydreg.work/tags/C/"},{"name":"深度探索C++对象模型","slug":"深度探索C-对象模型","permalink":"https://blog.apassbydreg.work/tags/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"}]},{"title":"《深度探索C++对象模型》第五章笔记 | Notes for Inside Cpp Object Model Chapter 05","slug":"InsideCppObjectModel-ch05","date":"2021-11-08T09:44:35.000Z","updated":"2021-11-08T09:47:04.451Z","comments":true,"path":"2021/11/InsideCppObjectModel-ch05/","link":"","permalink":"https://blog.apassbydreg.work/2021/11/InsideCppObjectModel-ch05/","excerpt":"","text":"5.1 无继承情况下的对象构造 Plain Old Data (POD) A Plain Old Data Structure in C++ is an aggregate class that contains only PODS as members, has no user-defined destructor, no user-defined copy assignment operator, and no nonstatic members of pointer-to-member type. 这类数据结构是 C 兼容的，表现和 C 程序一致。 Abstract Data Type (ADT) 加入 ADT 结构之后，程序会在特定情况下调用给定的构造、析构函数。虽然这带来了微小的性能损失，但在工程上带来的好处常常更大。 为继承做准备 在加入虚函数后，编译器必须引入虚表，并提供一系列底层的对 vptr 的设置和转换操作，包括： 向构造函数中添加初始化 vptr 的代码 合成有意义的 copy construcor、copy assignment constructor 这些内容的引入让对象不再满足从前的 bitwise 语义，因此在函数传入、返回、拷贝赋值的过程中均会引入额外的消耗。一般而言，当设计中有大量函数需要以传值的方式返回一个 local class object ，那么提供一个 copy constructor 就比较合理。这样的 copy constructor 可以触发 NRV 优化，避免额外对象的构建。 5.2 继承体系下的对象构造 在一个 class object 被定义时，其 constructor 中可能含有大量的隐藏码，可能包括了： 所有 virtual base class constructors 必须被按声明和层次顺序调用 如果在 member initialization list 中，则使用明确指定的参数初始化 base class 如果不在 member initialization list 中，则寻找 default constructor 初始化 base class 每一个 subobject 的偏移量需要在执行期可存取 所有 base class constructor 按声明顺序调用 如果在 member initialization list 中，则使用明确指定的参数初始化 base class 如果不在 member initialization list 中，则寻找 default constructor 初始化 base class 在 base class 是 vptr 的初始化 记录在 member initialization list 中的变量初始化 含有 default constructor 且未在 member initialization list 中的变量初始化 虚拟继承 当引入虚拟继承后，constructor 的扩充就不同于传统的只需要考虑 data members 和 vptr 的初始化问题了。在串式的 constructor 调用过程中 virtual base class 的 constructor 可能被重复调用，这要求编译器只在当一个完整的 class object 被构建时调用 virtual base class 的 constructor ，而在处理 subobjects 时压抑它们的调用。 vptr 初始化 C++ 语言规则要求，在一个 class object 的 constructor（包括其 subobject 的 constructor ）中，经由构造中的对象调用 virtual function ，其函数实体应该是在当前 constructor 属于的 class 中定义的那个。这要求虚拟机制必须知道自己是否处于一个 constructor 中。 为了控制决定对应位置的 virtual functions 的名单，编译系统需要通过控制 vptr 的初始化。事实上这一操作是在 base class constructor 调用之后、程序员代码或 member initialization list 对应的代码之前完成的。 5.3 对象复制语义学 当使用一个 class object 指定给另一个 class object 时，有三种可能的选择： 不做任何事，使用默认拷贝行为 提供一个 copy assignment operator 明确拒绝这个行为（通过提供一个 private 的 copy assignment operator） 在以下的情况下，一个 object 不符合 bitwise semantics ，而需要用户提供明确的 copy assignment operator ： 其中含有一个具有用户定义的 copy assignment operator 的 member object 其 base class 中存在 copy assignment operator 定义 其声明了任何 virtual function（vptr 总是不能直接拷贝的） 其继承自一个 virtual base class 但这种用户声明的内容总比默认情况要慢，还会出现因为不像 constructor 拥有 members initialization list 从而无法压抑 virtual base class 的 copy operators 的调用的情况。 解决这一情况的方法还是，如之前所说，不要允许 virtual base class 的拷贝操作、甚至不要在其中存放任何数据。 5.4 对象的效率 在对象符合 bitwise copy semantics 的时候效率最高，无论是 POD 、单继承或者是多继承效率均没有多少差别。为数不多的差距在于使用用户代码初始化成员变量和使用 members initialization list 初始化成员变量所带来的细微区别。 一旦引入 virtual function 或 virtual base class ，由于程序需要合成新的处理虚继承、虚函数的 copy assignment / constructor 内容，运行效率将大大降低。其中又以虚拟继承的情况尤甚。 5.5 解构语义学 如果类本身没有定义 destructor ，那么只在其内带的、或基类中的成员变量拥有destructor 的时候，编译器才会合成一个destructor ——即使其中使用了虚函数或者虚拟派生。 一个由程序员定义的 destructor 被扩展的方式类似 constructor 被扩展的方式，但是会反过来，其顺序如下： 如果 object 内存在一个 vptr，会首先重设相关的 vtbl destructor 的函数本身被执行 如果其任何 member class object（不含基类中的）有 destructor ，它们会被执行 如果有任何上一层的 nonvirtual base class 拥有 destructor ，它们会被执行 如果有任何 virtual base class 拥有 destructor ，它们会被执行 一个 object 的生命周期结束于 destructor 被执行的时候。在执行期间，它会依次变成它的各个层级的基类被最终消亡。 这里的顺序可能有些问题，第一步实际上可能应该放在第三步后执行","categories":[{"name":"programming","slug":"programming","permalink":"https://blog.apassbydreg.work/categories/programming/"},{"name":"reading notes","slug":"programming/reading-notes","permalink":"https://blog.apassbydreg.work/categories/programming/reading-notes/"}],"tags":[{"name":"OOP","slug":"OOP","permalink":"https://blog.apassbydreg.work/tags/OOP/"},{"name":"C++","slug":"C","permalink":"https://blog.apassbydreg.work/tags/C/"},{"name":"深度探索C++对象模型","slug":"深度探索C-对象模型","permalink":"https://blog.apassbydreg.work/tags/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"}]},{"title":"PBRT 第六章笔记（基础篇） | Notes for PBRT Chapter 06 - Camera Models (basis)","slug":"PBRT-ch06","date":"2021-11-04T14:21:01.000Z","updated":"2021-11-15T14:03:47.027Z","comments":true,"path":"2021/11/PBRT-ch06/","link":"","permalink":"https://blog.apassbydreg.work/2021/11/PBRT-ch06/","excerpt":"","text":"6.1 Camera Model 123456789101112131415161718192021class Camera &#123; public: // Camera Interface Camera(const AnimatedTransform &amp;CameraToWorld, Float shutterOpen, Float shutterClose, Film *film, const Medium *medium); virtual ~Camera(); virtual Float GenerateRay(const CameraSample &amp;sample, Ray *ray) const = 0; virtual Float GenerateRayDifferential(const CameraSample &amp;sample, RayDifferential *rd) const; virtual Spectrum We(const Ray &amp;ray, Point2f *pRaster2 = nullptr) const; virtual void Pdf_We(const Ray &amp;ray, Float *pdfPos, Float *pdfDir) const; virtual Spectrum Sample_Wi(const Interaction &amp;ref, const Point2f &amp;u, Vector3f *wi, Float *pdf, Point2f *pRaster, VisibilityTester *vis) const; // Camera Public Data AnimatedTransform CameraToWorld; const Float shutterOpen, shutterClose; Film *film; const Medium *medium;&#125;; 相机的抽象基类如上图所示。为了构建一个 Camera 衍生类的对象，你需要向父类传入的参数包括： 摄像机坐标到世界坐标的变换，表示相机在世界坐标内的位置 记录了快门开启和关闭时间的两个浮点数，可以用于生成带有运动模糊的场景 用于记录图像的 Film 指针 表示了摄像机周围介质的 Medium 指针 Camera 类型中最重要的函数即是 GenerateRay, GenerateRayDifferential 两个生成光线的函数。它们均会利用 CameraSample 中的信息生成对应的光线（或微分光线），并返回该光线对应的权值。一般而言，这个权值会是 1 ，但对于另外一些考虑了镜头特性的系统，它可能会发生变化。 6.1.1 摄像机坐标系 在这个坐标系中，相机的 zzz 轴被作为相机镜头指向的方向， yyy 轴作为镜头的上方。使用这种方法可以简单地比较物体在摄像机坐标系中的 zzz 值来判断它是否被其他物体遮挡。 6.2 Projective Camera Models CG 中最基础的问题之一就是如何将三维空间投影到二维平面表示。在大部分解决方案中，均使用了一个 4×44 \\times 44×4 的投影变换矩阵将三维空间的一部分区域投影到 Normalized device coordinate (NDC) 空间中。这个空间是一个单位立方体（虽然有的地方可能使用的坐标范围是 [−1,1][-1, 1][−1,1] ），通过这个空间的 xyxyxy 轴信息即对应了屏幕上的 uv 坐标。 作为这类摄像机的基类的 ProjectiveCamera 类，在 Camera 类的基础上增加了镜头半径、视窗大小、对焦距离等参数。在这个类型中有三种空间： 相机空间：以相机为中心的坐标系 屏幕空间：由输入的 screenWindow 决定的屏幕 xyxyxy 坐标范围包围盒空间，一般指的是 NDC 空间 光栅（Raster）空间：由像素的实际索引坐标组成的包围盒空间 1234567891011121314151617class ProjectiveCamera : public Camera &#123; public: // ProjectiveCamera Public Methods ProjectiveCamera(const AnimatedTransform &amp;CameraToWorld, const Transform &amp;CameraToScreen, const Bounds2f &amp;screenWindow, Float shutterOpen, Float shutterClose, Float lensr, Float focald, Film *film, const Medium *medium) : Camera(CameraToWorld, shutterOpen, shutterClose, film, medium), CameraToScreen(CameraToScreen); protected: // ProjectiveCamera Protected Data Transform CameraToScreen, RasterToCamera; Transform ScreenToRaster, RasterToScreen; Float lensRadius, focalDistance;&#125;; 6.2.1 正交投影相机 正交投影相机相机的视锥是一个长方体： 这种摄像机的屏幕空间到光栅空间的换算异常简单，只需要将边长匹配并忽略 zzz 轴即可。生成光线时，则会从近平面上对应的位置生成一个平行于 zzz 轴的光线。 6.2.2 透视投影相机 透视投影相机的视锥是一个锥体，它由一个表示视口左右端向量夹角的浮点数 fov (field of view) 和远近平面的距离组成（见本章图一）。由于对于任意位置的不同平面，其相似比率均和其 zzz 值正比。为了将视锥空间映射到 NDC 空间中，不同轴向的比例和对应的矩阵为： x′=x/zy′=y/zz′=far(z−near)z(far−near), (1000010000ff−n−fnf−n0010)\\begin{matrix} x&#x27; = &amp; x / z\\\\ y&#x27; = &amp; y / z\\\\ z&#x27; = &amp; {far(z - near) \\over z(far - near)} \\end{matrix} , \\ \\left(\\begin{matrix} 1 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; 1 &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; {f \\over f-n} &amp; -{fn \\over f-n}\\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\end{matrix}\\right)x′=y′=z′=​x/zy/zz(far−near)far(z−near)​​, ⎝⎜⎜⎛​1000​0100​00f−nf​1​00−f−nfn​0​⎠⎟⎟⎞​ 注意 zzz 轴的变换并非是一个线性的变换，为了构造对应矩阵 z′(z0)+z′(z1)≠z′(z0+z1)z&#x27;(z_0) + z&#x27;(z_1) \\neq z&#x27;(z_0 + z_1)z′(z0​)+z′(z1​)​=z′(z0​+z1​) 。注意上述变换，在一个四维的齐次坐标乘以该变换后不难发现新的坐标的第四个参量就代表了原始的 zzz 值，这在很多渲染中都是十分常用的保存线性的深度坐标的方法。 这种小孔成像的透视相机模型生成光线的方式也很简单，只要找到对应像素在任意一个平行于远、近平面的平面上的位置，构建一个从原点指向该方向的光线即可。 6.2.3 透镜模型和景深 以上的透视相机模型模拟的是一个小孔成像的相机类型。在实际生活中，光线一般会通过一个有限大小的光圈进入相机，并经过透镜折射到胶片上。这种相机模型将会在 6.4 节中详细讨论。 另一种建模这种现象的古典方法是 thin lens approximation 。这种方法假设相机的镜头是一个厚度相对于其曲率可以忽略的球形镜面。在这种模型中，平行的入射光将会汇聚在同一点上。特别地，平行于对称轴的光线将会汇聚在焦点上。 在更一般的情况下，对于在对称轴上的点，Gaussian Lens Equation 给出了其发出的光线经过透镜聚焦的位置： 1z′−1z=1f, z′=zfz+f{1 \\over z&#x27;} - {1 \\over z} = {1 \\over f}, \\ z&#x27; = {zf \\over z + f} z′1​−z1​=f1​, z′=z+fzf​ 失焦的点将在成像平面上投影出一个圆盘状的光斑（或取决于镜头特性的别的东西）。这个光斑的大小取决于相机的光圈、焦距和对焦平面的位置。在现实中，物体不一定需要准确的位于焦平面上才能拥有锋利的成像——只要上述提到的光斑的大小小于成像平面上一个像素的大小即可。这一整段在焦内的区域被称为景深。在几何上，我们很容易就能得到光斑的大小： dc=az′×∣zf−z′∣d_c = \\frac{a}{z&#x27;} \\times |z_f - z&#x27;| dc​=z′a​×∣zf​−z′∣ 在这种模型下采样光线需要增加额外的随机性。对于感受器上的某一点，会首先随机采样镜头上的任意位置，接着构建经过镜头该位置折射向感受器相应位置的光线。构建方式如下图所示： 中间的原点即代表 pinhole 相机的小孔成像位置，通过在对焦平面上找到对应位置，可知该位置发出的光线经过透镜的任意一点均会最终汇聚到感受器的那一点上，连接该点和之前的随机采样点即可得到光线方向。 6.3 Environment Camera 相当于一个全景相机，利用球坐标系的角度采样光线。二维的角度恰好可以映射到记录媒介的 uv 上： 1234567891011121314Float EnvironmentCamera::GenerateRay(const CameraSample &amp;sample, Ray *ray) const &#123; ProfilePhase prof(Prof::GenerateCameraRay); // Compute environment camera ray direction Float theta = Pi * sample.pFilm.y / film-&gt;fullResolution.y; Float phi = 2 * Pi * sample.pFilm.x / film-&gt;fullResolution.x; Vector3f dir(std::sin(theta) * std::cos(phi), std::cos(theta), std::sin(theta) * std::sin(phi)); *ray = Ray(Point3f(0, 0, 0), dir, Infinity, Lerp(sample.time, shutterOpen, shutterClose)); ray-&gt;medium = medium; *ray = CameraToWorld(*ray); return 1;&#125; 6.4 真实相机 ⚠️ 这部分描述了真实世界中由多个镜片组构成的真实相机系统，容我以后再看。","categories":[{"name":"programming","slug":"programming","permalink":"https://blog.apassbydreg.work/categories/programming/"},{"name":"reading notes","slug":"programming/reading-notes","permalink":"https://blog.apassbydreg.work/categories/programming/reading-notes/"}],"tags":[{"name":"CG","slug":"CG","permalink":"https://blog.apassbydreg.work/tags/CG/"},{"name":"render","slug":"render","permalink":"https://blog.apassbydreg.work/tags/render/"},{"name":"PBRT","slug":"PBRT","permalink":"https://blog.apassbydreg.work/tags/PBRT/"}]},{"title":"PBRT 第五章笔记 | Notes for PBRT Chapter 05 - Color and Radiometry","slug":"PBRT-ch05","date":"2021-11-02T13:44:45.000Z","updated":"2022-02-15T09:41:41.310Z","comments":true,"path":"2021/11/PBRT-ch05/","link":"","permalink":"https://blog.apassbydreg.work/2021/11/PBRT-ch05/","excerpt":"","text":"5.1 Spectral Representation 真实世界中的物体的 SPD（spectral power distribution，光谱能量分布）可能十分复杂。在渲染器中需要一种紧凑、高效和准确的方式来表现这些函数。在实践中却不得不做出一些牺牲。 研究这些问题的一般框架在于找到一些优质的基函数来表示 SPD 。基函数可以将无穷维的 SPD 映射到离散的包含数个参数的表示方法上。 5.1.1 Spectrum 类型 在 pbrt 中，光照信息被保存在 Spectrum 类型中。这个类并没有被定义，而是用一个 typedef 重定向至了最常用了 RGBSpectrum 类上。 5.1.2 CoefficientSpectrum 类型 1234567template &lt;int nSpectrumSamples&gt; class CoefficientSpectrum &#123;public: /* ... */ static const int nSamples = nSpectrumSamples;protected: Float c[nSpectrumSamples];&#125;; 这个类型展示了一种使用参数定义的光谱类型。它是一个模板类，可以适配各种不同的参数的数量。其 public 的函数中除了重载了各类运算符外，还包括了一些常用的数学和测试函数如 Clamp, Lerp, HasNaNs 等等。这个类型基于以下假设： 采样的基函数对于不同的输入的响应是线性的 各个基函数之间不会互相影响 5.2 The SampledSpectrum Class SampledSpectrum 类型继承自 CoefficientSpectrum 类，它将一段波长范围之内分割为等长的不同区间，使用一个采样值代替各个区间之内的能量分布。默认情况下，该类会在 [400nm,700nm)[400 {\\rm nm}, 700 {\\rm nm})[400nm,700nm) 的范围内采样 60 个区间来表示光谱上的能量分布。 这个类型除了继承自基类的函数外，还提供了包括初始化为统一值、使用已有样本初始化等方法。 5.2.1 XYZ Color 基于人眼感受颜色的生物学机理，可以只用三个浮点数来表示光谱从而得到与人眼收到的信息相似的结果。设三个分量上对于不同波长的权重函数为 X(λ),Y(λ),Z(λ)X(\\lambda), Y(\\lambda), Z(\\lambda)X(λ),Y(λ),Z(λ) ，则从 SPD 中计算出三个对应的浮点数的公式为： xλ=∫λS(λ)X(λ)dλyλ=∫λS(λ)Y(λ)dλzλ=∫λS(λ)Z(λ)dλ\\begin{aligned}&amp;x_{\\lambda}=\\int_{\\lambda} S(\\lambda) X(\\lambda) \\mathrm{d} \\lambda \\\\&amp;y_{\\lambda}=\\int_{\\lambda} S(\\lambda) Y(\\lambda) \\mathrm{d} \\lambda \\\\&amp;z_{\\lambda}=\\int_{\\lambda} S(\\lambda) Z(\\lambda) \\mathrm{d} \\lambda\\end{aligned} ​xλ​=∫λ​S(λ)X(λ)dλyλ​=∫λ​S(λ)Y(λ)dλzλ​=∫λ​S(λ)Z(λ)dλ​ CIE 标准中定义的这三条权重函数如下所示，它们是从一系列基于人类视觉的试验中总结出的经验值，代表了人眼中不同的细胞对于不同颜色的敏感度。 SampledSpectrum 类同样提供了将 SPD 转化为这三个参数的方法 5.2.2 RGB Color 上文中的 XYZ 颜色的表示方式是基于人眼感受功能的，而 RGB 颜色则是基于显示器显示方式的角度构建出来的。下图展示了 LCD 和 LED 显示器的三种显示颜色的实际 SPD 分布： 将人眼感受值 XYZ 颜色转化为用于显示的 RGB 颜色需要乘以一个预计算的矩阵： [rgb]=(∫R(λ)X(λ)dλ∫R(λ)Y(λ)dλ∫R(λ)Z(λ)dλ∫G(λ)X(λ)dλ∫G(λ)Y(λ)dλ∫G(λ)Z(λ)dλ∫B(λ)X(λ)dλ∫B(λ)Y(λ)dλ∫B(λ)Z(λ)dλ)[xλyλzλ]\\left[\\begin{array}{l}r \\\\g \\\\b\\end{array}\\right]=\\left(\\begin{array}{ccc}\\int R(\\lambda) X(\\lambda) \\mathrm{d} \\lambda &amp; \\int R(\\lambda) Y(\\lambda) \\mathrm{d} \\lambda &amp; \\int R(\\lambda) Z(\\lambda) \\mathrm{d} \\lambda \\\\\\int G(\\lambda) X(\\lambda) \\mathrm{d} \\lambda &amp; \\int G(\\lambda) Y(\\lambda) \\mathrm{d} \\lambda &amp; \\int G(\\lambda) Z(\\lambda) \\mathrm{d} \\lambda \\\\\\int B(\\lambda) X(\\lambda) \\mathrm{d} \\lambda &amp; \\int B(\\lambda) Y(\\lambda) \\mathrm{d} \\lambda &amp; \\int B(\\lambda) Z(\\lambda) \\mathrm{d} \\lambda\\end{array}\\right)\\left[\\begin{array}{c}x_{\\lambda} \\\\y_{\\lambda} \\\\z_{\\lambda}\\end{array}\\right] ⎣⎡​rgb​⎦⎤​=⎝⎛​∫R(λ)X(λ)dλ∫G(λ)X(λ)dλ∫B(λ)X(λ)dλ​∫R(λ)Y(λ)dλ∫G(λ)Y(λ)dλ∫B(λ)Y(λ)dλ​∫R(λ)Z(λ)dλ∫G(λ)Z(λ)dλ∫B(λ)Z(λ)dλ​⎠⎞​⎣⎡​xλ​yλ​zλ​​⎦⎤​ PBRT 中也提供了不同表示方法之间互相转化的方法。特别地，从 RGB 颜色转换为 SampledSpectrum 的采样值时，由于维度的减少使得大量光谱信息在转换的过程中丢失，而原始的 RGB 颜色的 SPD 函数的变化又实在太大，直接重建会导致 SampledSpectrum 中的采样值函数十分不光滑。PBRT 使用了 Smits 等人在 1999 年发表的文章 An RGB-to-spectrum conversion for reflectances 中使用的方法从而得到一个较为平滑的转换。 5.3 RGBSpectrum Implementation 有关 RGB 颜色的讨论在上一节中已经提到，RGBSpectrum 类继承于只有三个采样值的 SampledSpectrum 基类，它实现了上节中的部分于 RGB 颜色互相转换的函数。 RGB 表示法是目前最常用的表示方式，默认情况下，PBRT 使用它作为 SPD 的表示法。 5.4 Radiometry 光也是电磁波的一种。在 PBRT 中，为了简化计算的复杂度，对光线的行为做出了以下假设： 线性响应：系统对两个不同的输入之和产生的输出等于它们分开的输出之和 能量守恒：在散射过程中，出射的能量永远小于等于入射值 无极性、无散射或衍射、不同波长之间互相独立 稳定状态：在环境中的光场被认为是已经达到了平衡状态 5.4.1 基础量纲 Energy 单位是 JJJ ，单个光子的能量表示为： Q=hcλQ = {hc \\over \\lambda} Q=λhc​ Flux 单位时间内接收或释放的光能，单位是 J/sJ/sJ/s 或 WWW，定义为： Φ=lim⁡Δt→0ΔQΔt=dQdt\\Phi = \\lim_{\\Delta t \\to 0} {\\Delta Q \\over \\Delta t} = {\\mathrm{d} Q \\over \\mathrm{d} t} Φ=Δt→0lim​ΔtΔQ​=dtdQ​ 在时间上积分这个量即可得到总能量。 Irradiance 单位面积上单位时间接收或释放的光能，单位是 W/m2W/m^2W/m2 ，定义为： 需要注意的是，这里的面积指的是垂直于光照方向的面积，当光线并非垂直于表面入射时接收到光线的面积时，由于实际受光范围变大，计算 irradiance 时需要乘以一个 cos⁡(θ)\\cos(\\theta)cos(θ) 项，其中 θ\\thetaθ 代表了入射方向于法线的夹角。 Intensity intensity 描述了固定功率的光源在单位立体角上的能量分布情况。其中立体角可以通过将物体投影到单位圆上求面积得到。intensity 的单位是 W/srW/srW/sr ，定义为： E(p)=lim⁡ΔA→0ΔΦΔA⊥=dΦdA⊥E(p) = \\lim_{\\Delta A \\to 0} {\\Delta \\Phi \\over \\Delta A^{\\perp}} = {\\mathrm{d} \\Phi \\over \\mathrm{d}A^{\\perp}} E(p)=ΔA→0lim​ΔA⊥ΔΦ​=dA⊥dΦ​ Radiance radiance 描述了在单位立体角单位面积上单位时间内接收到的能量。你可以理解为：光源相对受光位置的方向为 ω\\omegaω 立体角为 dω\\mathrm{d}\\omegadω ，受光位置的面积为 dA\\mathrm{d}AdA ，在单位时间内的能量传输。其计算方式为： L(p,ω)=lim⁡Δω→0ΔEω(p)Δω=dEω(p)dω=dΦdωdA⊥L(p, \\omega) = \\lim_{\\Delta \\omega \\to 0} {\\Delta E_\\omega(p) \\over \\Delta \\omega} = {\\mathrm{d} E_\\omega(p) \\over \\mathrm{d}\\omega} = {\\mathrm{d}\\Phi \\over \\mathrm{d}\\omega\\mathrm{d}A^{\\perp}} L(p,ω)=Δω→0lim​ΔωΔEω​(p)​=dωdEω​(p)​=dωdA⊥dΦ​ radiance 是全书中最常用的物理量，因为它在一条光线的传输过程中是一个不变的量，不会随着距离等因素变化。 5.4.2 出射和入射光线函数 由于在 PBRT 中法线规定了一个表面的正向和反向，因此需要对表面上的某处的受光也做出正向反向的区分。 L+(p,ω)=lim⁡t→0+L(p+tnp,ω)L−(p,ω)=lim⁡t→0−L(p+tnp,ω)\\begin{aligned}&amp;L^{+}(\\mathrm{p}, \\omega)=\\lim _{t \\rightarrow 0^{+}} L\\left(\\mathrm{p}+t \\mathbf{n}_{\\mathrm{p}}, \\omega\\right) \\\\&amp;L^{-}(\\mathrm{p}, \\omega)=\\lim _{t \\rightarrow 0^{-}} L\\left(\\mathrm{p}+t \\mathbf{n}_{\\mathrm{p}}, \\omega\\right)\\end{aligned} ​L+(p,ω)=t→0+lim​L(p+tnp​,ω)L−(p,ω)=t→0−lim​L(p+tnp​,ω)​ 另一个需要注意的内容是，无论是出射还是入射光线的表示中，光线的起点均为该表面上的点。也就是说，对于入射光线的方向，实际上是从受光点指向光源的向量，而不是一般而言认为的从光源发出的向量。 结合两种定义即可得到出射光和入射光的表达： Li(p,ω)={L+(p,−ω),ω⋅np&gt;0L−(p,−ω),ω⋅np&lt;0Lo(p,ω)={L+(p,ω),ω⋅np&gt;0L−(p,ω),ω⋅np&lt;0\\begin{aligned}&amp;L_{\\mathrm{i}}(\\mathrm{p}, \\omega)= \\begin{cases}L^{+}(\\mathrm{p},-\\omega), &amp; \\omega \\cdot \\mathbf{n}_{\\mathrm{p}}&gt;0 \\\\L^{-}(\\mathrm{p},-\\omega), &amp; \\omega \\cdot \\mathbf{n}_{\\mathrm{p}}&lt;0\\end{cases} \\\\&amp;L_{\\mathrm{o}}(\\mathrm{p}, \\omega)= \\begin{cases}L^{+}(\\mathrm{p}, \\omega), &amp; \\omega \\cdot \\mathbf{n}_{\\mathrm{p}}&gt;0 \\\\L^{-}(\\mathrm{p}, \\omega), &amp; \\omega \\cdot \\mathbf{n}_{\\mathrm{p}}&lt;0\\end{cases}\\end{aligned} ​Li​(p,ω)={L+(p,−ω),L−(p,−ω),​ω⋅np​&gt;0ω⋅np​&lt;0​Lo​(p,ω)={L+(p,ω),L−(p,ω),​ω⋅np​&gt;0ω⋅np​&lt;0​​ 特别的，对于空间中没有介质的位置有： Lo(p,ω)=Li(p,−ω)=L(p,ω)L_{o}(\\mathrm{p}, \\omega)=L_{\\mathrm{i}}(\\mathrm{p},-\\omega)=L(\\mathrm{p}, \\omega) Lo​(p,ω)=Li​(p,−ω)=L(p,ω) 5.5 Working with Radiometric Integrals 本节中提供了一些计算某一点处的 Irradiance 的积分公式与技巧。原始的定义如下： E(p,n)=∫ΩLi(p,ω)∣cos⁡θ∣dωE(p, n) = \\int_{\\Omega}L_i(p, \\omega)|\\cos\\theta|\\mathrm{d}\\omega E(p,n)=∫Ω​Li​(p,ω)∣cosθ∣dω 5.5.1 使用投影固体角积分 使用固体角积分可以简化掉上面公式中的 cos⁡\\coscos 项，由于有 dω⊥=∣cos⁡θ∣dω\\mathrm{d}\\omega^{\\perp} = |\\cos\\theta|\\mathrm{d}\\omegadω⊥=∣cosθ∣dω ，上述公式可以转换为： E(p,n)=∫H2(n)Li(p,ω)dω⊥E(p, n) = \\int_{H^2(n)}L_i(p, \\omega)\\mathrm{d}\\omega^{\\perp} E(p,n)=∫H2(n)​Li​(p,ω)dω⊥ 5.5.2 在球坐标系下积分 为了将固体角转换为在坐标系上的积分，需要进行以下映射： dω=sin⁡θdθdϕ\\mathrm{d}\\omega = \\sin\\theta\\mathrm{d}\\theta\\mathrm{d}\\phi dω=sinθdθdϕ 因此在法线半球的积分就可以写成： E(p,n)=∫02πdϕ∫0π/2Li(p,θ,ϕ)cos⁡θsin⁡θdθE(p, n) = \\int_0^{2\\pi}\\mathrm{d}\\phi\\int_0^{\\pi/2} L_i(p, \\theta,\\phi)\\cos\\theta\\sin\\theta\\mathrm{d}\\theta E(p,n)=∫02π​dϕ∫0π/2​Li​(p,θ,ϕ)cosθsinθdθ 5.5.3 在面积上积分 在现实情况中，常常需要对一个面光源积分。想从使用几何体表示的面光源获得面积容易、获得前述的立体角之类的信息却十分困难。此时在面积上积分会带来更多好处。转换面积积分和立体角积分的方式是： dω=dAcos⁡θr2\\mathrm{d}\\omega = {\\rm{d}A\\cos\\theta \\over r^2} dω=r2dAcosθ​ 其中 θ\\thetaθ 是该面的法线与光线的夹角。转换后的积分变成了： E(p,n)=∫ALcos⁡θidAcos⁡θor2E(p, n) = \\int_A L\\cos\\theta_i {\\rm{d}A\\cos\\theta_o \\over r^2} E(p,n)=∫A​Lcosθi​r2dAcosθo​​ 5.6 Surface Reflection 当一束光射入某个表面并发生反射，我们通常使用反射光在不同方向上的光谱分布来描述它的光线传输过程。对于半透明材质而言，描述光线的传输将变得更为复杂。对于皮肤、牛奶等材质，一束光可能从一点进入并从另一个位置射出。 在 PBRT 中使用了 BRDF 和 BSSRDF 来描述这些过程。 5.6.1 Bidirectional Scattering Distribution Function *(*BSDF) 给定光线的入射方向、出射方向和表面上的一点，BSDF 描述了入射方向的光线 irradiance 传输到出射方向上的 radiance 比例。 f(p,ωo,ωi)=dLo(p,ωo)dE(p,ωi)=dLo(p,ωo)Li(p,ωi)cos⁡θidωif\\left(\\mathrm{p}, \\omega_{\\mathrm{o}}, \\omega_{\\mathrm{i}}\\right)=\\frac{\\mathrm{d} L_{\\mathrm{o}}\\left(\\mathrm{p}, \\omega_{\\mathrm{o}}\\right)}{\\mathrm{d} E\\left(\\mathrm{p}, \\omega_{\\mathrm{i}}\\right)}=\\frac{\\mathrm{d} L_{\\mathrm{o}}\\left(\\mathrm{p}, \\omega_{\\mathrm{o}}\\right)}{L_{\\mathrm{i}}\\left(\\mathrm{p}, \\omega_{\\mathrm{i}}\\right) \\cos \\theta_{\\mathrm{i}} \\mathrm{d} \\omega_{\\mathrm{i}}} f(p,ωo​,ωi​)=dE(p,ωi​)dLo​(p,ωo​)​=Li​(p,ωi​)cosθi​dωi​dLo​(p,ωo​)​ 基于物理的 BSDF 满足了两大性质： 对称：交换入射和出射方向得到的值不变 f(p,ωo,ωi)=f(p,ωi,ωo)f(p, \\omega_o, \\omega_i) = f(p, \\omega_i, \\omega_o)f(p,ωo​,ωi​)=f(p,ωi​,ωo​) 能量守恒：入射的能量永远大于等于出射的能量，即对入射方向积分有 ∫S2f(p,ωo,ω′)cos⁡θ′dω′≤1\\int_{S^2}f(p, \\omega_o, \\omega&#x27;)\\cos\\theta&#x27;\\mathrm{d}\\omega&#x27; \\leq 1 ∫S2​f(p,ωo​,ω′)cosθ′dω′≤1 BSDF 实际上由 BRDF 和 BTDF 组成，BRDF 描述了在法线半球上的传输信息，常用于各种不透明表面；而 BSDF 则描述了另一个半球上的传输信息，常用于各种折射表面。 使用 BSDF 计算出射 radiance 的方法只需在立体角上积分即可： Lo(p,ωo)=∫S2f(p,ωo,ωi)Li(p,ωi)∣cos⁡θi∣dωiL_o(p, \\omega_o) = \\int_{S^2}f(p, \\omega_o,\\omega_i)L_i(p,\\omega_i)|\\cos\\theta_i|\\mathrm{d}\\omega_i Lo​(p,ωo​)=∫S2​f(p,ωo​,ωi​)Li​(p,ωi​)∣cosθi​∣dωi​ 5.6.2 Bidirectional Scattering Surface Reflectance Distribution Function (BSSRDF) 由于 BSSRDF 在法线方向的另一侧通常在发生复杂的光线传输过程，我们假定在那些位置不会贡献额外的入射光，也就只需考虑法线侧的入射光。通过分离 BRDF 中的入射点和出射点可以得到 BSSRDF ，它并不考虑光线在介质内部经过的路径，只考虑最终的结论。使用 BSSRDF 得到出射 radiance 的方法需要在 BRDF 的基础上增加对面积的积分： Lo(p,ωo)=∫AdA∫H2(n)f(pi,po,ωo,ωi)Li(pi,ωi)∣cos⁡θi∣dωiL_o(p, \\omega_o) = \\int_A{\\rm dA}\\int_{H^2(n)}f(p_i,p_o,\\omega_o,\\omega_i)L_i(p_i,\\omega_i)|\\cos\\theta_i|\\mathrm{d}\\omega_i Lo​(p,ωo​)=∫A​dA∫H2(n)​f(pi​,po​,ωo​,ωi​)Li​(pi​,ωi​)∣cosθi​∣dωi​","categories":[{"name":"programming","slug":"programming","permalink":"https://blog.apassbydreg.work/categories/programming/"},{"name":"reading notes","slug":"programming/reading-notes","permalink":"https://blog.apassbydreg.work/categories/programming/reading-notes/"}],"tags":[{"name":"CG","slug":"CG","permalink":"https://blog.apassbydreg.work/tags/CG/"},{"name":"render","slug":"render","permalink":"https://blog.apassbydreg.work/tags/render/"},{"name":"PBRT","slug":"PBRT","permalink":"https://blog.apassbydreg.work/tags/PBRT/"}]},{"title":"《深度探索C++对象模型》第四章笔记 | Notes for Inside Cpp Object Model Chapter 04","slug":"InsideCppObjectModel-ch04","date":"2021-11-01T13:52:35.000Z","updated":"2021-11-04T14:21:47.857Z","comments":true,"path":"2021/11/InsideCppObjectModel-ch04/","link":"","permalink":"https://blog.apassbydreg.work/2021/11/InsideCppObjectModel-ch04/","excerpt":"","text":"4.1 Member 的各种调用方式 Nonstatic Member Functions C++ 的设计准则就是让 nonstatic member functions 的开销和一般的函数完全相同，它不会带来任何额外负担，因为编译器内部会将该函数实体转化为对等的 nonmember 函数实体。转化的步骤在于： 改写函数原型，增加一个额外的 this 指针，如果这个函数有 const 修饰符，则指针也需要有该修饰符 将该函数重写成一个外部函数，并对函数的名称进行「mangling」处理，使它变成独一无二的词语 改写每个这个函数的调用操作 对于函数名称的改写方式在各个编译器中并没有统一的方式，其中一种可能的做法是在函数名前面添加类名和、参数列表的信息 Virtual Member Functions 一个通过多态调用的虚成员函数需要进行运行时确定调用的函数体，一般是从 vtbl 中对应的 slot 位置找到该函数对应的指针再进行函数调用操作。对于虚函数中对于其它虚函数的调用，由于在分析出虚函数调用来自的实体的时候就已经掌握了对应的类型信息，因此并不需要额外的运行时开销。 另一方面，直接从实体调用的虚成员函数也不需要从 vtbl 中取地址，它绑定的实体在编译期间即可确定。编译器会以对待普通 nonstatic member functions 的方式处理这些函数。 Static Member Functions 在引入 static member functions 之前，C++ 要求所有 member functions 均需要经由对应的 class object 调用。而实际上只有当一个或多个 nonstatic data members 在函数中被使用的时候才需要一个 class object。当没有任何 nonstatic member 被使用时，该函数中的 this 也就没有了作用（但 C++ 不能识别这个情况）。 这样的话，若是一个 static member 被声明为 nonpublic ，它的存取就不得不通过一个 member function 来实现。在过去，可能会出现一些奇怪的代码： 1((ClassType *) 0)-&gt;get_object_cnt(); static member functions 便是用于解决这种问题。它的主要特性就是不含 this 指针，因此就拥有了一系列次要特性： 不能直接存取 nonstatic members 不能被声明为 const, volatile, virtual 不需要经过 class object 调用 nonstatic 函数由于缺乏 this 指针，使它拥有了一些意想不到的好处：可以作为 callback 函数，或是应用在线程函数上。 4.2 Virtual Member Functions 本节中深入探究了 vtbl 模型。 多态的表示 为了支持 virtual function 机制，必须要能够对多态对象有某种执行期的类型判断方法。 第一种解决方案是直接把必要的信息加在指针上，使它包括了参考的对象地址以及其对象类型的某种编码或结构。这个方法带来了两个问题，一是程序即使不使用多态也会增加空间负担，另一方面它也不能与 C 程序之间链接兼容。 第二种方法即将必要信息放在对象本身中，但一个结构是否需要那些额外的信息则是一件非常难以判断的事情。这会造成类内存的膨胀以及丧失与 C 接口的兼容性。为了判断哪些类型需要什么信息，需要一个更好的规范以判断在何时需要放入哪些信息： 信息的用途：在 C++ 中，多态表示了以一个基类的指针寻址出一个派生类的对象的意思。然而对于多态的使用，又有着不同的要求： 12345678Base *ptr;// 这种使用方法可以通过对 virtual function call 的 resolve 完成ptr-&gt;function();// 这种使用方法需要 runtime type identification (RTTI) 的支持if (Derived *dptr = dynamic_cast&lt;Derived&gt;(ptr))&#123; dptr-&gt;member++;&#125; 信息的内容：为了正确的实现多态，运行期间需要直到的信息包括了指针指向的变量的真实类型，以及对应的实体的位置。由此需要一个 vtbl 的机制，在 class object 中安插指向 vptr 指向虚函数表，并给每个对应的函数指派一个固定的 vtbl 索引值。一个类中的 vtbl 的内容包括了： 这个类中定义的函数实体，它可能重载了一个 base class virtual function 继承自 base class 的没有被重写的函数实体 纯虚函数的实体（一般会统一指向一个异常函数如 pure_virtual_function_called() ） 派生的实现 当一个含有虚函数表的类型被作为基类单派生后，新的函数可能有以下几种可能： 继承了基类的虚函数实体，对应的函数地址会被拷贝到派生类虚表的对应位置 使用自己重载的函数实体，将新的函数地址覆盖虚表的对应位置 增加新的虚函数，此时虚表的尺寸也会增加以存放新的函数地址 在单派生链中，每一个虚函数在重载前后都存在于虚表的同一个偏移位置处，这是非常直观且运行良好的，然而一旦引入了多继承和虚拟继承，对虚函数的支持就不那么好了。 多继承下的虚函数 在多重继承中支持虚函数的复杂度主要围绕在第二个以及后续的基类上，以及必须在执行期间调整 this 指针这一点。 在多重继承之下，每个 n 重继承的派生类都会有 n 个虚函数表（单一继承如上所述不会产生额外的虚函数表）。对于每一个虚函数表，派生对象中都会有对应的 vptr 一种可能的布局如下图所示： 有三种情况，第二个或者后续的基类会影响对虚函数的支持，这在上图中用三个 * 号表示： 通过一个指向第二个基类的指针调用派生类重载后的虚函数 通过指向派生类的指针调用未被重载的第二个或之后的基类中的虚函数 在 C++ 语言扩充性质下，允许一个虚函数的返回值发生变化，可能是 base type 也可能是 public derived type ： 123Base2 *pb = new Derived;// 此时返回的是 Derived::clone() ，它重载了两个基类中的虚函数Base2 *_pb = pb-&gt;clone(); 虚继承下的虚函数 当一个派生类从一个基类虚拟派生而来时，即使只是单一继承，其基类对象在派生类中都是未知的，需要在运行期决议并调整对应的 this 函数指针。 当一个 virtual base class 从另一个 virtual base class 中派生而来且二者都有 virtual functions 和 nonstatic data members 是，编译器对于它的支持将会变得极端复杂且诡异。最简单的方式就是不要再 virtual base class 中声明任何 nonstatic data member （和有实体的 nonstatic function） 4.3 函数的效率 使用类似以下的方法测试不同种类的函数的效率： 123456789101112131415161718// nonmember function 实例void cross_product(const Point3d &amp;pA, const Point3d &amp;pB)&#123; Point3d pC; /* ... */ return pC;&#125;int main() &#123; Point3d pA, pB; /* ... */ for (int iters = 0; iters &lt; 1e7; iters++) &#123; // nonmember function 实例 cross_product(pA, pB); &#125;&#125; 需要注意的地方有几个： inline 函数不止能节省一般函数调用带来的额外负担，还能提供给程序额外的优化机会 多重继承增加的时间消耗实际上源于函数中初始化返回值用的那个点的 constructor 处理了更多的虚拟函数相关的信息。 4.4 指向 Member Function 的指针 在上一章中曾经讲到，取一个类中 nonstatic data member 的地址实际上得到的是它在类内布局中的字节位置（有时需要加一）。它是一个不完整的值，必须绑定在某个 class object 的地址上才能被存取。一个指向 nonstatic member function 的指针的性质也与此相似，必须绑定于特定的 class object 的地址上（因为需要 this 指针），而 static member function 则不需要。 单继承下的情况 对于一个指向非虚函数的指针，得到的将会是它在内存中的直接地址。而对于指向虚函数的指针，得到的则是该函数在虚函数表中的索引值（有时需要加一）。但这会导致函数指针的二义性，当普通函数和虚函数具有同样的参数列表和返回值时，可能会出现内容的冲突。多重继承的引入提出了更加一般的实现方式的需要，顺势解决了这个问题。 多继承下的情况 为了能让指向成员函数的指针也可以支持多继承和虚拟继承，Stroustrup 中设计了如下的结构体记录函数指针信息： 12345678struct __mptr &#123; int delta; // this 指针使用时需要的偏移值 int index; // vtbl 中的函数位置索引，为 -1 时表示不指向 vtbl union &#123; __ptrtofunc faddr; // 内存中的函数指针 int v_offset; // 多继承或者虚拟继承中的 vptr 位置 &#125;；&#125;; 成员函数指针的效率 4.5 Inline Functions 考虑一个点的加法运算： 1234567Point operator+(const Point &amp;pt1, const Point &amp;pt2)&#123; Point new_pt; new_pt._x = pt1._x + pt2._x; /* ... */ return new_pt;&#125; 理论上，使用 inline 函数完成 get 和 set 能让系统变得更加干净： 1234void Point::x(float x) &#123; _x = x; &#125;float Point::x() &#123; return _x; &#125;new_pt.x(pt1.x() + pt2.x()); inline 函数的引用可以将其后可能因为在继承体系中的位移等改变带来的 data members 的变化最小化，同时保持和原有写法一样高的效率。另一方面，这个加法函数也不需要声明为原函数的一个 friend 了。 然而实际上 C++ 中的 inline 关键字并不是强制要求，它只是一个请求。如果编译器认为该函数无法被合理的扩展（即执行成本不比普通函数调用低），他就不会将函数 inline 化。对于执行成本的估计，通常是用函数中计算 assignments、function calls、virtual function calls 等操作的加权次数统计得到的。 一般而言，处理一个 inline 函数有两个阶段： 分析函数的定义。如果函数因为其复杂度或者构建问题被判断为不可以成为 inline ，它则会被转化为一个 static 函数，并在被编译的模块内产生对应的函数定义。 真正的 inline 函数扩展操作发生在它被调用的时刻，着会带来参数求值和临时对象管理的问题。在扩展点上，编译器同样会判断这个调用是否不需要成为 inline 调用。需要注意的是，如果 inline 函数只有一个表达式，那么它第二个或者更加往后的调用方式就不会被扩展开。上述的第二种写法中的调用会被扩展为及其丑陋的代码： 1new_pt.x= pt1._x + x__5PointFV(&amp;pt2); inline 函数的形式参数管理 在 inline 扩展期间，每个形参都会被实际参数所替代。然而，并不能简单地直接将所有形参替换为传入的表达式，因为这可能导致对实际参数额外的求值操作。一般而言，这些可能导致副作用的实参均需要引入临时变量代替。 如：inline 函数调用 func(1, foo(), bar() + 3); 的后两项就会在编译期替换为临时变量。 inline 函数的局部变量管理 一般而言，inline 函数中点每个局部变量都必须放在函数调用的一个封闭区间内，并拥有独一无二的名称。 当 inline 函数以分离的表达式的形式被扩展多次时，一般只需要一组局部变量，然而当它在单个表达式中多次使用并扩展时，每一次扩展都需要自己的局部变量。这些额外的局部变量和上一节中用来替换有副作用的实参的临时变量可能会导致大量临时性对象的产生，从而使程序的大小暴增。","categories":[{"name":"programming","slug":"programming","permalink":"https://blog.apassbydreg.work/categories/programming/"},{"name":"reading notes","slug":"programming/reading-notes","permalink":"https://blog.apassbydreg.work/categories/programming/reading-notes/"}],"tags":[{"name":"OOP","slug":"OOP","permalink":"https://blog.apassbydreg.work/tags/OOP/"},{"name":"C++","slug":"C","permalink":"https://blog.apassbydreg.work/tags/C/"},{"name":"深度探索C++对象模型","slug":"深度探索C-对象模型","permalink":"https://blog.apassbydreg.work/tags/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"}]},{"title":"Unity 里的平滑跟踪相机 | Smooth Following Camera in Unity","slug":"UnitySmoothFollowingCamera","date":"2021-10-31T16:44:03.000Z","updated":"2021-11-04T14:21:47.856Z","comments":true,"path":"2021/11/UnitySmoothFollowingCamera/","link":"","permalink":"https://blog.apassbydreg.work/2021/11/UnitySmoothFollowingCamera/","excerpt":"","text":"在游戏中，你可能会经常碰到需要让摄像机跟踪某一角色的需求。当然，简单地将摄像机绑定到角色身上自然是最容易不过了，可这是否有一点不够 COOOOOOL ？本文描述了一种简单的平滑跟踪策略，让摄像机能够实现类似缓入缓出、刹车过冲的效果。这种方法同样可以运用于自动生成补间摄像机动画上。你可以在 这里 查看完整的源码。 一个公式说明原理 一个运动平滑的跟踪相机的本质是什么？我认为主要有三点： 相机的速度函数应该是连续的，不能有急刹车的存在 相机的视点（LookAt）需要尽可能贴近被摄物体 相机的速度需要尽可能与被摄物体匹配 这三点每一条都看上去很直观，但实际上想要得出一个解析解难度并不算小（至少以我薄弱的数学基础真解不出来）。那么，当无法直接得到直观的有关位置的函数时，我们应该怎么办呢？在此我选择将上面的三个条件做一点转换： 相机的速度函数处处可导（连续一定可导） 相机的加速度应该与视点和被摄物体的距离成反比 相机的加速度应该与摄像机速度和被摄物体速度之差成反比 有了以上三条公式，再将反比关系替换成一个简单的线性映射，加入两个参数，我们就得到了一个核心公式： a=−w0(po−p)−w1(vo−v)a = -w_0(p_o - p) - w_1(v_o - v) a=−w0​(po​−p)−w1​(vo​−v) 或者，写成微分方程的形式： ∂2p∂t2=−w0(po−p)−w1(vo−∂p∂t){\\partial^2 p \\over \\partial t^2} = -w_0(p_o - p) - w_1(v_o - {\\partial p \\over \\partial t}) ∂t2∂2p​=−w0​(po​−p)−w1​(vo​−∂t∂p​) 当然，这个公式不止可以描述位置，它实际上可以在任意的地方生成较为平滑的插值。另一方面，将它应用在角度、偏移量等参数上也可以得到平滑的补间动画。使用这种系统的一个优势在于：不同于基于预设关键帧的动画，这种方式生成的动画可以在任意时间点从一个目标无缝转换到另一个目标上。 实现 有了这么简单的一个公式，实现起来自然并不困难。在每一次 Update() 调用中，你需要保存少数几个有关当前位置、速度的变量就能通过计算加速度、更新速度、从而得到更新后的摄像机参数。以下代码负责更新摄像机的目标点和速度，其他参数也是类似的过程。 123456&#123; Vector3 accel = L0Weight * (objPos - camLookAt) + L1Weight * (objSpeed - camSpeed); Vector3 dv = accel * Time.deltaTime; camLookAt += (camSpeed + dv * 0.5f) * Time.deltaTime; camSpeed += dv;&#125; 在这个控制器中，主要的控制方式使用的是在以物体为中心的球坐标系上确定位置的方法，而非之前常用的欧拉角。默认情况下，摄像机的上方向是沿着 y 轴正方向的，但本控制器也提供了一个侧滚参数来表示摄像机以拍摄方向为轴上的滚动。这个特性不仅仅可以表示滚动，还可以在特殊情况下帮助摄像机进行正确的插值。 特例的一种在于，当摄像机垂直地从上向下拍摄时，默认的 y 轴正方向已经不能作为摄像机的上方了。在转过这一点时，随着朝向的改变，摄像机会瞬间旋转 180° 的朝向。这种突变是大部分情况下都不愿意看到的。本系统利用这个沿着拍摄方向的翻滚特性设计了一个在转过这一点处的平滑插值方案。你可以通过控制平滑过渡开始的位置以更好地规划摄像机动画。当然，如果你并不需要这一特性的话，也可以将 interpThres 设置为 0 以关闭它。 1234567891011121314151617181920212223242526272829private Vector3 realRotationsToWorldUp(Vector3 dir)&#123; float a0 = Mathf.Deg2Rad * realDirections[0], a1 = Mathf.Deg2Rad * realDirections[1]; float rot = Mathf.Deg2Rad * realRotation; Vector3 rotZ = dir.normalized; Vector3 rotX, rotY; if (Mathf.Abs(rotZ.y) &lt; 1.0f) &#123; Vector3 z = new Vector3(0, 1, 0); rotY = Vector3.Cross(z, rotZ).normalized; rotX = Vector3.Cross(rotZ, rotY); &#125; else &#123; rotX = new Vector3(Mathf.Sin(a0), 0, Mathf.Cos(a0)) * -1; rotY = new Vector3(Mathf.Cos(a0), 0, -Mathf.Sin(a0)) * -1; &#125; // smooth transition float diff = Mathf.Abs(realDirections[1] - 180 * Mathf.Floor(realDirections[1] / 180) - 90) / 90; if (diff &lt; interpThres) &#123; float interp = Mathf.Pow(1 - diff / interpThres, 2.5f); rot += Mathf.PI * interp * 0.5f * Mathf.Sign(Mathf.Cos(a1)); &#125; return rotX * Mathf.Cos(rot) + rotY * Mathf.Sin(rot);&#125; 微分方程的稳定性分析 受 3B1B 的 这个关于微分方程可视化分析的视频 的启发，我尝试着在相空间中可视化了这个微分方程。 有关上述的微分方程，当被摄物体静止于某一点时，可以写成： ∂2dp∂t2=−w0dp−w1(vo−∂dp∂t), dp=(p−p0){\\partial^2 dp \\over \\partial t^2} = -w_0dp - w_1(v_o - {\\partial dp \\over \\partial t}), \\ dp = (p - p_0) ∂t2∂2dp​=−w0​dp−w1​(vo​−∂t∂dp​), dp=(p−p0​) 将整个空间的中心设为零点，以横坐标表示物体的位置、纵坐标代表速度构建相空间。下面这个工程可视化了在被摄物体静止不动的情况下，相机在不同的初始条件下，相空间中的向量场分布，以及其对应的运动轨迹。你可以通过它直观地体会在不同初始条件和参数下物体的位置和速度将会如何变化。 一些问题 这个系统只是一个非常简单的微分系统，其中包含着不少问题。有的问题可以通过简单地修改代码得到改善，而有的问题则较难解决。 可能的优化 我目前有头绪的优化包括： 对不同的参数设置不同的微分方程的权重，从而体现不同的敏感度 通过修改插值的公式形式，可能获得更加平滑的过渡 潜在的不足 参数较难调整：虽然每个参数的意义都颇为直观，但当你想要获得一个「能在固定时间由某初始情况收敛」的参数组是十分困难的 对于获取的数值稳定性有一定要求：当输入的数值含有抖动的情况下，可能会出现一些鬼畜的情况（比如我在之前的一版测试中简单地在每次更新中给被摄物体加入一个固定的位移量，但由于更新的时间间隔并不统一，造成了速度计算中的反复横跳，结果非常鬼畜）","categories":[{"name":"programming","slug":"programming","permalink":"https://blog.apassbydreg.work/categories/programming/"},{"name":"gamedev","slug":"programming/gamedev","permalink":"https://blog.apassbydreg.work/categories/programming/gamedev/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://blog.apassbydreg.work/tags/Unity/"},{"name":"GameLogic","slug":"GameLogic","permalink":"https://blog.apassbydreg.work/tags/GameLogic/"}]},{"title":"PBRT 第四章笔记 | Notes for PBRT Chapter 04 - Primitives and Intersection Acceleration","slug":"PBRT-ch04","date":"2021-10-30T16:58:53.000Z","updated":"2021-11-04T14:21:29.660Z","comments":true,"path":"2021/10/PBRT-ch04/","link":"","permalink":"https://blog.apassbydreg.work/2021/10/PBRT-ch04/","excerpt":"","text":"4.1 Primitive Interface and Geometric Primitives 抽象的 Primitive 基类提供了连接几何系统和着色系统的桥梁 123456789101112131415// Primitive Declarationsclass Primitive &#123; public: // Primitive Interface virtual ~Primitive(); virtual Bounds3f WorldBound() const = 0; virtual bool Intersect(const Ray &amp;r, SurfaceInteraction *) const = 0; virtual bool IntersectP(const Ray &amp;r) const = 0; virtual const AreaLight *GetAreaLight() const = 0; virtual const Material *GetMaterial() const = 0; virtual void ComputeScatteringFunctions(SurfaceInteraction *isect, MemoryArena &amp;arena, TransportMode mode, bool allowMultipleLobes) const = 0;&#125;; 前三个函数均在上一节中有所提及，第四个 GetAreaLight 函数则会返回一个指向该几何体的发光分布（emission distribution）的指针。这是为了统一作为光源的几何体和其它的几何体类型；第五个 GetMaterial 函数则返回了该几何体对应的材质信息。 最后一个函数 ComputeScatteringFunctions 会初始化参数 isect 中用于表示局部光线散射信息的表示（如 BSDF、BSSRDF 等） 4.1.1 Geometric Primitives Geometric Primitives 类表示了场景中的单个物体，每个 Geometric Primitives 类中都有且只有一个 Shape 类型的实例。 1234567891011121314151617181920212223class GeometricPrimitive : public Primitive &#123; public: // GeometricPrimitive Public Methods virtual Bounds3f WorldBound() const; virtual bool Intersect(const Ray &amp;r, SurfaceInteraction *isect) const; virtual bool IntersectP(const Ray &amp;r) const; GeometricPrimitive(const std::shared_ptr&lt;Shape&gt; &amp;shape, const std::shared_ptr&lt;Material&gt; &amp;material, const std::shared_ptr&lt;AreaLight&gt; &amp;areaLight, const MediumInterface &amp;mediumInterface); const AreaLight *GetAreaLight() const; const Material *GetMaterial() const; void ComputeScatteringFunctions(SurfaceInteraction *isect, MemoryArena &amp;arena, TransportMode mode, bool allowMultipleLobes) const; private: // GeometricPrimitive Private Data std::shared_ptr&lt;Shape&gt; shape; std::shared_ptr&lt;Material&gt; material; std::shared_ptr&lt;AreaLight&gt; areaLight; MediumInterface mediumInterface;&#125;; 除了指向 Shape 的指针外，它还保存了指向光照和材质信息的指针，最后的 mediumInterface 则被用于体积渲染中。 本类中的前三个函数均基本都是重定向至其 shape 指针的对应函数上。Intersect 函数则额外增加了初始化 isect 参数中的 mediumInterface 成员的步骤。 TransformedPrimitive: Object Instancing and Animated Primitives TransformedPrimitive 类保存了一个 Primitive 和一个 AnimatedTransform 。这个额外的信息让 object instancing 和为几何体设置动画变得可能。 123456789101112131415161718192021class TransformedPrimitive : public Primitive &#123; public: // TransformedPrimitive Public Methods TransformedPrimitive(std::shared_ptr&lt;Primitive&gt; &amp;primitive, const AnimatedTransform &amp;PrimitiveToWorld); bool Intersect(const Ray &amp;r, SurfaceInteraction *in) const; bool IntersectP(const Ray &amp;r) const; const AreaLight *GetAreaLight() const &#123; return nullptr; &#125; const Material *GetMaterial() const &#123; return nullptr; &#125; void ComputeScatteringFunctions(SurfaceInteraction *isect, MemoryArena &amp;arena, TransportMode mode, bool allowMultipleLobes) const &#123; /* 这个函数不应该被运行，运行时会报错 */ &#125; Bounds3f WorldBound() const &#123; return PrimitiveToWorld.MotionBounds(primitive-&gt;WorldBound()); &#125; private: // TransformedPrimitive Private Data std::shared_ptr&lt;Primitive&gt; primitive; const AnimatedTransform PrimitiveToWorld;&#125;; 本类中的 GetAreaLight, GetMaterial, ComputeScatteringFunctions 不能直接调用（会报错），真正需要调用的是这个对象拥有的 primitive 的对应函数。 不是很明白这里为啥不直接转发 primitive 成员的对应函数 Object Instancing 我将这个词理解为物体的复用。当场景中存在大量重复的物体时，这些物体本质上只有其 transform 不同而已。在本类的情况下，可以让大量不同的 TransformedPrimitive 指向相同的 Primitive ，而只有 transform 不一样。 刚体动画 通过在底层 shape 之上再叠加一层变换可以给更加方便的动画设置提供支持。虽然这样会增加一部分成本，但让底层的 shape 知晓更多的变换信息会产生更多的内存和帧间处理的消耗，这与本类的初衷背道而驰 4.2 Aggregates Aggregate 类提供了将多个几何体聚合为单个几何体的方式。这种将不同物体聚合而视作一个的方法在构建加速结构中非常常用。这也是一个抽象类，其中的任何函数都不该被调用。 123456789class Aggregate : public Primitive &#123; public: // Aggregate Public Methods const AreaLight *GetAreaLight() const; const Material *GetMaterial() const; void ComputeScatteringFunctions(SurfaceInteraction *isect, MemoryArena &amp;arena, TransportMode mode, bool allowMultipleLobes) const;&#125;; 不是很明白这里不用就不用为啥不直接留空啊，基类的这几个函数本来就没有函数体 4.3 Bounding Volume Hierarchies (BVH) BVH 以一种树状的结构加速光线相交测试。当光线与树中任意节点的包围盒没有相交时，该节点的整个子树都会被丢弃。在这种结构中，每一个几何体均在树中只出现一次，这种特性不仅避免了重复将同一个物体和光线求交，还使得这种加速算法的空间消耗有了明确的上界。 与下一节要讨论的 kd-tree 相比，BVH 虽然效率上稍微低一些，但优势在于构建时间较短、且不易受到各类数值误差的影响。 1234567891011121314151617181920212223242526272829303132333435363738394041class BVHAccel : public Aggregate &#123; public: // BVHAccel Public Types enum class SplitMethod &#123; SAH, HLBVH, Middle, EqualCounts &#125;; // BVHAccel Public Methods BVHAccel(std::vector&lt;std::shared_ptr&lt;Primitive&gt;&gt; p, int maxPrimsInNode = 1, SplitMethod splitMethod = SplitMethod::SAH); Bounds3f WorldBound() const; ~BVHAccel(); bool Intersect(const Ray &amp;ray, SurfaceInteraction *isect) const; bool IntersectP(const Ray &amp;ray) const; private: // BVHAccel Private Methods BVHBuildNode *recursiveBuild( MemoryArena &amp;arena, std::vector&lt;BVHPrimitiveInfo&gt; &amp;primitiveInfo, int start, int end, int *totalNodes, std::vector&lt;std::shared_ptr&lt;Primitive&gt;&gt; &amp;orderedPrims); BVHBuildNode *HLBVHBuild( MemoryArena &amp;arena, const std::vector&lt;BVHPrimitiveInfo&gt; &amp;primitiveInfo, int *totalNodes, std::vector&lt;std::shared_ptr&lt;Primitive&gt;&gt; &amp;orderedPrims) const; BVHBuildNode *emitLBVH( BVHBuildNode *&amp;buildNodes, const std::vector&lt;BVHPrimitiveInfo&gt; &amp;primitiveInfo, MortonPrimitive *mortonPrims, int nPrimitives, int *totalNodes, std::vector&lt;std::shared_ptr&lt;Primitive&gt;&gt; &amp;orderedPrims, std::atomic&lt;int&gt; *orderedPrimsOffset, int bitIndex) const; BVHBuildNode *buildUpperSAH(MemoryArena &amp;arena, std::vector&lt;BVHBuildNode *&gt; &amp;treeletRoots, int start, int end, int *totalNodes) const; int flattenBVHTree(BVHBuildNode *node, int *offset); // BVHAccel Private Data const int maxPrimsInNode; const SplitMethod splitMethod; std::vector&lt;std::shared_ptr&lt;Primitive&gt;&gt; primitives; LinearBVHNode *nodes = nullptr;&#125;; 本类的构造函数会接收一个表示了不同的 BVH 构建方式的参数。在枚举类中，后两者是简单地在结构中点划分或者分为等量的两组，其性能都不算高，而前两者则会在接下来详细说明。 4.3.1 BVH 的构建 BVH 的构建一般分为三步： 每一个物体的包围盒会被计算并放在一个数组中 使用传入的 splitMethod 参数指向的算法构建二叉树 将二叉树转化为更加紧凑、高效的无指针表示 为了构建 BVH ，需要记录的除了包围盒以外还有包围盒的中心和索引。 12345678struct BVHPrimitiveInfo &#123; BVHPrimitiveInfo(size_t primitiveNumber, const Bounds3f &amp;bounds) : primitiveNumber(primitiveNumber), bounds(bounds), centroid(.5f * bounds.pMin + .5f * bounds.pMax) &#123; &#125; size_t primitiveNumber; Bounds3f bounds; Point3f centroid;&#125;; 这些信息将被用于构建二叉树结构。不同的算法使用的构建方式并不相同，这将在接下来说明。在构建时同样完成的还有节点总数的设置，以及另一组指向几何体的指针（顺序与原有的可能有区别，因此需要将其与原有指针交换）。构建完成后，函数会返回申请在 MemoryArena 上的二叉树的根节点的指针。此时使用的结构是 BVHBuildNode ，其内容如下： 1234567struct BVHBuildNode &#123; void InitLeaf(int first, int n, const Bounds3f &amp;b) &#123; ... &#125; void InitInterior(int axis, BVHBuildNode *c0, BVHBuildNode *c1) &#123; ... &#125; Bounds3f bounds; BVHBuildNode *children[2]; int splitAxis, firstPrimOffset, nPrimitives;&#125;; 节点中保存最终指向的物体的指针的方式是通过两个整数 firstPrimOffset, nPrimitives 分别表示在指针数组中的起始偏移和几何体数目。 在每个节点内部，分割算法会选择坐标轴中的一个作为基准（PBRT 中选择了坐标范围最广的轴），确定一个分割位置使得该位置两侧的几何体分别属于下一级不同的节点。这个过程持续到该节点中只有一个几何体，或者该节点中所有几何体的中心都一样为止。每产生一个叶子节点，其中的几何体指针就会被增加到初始为空的 orderedPrims 的最后以形成一个良好排列的数组。 分割完成后，会根据最终的节点数量申请对应大小的内存保存更加紧凑的结构 LinearBVHNodes 12345678910struct LinearBVHNode &#123; Bounds3f bounds; union &#123; int primitivesOffset; // leaf int secondChildOffset; // interior &#125;; uint16_t nPrimitives; // 0 -&gt; interior node uint8_t axis; // interior node: xyz uint8_t pad[1]; // ensure 32 byte total size&#125;; 4.3.2 SAH 分割算法 所有分割算法都试图找到一种分割方式，使得在节点上进行光线相交计算的开销尽可能的少。寻找到一个这样的全局最优解是十分困难的，所以各种算法一般会构建一个 cost 模型来替代估计实际的开销、并使用特定的算法（如贪心算法）找到这个 cost 模型的局部最优解。 SAH 的 cost 模型如下： 设一个聚合中有 NNN 个几何体，在每个几何体上做相交测试的开销分别是 tisect(oi)t_{isect}(o_i)tisect​(oi​) ，则当这个节点是叶子节点时的总开销为： Cl=∑i=1Ntisect(oi)C_l = \\sum_{i=1}^N t_{isect(o_i)} Cl​=i=1∑N​tisect(oi​)​ 如果将这个聚合中的几何体分为 A,BA,BA,B 两部分，使得可以使用 ttravt_{trav}ttrav​ 的时间确定某光线需要继续测试哪些部分的相交情况（概率分别为 pA,pBp_A, p_BpA​,pB​ ），则这种中间节点的总开销为： Ci=ttrav+pA∑i=0NAtisect(ai)+pB∑i=0NBtisect(bi)C_i = t_{trav} + p_A\\sum_{i=0}^{N_A}t_{isect}(a_i) + p_B\\sum_{i=0}^{N_B}t_{isect}(b_i) Ci​=ttrav​+pA​i=0∑NA​​tisect​(ai​)+pB​i=0∑NB​​tisect​(bi​) PBRT 基于构建和使用的效率考量制定了以下的规则： 假设对于所有几何体 tisectt_{isect}tisect​ 均相等且约等于 ttravt_{trav}ttrav​ 的 8 倍，并使用每个部分的表面积估计 pA,pBp_A, p_BpA​,pB​ （这也是 SAH 算法名字的来源） 使用固定数量的（代码中是 12 个）均匀分布的候选位置确定分割方法，而不是尝试所有可能的位置 当节点中几何体的数量小于一定值（代码中是 2 个）时，直接将节点中的几何体分割为两个含有同样数量的叶子节点，因为此时使用 SAH 算法对效率并没有明显提高但又很耗费资源 只有当分割后的 cost 低于分割前时，分割才会发生 4.3.3 Linear BVH 使用 SAH 构建的 BVH 有两个主要的缺陷： 一个场景中的几何体会被在构建BVH时重复计算很多遍表面积 自上而下的 BVH 构建结构难以并行化 为了解决这些问题，诞生了 LBVH 算法。在 LBVH 中，树的生成时间与几何体数量线性相关、且可以快速生成可供独立并行的分块，提高了其并行程度。其最主要的特点是将 BVH 的构建算法理解为一个排序算法。它使用 Morton Codes 将高维空间中相邻的点映射到在一维的线上的点，从而使他们能够被更容易地排序。当节点被排序完成后，空间上相邻的几何体群在排序后的序列中也相邻。 Morton Codes 这种编码方式并不复杂，实际上就相当于将高维的点的各个坐标的二进制表示中每个 bit 交叉排列，如点 (x,y)(x, y)(x,y) 的 Morton Codes 表示就是 ⋯yb2xb2yb1xb1yb0xb0\\cdots y_{b2}x_{b2}y_{b1}x_{b1}y_{b0}x_{b0}⋯yb2​xb2​yb1​xb1​yb0​xb0​ 这种编码用一种类似 Z 字分型的方式将空间中的区域连成一维的线，示意图如下： HLBVH LBVH 就相当于使用简单的等分点分割方法构建的 BVH ，它直接在一个节点的每个坐标轴的坐标范围的等分点处切分平面。这种结构并不足够高效。因此此处引入了新的 HLBVH ，首先使用 LBVH 算法构建底层的子树，接着在这些子树的基础上使用 SAH 算法构建更高效的 BVH 结构 HLBVH 的构建流程如下： 首先计算所有几何体的最大的包围盒和每个几何体对应的 Morton Codes 使用基数排序算法排序所有节点，每个排序轮次会使用多位 在得到排序后的几何体后，将临近区域内的几何体首先聚合称为底层的子树，子树的生成规则如下： 每个子树中的节点应该都在同一块相邻的区域中（判断方法是 mask 后的 morton code 一致，即表示基层的一部分 code 相同） 每个子树中的节点数量应该小于某个值，当数量过多的时候会修改 mask 尝试更加细的分解 当 mask 缩小到最小时，所有节点都在一个 morton code 表示的最小单元格中，此时无条件生成一个子树 在串行完成第一部分粗分类后，后两部分将会并行地完成 将生成的子树列表视作几何体列表使用 SAH 构建上层的 BVH 4.3.4 BVH 的压缩和索引优化 BVH 构建完成后需要被进一步优化为更加缓存和内存高效的模块。最终的 BVH 会被使用深度优先的算法展开并储存在一段连续的线性内存空间中。这种结构让每个节点的第一个子节点都必定是该节点的直接后继，因此只需要显式储存指向第二个子节点的偏移量即可。 12345678910struct LinearBVHNode &#123; Bounds3f bounds; union &#123; int primitivesOffset; // leaf int secondChildOffset; // interior &#125;; uint16_t nPrimitives; // 0 -&gt; interior node uint8_t axis; // interior node: xyz uint8_t pad[1]; // ensure 32 byte total size&#125;; 整个结构体恰好只有 32 bytes ，使得它可以被直接放入一个 cache line 中优化缓存性能。 整个线性结构的构建是一个精心设计的深度优先遍历算法： 12345678910111213141516171819int BVHAccel::flattenBVHTree(BVHBuildNode *node, int *offset) &#123; LinearBVHNode *linearNode = &amp;nodes[*offset]; linearNode-&gt;bounds = node-&gt;bounds; int myOffset = (*offset)++; if (node-&gt;nPrimitives &gt; 0) &#123; CHECK(!node-&gt;children[0] &amp;&amp; !node-&gt;children[1]); CHECK_LT(node-&gt;nPrimitives, 65536); linearNode-&gt;primitivesOffset = node-&gt;firstPrimOffset; linearNode-&gt;nPrimitives = node-&gt;nPrimitives; &#125; else &#123; // Create interior flattened BVH node linearNode-&gt;axis = node-&gt;splitAxis; linearNode-&gt;nPrimitives = 0; flattenBVHTree(node-&gt;children[0], offset); linearNode-&gt;secondChildOffset = flattenBVHTree(node-&gt;children[1], offset); &#125; return myOffset;&#125; 4.3.5 BVH 的遍历 遍历 BVH 相当于递归地向下搜索中间节点，通过在途中抛弃与包围盒不会相交的节点提升效率。最后返回在叶子节点处调用几何体相交函数的结果。算法使用一个栈维护接下来需要访问的节点。 123456789101112131415161718192021222324252627282930313233343536373839bool BVHAccel::Intersect(const Ray &amp;ray, SurfaceInteraction *isect) const &#123; if (!nodes) return false; ProfilePhase p(Prof::AccelIntersect); bool hit = false; Vector3f invDir(1 / ray.d.x, 1 / ray.d.y, 1 / ray.d.z); int dirIsNeg[3] = &#123;invDir.x &lt; 0, invDir.y &lt; 0, invDir.z &lt; 0&#125;; // Follow ray through BVH nodes to find primitive intersections int toVisitOffset = 0, currentNodeIndex = 0; int nodesToVisit[64]; while (true) &#123; const LinearBVHNode *node = &amp;nodes[currentNodeIndex]; // Check ray against BVH node if (node-&gt;bounds.IntersectP(ray, invDir, dirIsNeg)) &#123; if (node-&gt;nPrimitives &gt; 0) &#123; // Intersect ray with primitives in leaf BVH node for (int i = 0; i &lt; node-&gt;nPrimitives; ++i) if (primitives[node-&gt;primitivesOffset + i]-&gt;Intersect( ray, isect)) hit = true; if (toVisitOffset == 0) break; currentNodeIndex = nodesToVisit[--toVisitOffset]; &#125; else &#123; // Put far BVH node on _nodesToVisit_ stack, advance to near // node if (dirIsNeg[node-&gt;axis]) &#123; nodesToVisit[toVisitOffset++] = currentNodeIndex + 1; currentNodeIndex = node-&gt;secondChildOffset; &#125; else &#123; nodesToVisit[toVisitOffset++] = node-&gt;secondChildOffset; currentNodeIndex = currentNodeIndex + 1; &#125; &#125; &#125; else &#123; if (toVisitOffset == 0) break; currentNodeIndex = nodesToVisit[--toVisitOffset]; &#125; &#125; return hit;&#125; 4.4 Kd-Tree Accelerator Binary space partitioning (BSP) 的算法通过平面适应性地分割空间。与 BVH 不同的是，这种算法并不会产生重叠的区域，而是在几何体刚好落在分割线中间时将它同时加入两侧计算。这种算法会递归地进行，直到节点中的几何体数量足够小或者树足够深的时候停止计算。因为分隔平面可以任意地放置在空间的任何位置，而三维空间的不同位置可以得到不同程度的细化，BSP 可以有效地适应场景中几何体分布不均匀的情况。 BSP 算法的两种变体分别是 kd-tree 和 octrees 。kd-tree 简单地限制分割平面必须垂直于某个坐标轴，从而加速结构的构建和使用；而 octrees 则在 kd-tree 的基础上，在一次分割中同时使用三个垂直于不同坐标轴的平面将空间分为 8 份。一个简单的 kd-tree 构建过程实例如下： 12345678910111213141516171819202122232425class KdTreeAccel : public Aggregate &#123; public: KdTreeAccel(std::vector&lt;std::shared_ptr&lt;Primitive&gt;&gt; p, int isectCost = 80, int traversalCost = 1, Float emptyBonus = 0.5, int maxPrims = 1, int maxDepth = -1); Bounds3f WorldBound() const &#123; return bounds; &#125; ~KdTreeAccel(); bool Intersect(const Ray &amp;ray, SurfaceInteraction *isect) const; bool IntersectP(const Ray &amp;ray) const; private: void buildTree(int nodeNum, const Bounds3f &amp;bounds, const std::vector&lt;Bounds3f&gt; &amp;primBounds, int *primNums, int nprims, int depth, const std::unique_ptr&lt;BoundEdge[]&gt; edges[3], int *prims0, int *prims1, int badRefines = 0); const int isectCost, traversalCost, maxPrims; const Float emptyBonus; std::vector&lt;std::shared_ptr&lt;Primitive&gt;&gt; primitives; std::vector&lt;int&gt; primitiveIndices; KdAccelNode *nodes; int nAllocedNodes, nextFreeNode; Bounds3f bounds;&#125;; 4.4.1 树的表示方法 kd-tree 也是一种二叉树，每个节点中均需要储存的信息和 BVH 相似。 kd-tree 的节点被包装为一个只有 8 byte 的结构体： 123456789101112131415struct KdAccelNode &#123; public: union &#123; Float split; // Interior int onePrimitive; // Leaf int primitiveIndicesOffset; // Leaf &#125;; private: union &#123; int flags; // Both int nPrims; // Leaf int aboveChild; // Interior &#125;;&#125;; KdAccelNode::flags 的低二位被用于指示该节点的类型（沿 x,y,zx,y,zx,y,z 分割的中间节点或叶子节点）。 对于叶子节点，KdAccelNode::flags 的高 30 位保存了内含的几何体数量，当仅有一个几何体时，KdAccelNode::onePrimitive 保存了该几何体的序号，而当有多个几何体时，则在 KdTreeAccel::primitiveIndices 中按照节点编号顺序储存这各个节点之中的几何体编号序列为一个连续数组，并在节点的 KdAccelNode::primitiveIndicesOffset 中保存这一节点对应序列的首位偏移。 对于中间节点，KdAccelNode::split 保存了分割的位置，而 KdAccelNode::aboveChild 的高 30 位则储存了在分割平面上方的子节点的偏移（和 BVH 的压缩方法一样，中间节点的直接后继就是它的其中一个子节点） 4.4.2 建树过程 在 KdTreeAccel 类中，所有的节点被储存在连续的空间中，使用指针 node 可以访问它们。而 nextFreeNode, nAllocedNode 则代表了下一个可用的节点的位置和当前已经申请的节点数量。 在开始递归算法前，需要进行以下的初始化步骤： 为了防止树的深度因为某些特殊情况不理智地增长，当最大深度没有被设置时，会使用一个经验值 8+1.3log⁡2N8 + 1.3\\log_2 N8+1.3log2​N 来设置最大深度。 预计算每个几何体的包围盒和所有几何体的包围盒，前者被预先放置在一个列表中 初始化储存节点中的几何体序号的连续数组。由于根节点中一定包含了所有节点，因此其初始值为 0 ~ N - 1 的所有整数 提前申请各种内存，如储存节点序列的内存块和暂存分割位置的信息结构体等 递归的建树流程如下： 找到下一个未使用但已申请的节点位置，如果已经用完了已申请的内存，则重新申请一个容量是原来的两倍的内存空间，并将原有内容迁移至新空间中 当达到了深度限制或者几何体的数量足够少后，生成一个叶子节点终止递归 如果这是一个内部节点，使用类似 SAH 的算法找到分割轴向和分割位置 kd-tree 中使用的分割算法与 SAH 有几点不同： kd-tree 中是有可能分割出不含任何几何体的子区域的。这种空区域不需要任何操作就可以被直接跳过，因此会在 cost 模型中产生一个额外的 bonus 项（下式中的 beb_ebe​ 只在存在空区域时非零）： C=ttrav+(1−be)(pBNB+pANA)tisectC = t_{trav} + (1-b_e)(p_BN_B + p_AN_A)t_{isect} C=ttrav​+(1−be​)(pB​NB​+pA​NA​)tisect​ 这块没看懂为什么要引入这个 beb_ebe​ 通过扫描每个物体的包围盒的六条边可以找到最合适的分割位置，这六条边被保存在 BoundEdge 结构中。易知，在每个轴向上之多需要 2N2N2N 个这样的结构，这些内存会被事先申请并在各层之间复用。 123456enum class EdgeType &#123; Start, End &#125;;struct BoundEdge &#123; Float t; int primNum; EdgeType type;&#125;; 在计算完将该节点直接作为叶子节点的 cost 后，函数会遍历所有该节点内的节点生成 BoundEdge 、然后在该轴向上排序所有边，最后从小到大地依次计算在每个位置上的 cost 。 算法会首先在空间最大的轴向上尝试分割，如果找不到比直接生成叶子节点更好的分割方法的话还会尝试另外两个轴向。特别地，在一些极端情况下可能根本找不到有用的分割方法（如下图），此时就只能放弃分割而生成一个叶子节点。 在确认了分割位置后，可以简单地将各个分割后的几何体指针分配到传入子节点的数组 prims0, prims1 内。因为会直接创建左子节点，前者可以直接传入接下来的子树中，而后者需要保存到左子树完成后才被第二次的建树操作使用： 12345678910// Recursively initialize children nodesFloat tSplit = edges[bestAxis][bestOffset].t;Bounds3f bounds0 = nodeBounds, bounds1 = nodeBounds;bounds0.pMax[bestAxis] = bounds1.pMin[bestAxis] = tSplit;buildTree(nodeNum + 1, bounds0, allPrimBounds, prims0, n0, depth - 1, edges, prims0, prims1 + nPrimitives, badRefines);int aboveChild = nextFreeNode;nodes[nodeNum].InitInterior(bestAxis, aboveChild, tSplit);buildTree(aboveChild, bounds1, allPrimBounds, prims1, n1, depth - 1, edges, prims0, prims1 + nPrimitives, badRefines); 4.4.3 kd-tree 的遍历 上图展示了 kd-tree 遍历的流程，在与当前中间节点的区域相交后，会计算出相交的 tmin, tmax, tsplit 。向子节点的遍历会从靠近 tmin 的更近的那个子节点先开始，直到抵达叶子节点后遍历其中的所有几何体。只有当在近子节点报告了不相交后远子节点才会被遍历到，如果不存在远子节点（tsplit &gt;= tmx）则直接报告不相交。这种 dfs 实际上使用了一个保存待访问节点信息的栈来实现： 1234struct KdToDo &#123; const KdAccelNode *node; Float tMin, tMax;&#125;; 近节点会被直接遍历，而后一个需要遍历的节点将被压入栈中","categories":[{"name":"programming","slug":"programming","permalink":"https://blog.apassbydreg.work/categories/programming/"},{"name":"reading notes","slug":"programming/reading-notes","permalink":"https://blog.apassbydreg.work/categories/programming/reading-notes/"}],"tags":[{"name":"CG","slug":"CG","permalink":"https://blog.apassbydreg.work/tags/CG/"},{"name":"render","slug":"render","permalink":"https://blog.apassbydreg.work/tags/render/"},{"name":"PBRT","slug":"PBRT","permalink":"https://blog.apassbydreg.work/tags/PBRT/"}]},{"title":"Unity 里的闪电特效 | Lightning FX in Unity","slug":"UnityLightningFX","date":"2021-10-28T08:36:16.000Z","updated":"2021-11-04T14:21:47.856Z","comments":true,"path":"2021/10/UnityLightningFX/","link":"","permalink":"https://blog.apassbydreg.work/2021/10/UnityLightningFX/","excerpt":"","text":"本文使用 Unity &gt;= 2020.3.19 的 URP 模板完成 此处仅提出一种可能的实现方案的展示，作为作者学习 Unity 的记录 源文件 点击此处下载 Motivation 制作这一闪电效果的参考来源于 这一视频 。通过将弧、波以及随机噪声组合在一起可以构建出单条闪电，进而叠加出完整的闪电效果。 一些准备工作 在本文中，我们将使用 Unity 中的 LineRenderer 渲染闪电，为此你需要准备一些东西： 一个发光材质 一个空的 GameObject 一个新 C# 脚本 我们希望这个闪电是可控的，所以给它加上了一系列参数： animate ：闪电是否会动（主要用于调参） seed ：随机种子 startPos, endPos ：闪电的起止位置 startWidth, endWidth ：闪电的起止宽度 numKeyPoints ：组成闪电的线段个数 evolutionStart, evolutionEnd ：起止剪切的比例 offsetPercentage ：径向错位的比例 tangentRandomRadius ：切向错位的半径 tangentRandomScale ：切向错位的全局缩放曲线 widthRandomSize ：粗细偏移量 animationDuration ：一轮动画的长度 arcHeight ：弧的最高位置 sineHeight, sineOffset ：波的高度和上下偏移量 noiseEvolutionSpeed ：噪声演化速度 这些参数的作用将在接下来说明。 得到这些参数后，我们还需要进行一些预处理。下面这个函数简单计算了步长、方向、距离以及 z 轴对应闪电法向的局部坐标系的基： 12345678910111213141516171819202122232425private void initParams()&#123; // random state rdm = seed; // direction and distance Vector3 dir = endPos - startPos; dist = dir.magnitude; pos_step = dist / (numKeyPoints + 1); width_step = (endWidth - startWidth) / (numKeyPoints + 1); // local coords n = dir.normalized; Vector3 tmp = new Vector3(0.0f, 0.0f, 0.0f); if (dir.z == 1.0f) &#123; tmp.x = 1.0f; &#125; else &#123; tmp.z = dir.z &gt; 0.0f ? 1.0f : -1.0f; &#125; x = Vector3.Cross(tmp, n); y = Vector3.Cross(n, x);&#125; 分解说明 随机数的状态 当关闭动画时，我们需要在每次调用都保证生成同样的随机数。这里使用了一个状态变量解决这个问题。仅当打开动画时，会使用一个新的随机数更新这个状态变量，让下一轮随机数的结果不同。 123456789if (animate)&#123; Random.InitState(rdm + Time.frameCount); rdm = (int)((1 &lt;&lt; 32) * Random.value);&#125;else&#123; Random.InitState(rdm);&#125; 随机数会在使用前首先生成好，并存放在数组中以供后面使用。为了生成平滑的动画，这些参数均使用 Perlin Noise 生成。 12345678910111213// generate random numbersVector2[] tangentOffsets = new Vector2[numKeyPoints];float[] directionalOffsets = new float[numKeyPoints];float[] widthOffsets = new float[numKeyPoints];for (int i = 0; i &lt; numKeyPoints; i++)&#123; float r = Mathf.Clamp01(Mathf.PerlinNoise(i * 4 + 0.1f, currTime * noiseEvolutionSpeed + seed)) * 0.75f + 0.25f; float phi = Mathf.Clamp01(Mathf.PerlinNoise(i * 4 + 0.9f, currTime * noiseEvolutionSpeed + seed)) * 2.0f * Mathf.PI; tangentOffsets[i].x = r * Mathf.Sin(phi); tangentOffsets[i].y = r * Mathf.Cos(phi); directionalOffsets[i] = Mathf.Clamp01(Mathf.PerlinNoise(i * 4 + 2.2f, currTime * noiseEvolutionSpeed + seed)) - 0.5f; widthOffsets[i] = Mathf.Clamp01(Mathf.PerlinNoise(i * 4 + 2.9f, currTime * noiseEvolutionSpeed + seed)) - 0.5f;&#125; 动画 这个效果中包含了完全随机的扰动和不那么随机的，有明确的更新频率的动画部分。这里使用了一个 currAnimationIdx 记录了之前正在播放的动画的轮数。当一轮动画结束后，这个值将被更新、并生成下一轮动画所需的参数。 另一方面，我们还需要记录当前动画播放到的时间位置 animationTime ，它被缩放在了 0 - 1 的范围内方便使用。 12345678910111213141516171819202122232425262728293031// timingfloat currTime = Time.fixedTime;float animationIdx = Mathf.Floor(currTime / animationDuration);float animationTime = currTime / animationDuration - animationIdx;// new animation paramsif (currAnimationIdx != animationIdx)&#123; currAnimationIdx = animationIdx; // arc currArcMaxHeight = Random.value * arcHeight; currArcTangentDeg = Random.value * 2.0f * Mathf.PI; currArcTangentDir = new Vector2(Mathf.Sin(currArcTangentDeg), Mathf.Cos(currArcTangentDeg)); // sine currSineLT = Random.value * 0.5f - 0.25f; if (currSineLT &gt;= 0) &#123; currSineLT = Mathf.Max(0.1f, currSineLT); &#125; currSineRT = Random.value * 0.5f + 0.75f; if (currSineRT &lt;= 1) &#123; currSineRT = Mathf.Min(0.9f, currSineRT); &#125; currSineHeight = Random.value * sineHeight; currSinePhi = Random.value * 2.0f * Mathf.PI; currSineOffset = (Random.value * 2.0f - 1.0f) * sineOffset + // offset 2.0f * Mathf.Cos(currSinePhi) / Mathf.PI * currSineHeight; // normalize currSineRotation = Random.value * 2.0f * Mathf.PI;&#125;float arcAmp = currArcMaxHeight * animationTime; 设定关键点的位置 整条闪电由 numKeyPoints + 2 个关键点构成，其中的首尾两个位置的点位置不变。而对于中间的关键点，需要通过之前的动画参数和随机数值确定真正的位置 基础位置 基础位置可以简单地通过 startPos + n * pos_step * (i + 1) 得到。在均匀的基础位置的基础上，如果加入了径向位置偏移，则还需要加上偏移量 Arc 视频中第一个效果是一个反复出现的弧形，这里我们使用一个简单的二次函数来拟合它： H(x)=k(x−0.5)2+Cmax⁡∗tH(x) = k(x - 0.5)^2 + C_{\\max}*t H(x)=k(x−0.5)2+Cmax​∗t 其中的 x,tx, tx,t 分别是当前关键点在闪电路径上的位置和动画播放的位置（范围均在 [0,1][0, 1][0,1] 之间），而 CCC 则对应了当前动画区间中的最大振幅， kkk 是一个需要求解的未知量。求解的方法也十分简单，使用 H(0)=H(1)=0H(0) = H(1) = 0H(0)=H(1)=0 的条件即可得到对应的 kkk 值。最后，加上一个表示这个波偏向的方向的角度 currArcTangentDeg 即可得到最终的偏移量。偏移的过程如下： 123float arcAmpAtT = arcAmp * (1.0f - 4.0f * (t - 0.5f) * (t - 0.5f));pos += currArcTangentDir.x * x * arcAmpAtT * tangentRandomScale.Evaluate(t);pos += currArcTangentDir.y * y * arcAmpAtT * tangentRandomScale.Evaluate(t); 其中 currArcTangentDir 保存了该角度对应在单位圆上的位置，便于直接与局部坐标系相乘 Sine 第二个效果是一个并不完整的波，这里我们使用一个切割过的三角函数拟合它： H(x)={(x/x0)S(x0),x∈[0,max⁡(0,x0))S(x),x∈[x0,x1)(1−x)/(1−x1)S(x1),x∈[min⁡(x1,1),1],S(x)=sin⁡(πx/(x1−x0)+ϕ+t)+offsetH(x) = \\begin{cases} (x / x_0) S(x_0) &amp; , x \\in [0, \\max(0, x_0))\\\\ S(x) &amp; , x \\in [x_0, x_1)\\\\ (1 - x) / (1 - x_1) S(x_1) &amp; , x \\in [\\min(x_1, 1), 1]\\\\ \\end{cases} , S(x) = \\sin(\\pi x / (x_1 - x_0) + \\phi + t) + offsetH(x)=⎩⎪⎨⎪⎧​(x/x0​)S(x0​)S(x)(1−x)/(1−x1​)S(x1​)​,x∈[0,max(0,x0​)),x∈[x0​,x1​),x∈[min(x1​,1),1]​,S(x)=sin(πx/(x1​−x0​)+ϕ+t)+offset 这个波的偏移方向应该和之前的弧相同。上式中的 x0,x1x_0, x_1x0​,x1​ 表示了波开始的左侧和右侧位置，offsetoffsetoffset 除了输入参数乘以随机数的结果以外，还减去了波上的积分（即首先将波移动到中心）。最后的偏移过程如下： 1234567891011121314151617float sineAmpAtT = 0;float phi = currSinePhi + animationTime;float sineRotationDeg = (t - 0.5f) * currSineRotation + currArcTangentDeg;if (t &lt; currSineLT)&#123; sineAmpAtT = t / currSineLT * (Mathf.Sin(phi) * currSineHeight + currSineOffset);&#125;if (t &gt;= currSineLT &amp;&amp; t &lt;= currSineRT)&#123; sineAmpAtT = Mathf.Sin(phi + (t - currSineLT) / (currSineRT - currSineLT) * Mathf.PI) * currSineHeight + currSineOffset;&#125;if (t &gt; currSineRT)&#123; sineAmpAtT = (1.0f - t) / (1.0f - currSineRT) * (-Mathf.Sin(phi) * currSineHeight + currSineOffset);&#125;pos += sineAmpAtT * Mathf.Sin(sineRotationDeg) * x * tangentRandomScale.Evaluate(t);pos += sineAmpAtT * Mathf.Cos(sineRotationDeg) * y * tangentRandomScale.Evaluate(t); 随机扰动 随机扰动包括了位置上的随机性和宽度上的随机性，均通过简单加上随机数的方式解决。 12345678// positionpos += tangentOffsets[i].x * x * tangentRandomRadius * tangentRandomScale.Evaluate(t);pos += tangentOffsets[i].y * y * tangentRandomRadius * tangentRandomScale.Evaluate(t);full_positions[i + 1] = pos;// widthfloat width = startWidth + width_step * (i + 1);width += widthOffsets[i] * t * widthRandomSize;full_curve.AddKey(t, width); 其它控制 注意到上面所有有关切向偏移的代码中均乘以了一个 tangentRandomScale.Evaluate(t) ，这个参数可以提供更加有意义的闪电形状（比如两侧靠近定点而中间偏移摆动大）。另一个控制项是起止的位置，可以用于做出闪电生长的动画。最后，你可以控制噪声演进的速度和一轮动画的时长来制造更多差异性的效果。 叠加不同参数的闪电 将脚本拖动到空对象上、增加一个 LineRenderer 、把材质扔上去，你就获得了一根闪电。通过将不同参数的闪电叠加在一起，你就可以获得一个看起来还不错的闪电效果。","categories":[{"name":"programming","slug":"programming","permalink":"https://blog.apassbydreg.work/categories/programming/"},{"name":"gamedev","slug":"programming/gamedev","permalink":"https://blog.apassbydreg.work/categories/programming/gamedev/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://blog.apassbydreg.work/tags/Unity/"},{"name":"FX","slug":"FX","permalink":"https://blog.apassbydreg.work/tags/FX/"}]},{"title":"《深度探索C++对象模型》第三章笔记 | Notes for Inside Cpp Object Model Chapter 03","slug":"InsideCppObjectModel-ch03","date":"2021-10-26T09:27:21.000Z","updated":"2021-11-17T17:39:57.770Z","comments":true,"path":"2021/10/InsideCppObjectModel-ch03/","link":"","permalink":"https://blog.apassbydreg.work/2021/10/InsideCppObjectModel-ch03/","excerpt":"","text":"在这一章中，类的 data members 和 class hierarchy 是中心议题。一个类的 data members 可以表现这个类在运行中的某种状态，而 data members 的 static 与否则体现了这个状态是被单个实例使用还是所有的该类的实例所使用。 3.1 Data Members 的绑定 在 C++ 最早的编译器上，变量定义的位置会影响事实上获取的值。考虑如下代码： 12345678910extern int v;class Sample&#123;public: // 注意：在早期 C++ 编译器中，这个函数会返回外部的 v int f() &#123; return v; &#125;private: int v;&#125;;// 近代 C++ 编译器会在这个位置分析函数实体，最后返回类内的 v 虽然这个情况在 C++ 2.0 后消失了（现代 C++ 编译器会按照语义返回类对象的变量值），这个古老的语言规则称为 member rewriting rule ，内容大意是：一个函数实体在整个 class 的声明结束前不会被分析。 然而，对于 member function 中的参数列表却并非如此，参数列表中的内容在可分析的情况下是就地 resolve 的，例如下面的代码： 12345678910111213typedef float l;class Sample&#123;public: // 注意：这里的传入值是一个浮点数，而不是下面定义的 long long void test(l _a) &#123; a = _a; cout &lt;&lt; _a &lt;&lt; endl; // 因此这个位置会输出一个浮点值 &#125;; typedef long long l; // 这里的 typedef 并不会被上文看到 l a; // 这是一个 long long 类型的数据&#125;; 3.2 Data Members 的布局 C++ Standard 要求：在同一个 access section（即 public, private, protected ）中，较晚出现的变量在内存中有较高的地址。然而，标准并不要求各个变量一定要连续排列，也没有要求在不同的 access section 之间的变量需要有明确的先后关系。 大多数编译器选择把多个 access section 合并在一起，并按照声明的次序形成一个连续区块。access sections 的数量并不会引起额外负担。 3.3 Data Member 的存取 3.3.1 Static Data Members 所有 static 变量被编译器提出于类外，被视为只在该类的生命范围内可见的全局变量。每个 static data member 只有一个实体，它被存放于程序的 data segment 中。每次程序操作该变量，编译器会将其转化为对该唯一的 extern 实体的直接操作。 无论是从 class object 使用 member selection operator（即 . 运算符）、还是从一个复杂的派生类中取用、或者从函数的返回值取用，每一个这种变量的使用并不会导致任何时间或者空间上的额外负担。 3.3.2 Nonstatic Data Members 这些变量直接存放在每个 class object 中，必须通过 class object 才能对它们进行操作。编译器会将 class object 的起始地址加上该变量的偏移量操作。即： 123class Sample &#123;&#125;;Sample s;&amp;s.x == &amp;s + (&amp;Sample::_x - 1); 类变量的偏移量总被加上 1 ，这样能帮助编译系统区分出“一个指向 data member 的指针，用以指出 class 的第一个 member ” 和 “ 一个指向 data member 的指针，没有指出任何 member ” 这两种情况（这在 3.3.6 中有进一步讨论）。 对于确认变量类型的 class object 的 data member 操作，在任意情况下均不会产生任何额外开销，因为对确定类型而言所有的 offset 均可在编译器确定。 在使用指针或者引用实现多态的情况，对于来自 struct member 、单一 class member 、单继承、多继承的 data members，这些偏移量也可以在编译期间获知。而对于使用了 virtual base class 虚拟继承而来的变量，确认 offset 的过程必须延迟到执行期才能解决。 3.4 继承与 Data Members 在 C++ 继承模型中，一个派生类对象所表现出来的东西是其自己加上其基类的总和。但 derived class members 和 base class members 的排列次序并无规定。在大部分编译器上，基类的变量总是先出现，但一旦碰上 virtual base class 就说不准了。 本节讨论了不同情况下的 data members 的排列情况 3.4.1 只有继承，没有多态 这种不含多态的情况称为具体继承（ concrete inheritance ，与虚继承相对）。一般而言，这种情况并不会增加额外开销。然而，需要注意的是这种写法可能带来一些问题： 容易重复设计出一些作用相同的函数 由于要求继承下来的类的完整性，可能累加不必要的 padding 从而带来额外的空间开销 3.4.2 含有多态的继承 一旦引入多态，势必要增加额外开销，包括了： 增加 vtbl 用于存储对应类型的虚函数入口 在 class object 中增加 vptr 指向 vtbl 在执行期需要通过跳转才能访问函数入口 修改对应的 constructor 和 destructor 设定和删除 vptr 的值 在引入了 vptr 后，一个重要的问题是应该把它放在什么位置： 早期的编译器中，它被放置于 class object 的尾端。这样可以保留 base class 的 C struct 布局，从而允许对象在 C 代码中继续使用。而随着虚继承和抽象基类的引入、加上 OO 编程方式的兴起，一些编译器开始将 vptr 置于 class object 的头部。这对于在多继承下通过指向 class members 的指针调用 virtual function 带来帮助（比如可以合并第一个基类和派生类的 vptr ，让它们指向一个同样的虚函数表，只不过不同指针的访问范围不同）。这两种布局的示意图如下： vptr 在尾部：继承了一个含有虚函数的类 vptr 在头部：继承自一个不含虚函数的类，但类中包含虚函数 特别地，以 g++ 在 c++11 标准下的编译结果为例，内存布局可能是这样的： 3.4.3 多继承 在将虚指针置于尾部时，单继承的派生类和基类的起始地址一样·，这是一种「自然」的继承情况（其实在将指针置于头部时对于大多数编译器也满足这一情况）。 多继承的复杂度在于派生类和其上一个的基类，乃至上上个基类之间都很有可能出现不自然的情况。编译器需要介入设定在类型转换时需要使用的地址偏移。 一般而言，基类在派生类中的排布是连续且遵循声明顺序的。对于一个多重派生对象，其第一个基类的 subobject 的指针仍然等价于派生类本身的指针，而后续的基类的指针则需要加上前面的类型 subobjects 的大小。 一种多重继承的示意图如下： 3.4.4 虚拟继承 多重继承在语义上的副作用在于它必须支持某种形式的 shared subobject 继承，一个典型的例子是最早的 iostream 库： 1234class ios &#123; ... &#125;;class istream : public virtual ios &#123; ... &#125;;class ostream : public virtual ios &#123; ... &#125;;class iostream : public istream, public ostream &#123; ... &#125;; 一般的实现方法是：当一个类内如果含有一个或者多个 virtual base class objects，它将被分割为两个部分：不变部分与共享部分。不变部分的数据总是具有固定的 offset 可以直接操作，而共享部分则通过由各个编译器实现的方式间接操作。 最基础的实现方法是在每个派生类中插入一些指向 virtual base class object 的指针，但这种方法有两个缺点： 每个对象因为虚拟继承带来的额外开销不是固定的 虚拟继承链的加长会导致间接存储层次的增加，而不是固定的额外开销 对于第二个问题，大部分编译器都通过在编译器取得所有的 nested virtual base class 指针放到派生类中，从而解决固定存储时间的问题。如将 a.(subobj_b).(subobj_c).var 转化为 a.(subobj_b_c).var 。 对于第一个问题有两种解决方案： MSVC 编译器引入了类似 vtbl 的所谓 virtual base class pointer table 的概念 在 vtbl 中存放 virtual base class offset 。如在 Sun 编译器中，vtbl 可以被正值或者负值索引，其中负值的位置存放 virtual base class offset 因为虚拟继承会产生额外的开销，所以对于它而言最有效的运用方式是使用一个抽象的 virtual base class，而其中没有任何 data member 3.5 对象成员的效率 在没有继承关系的情况下，如果打开优化（这是为了避免出现因为编译器的策略原因出现的扰动），所有对象成员的使用效率是完全一致的。这在可以直接确定数据地址的单一继承下，情况也是一样的。 然而，一旦引入虚拟继承，测试中所有的编译器都歇菜了。哪怕访问的成员是一个可以在编译期间就能确定地址的非多态对象，虽然不开优化的情况下效率变化并不大，但打开优化之后的效率仍然有显著的降低。这可能说明了间接性会严重影响「将运算移向寄存器或缓存执行」的优化能力。 3.6 指向 Data Members 的指针 使用语法 &amp;Class::data_member_name 可以获取该成员变量在类内的指针（偏移量）。并使用 class_object_ptr-&gt;(*data_member_ptr) 应用这个指针。 这种偏移量的做法会遇到无法区分 NULL 指针和指向偏移量为 0 的 data member 的指针的问题。这要求所有真正的 member offset 的值均被加一，而在使用这个值时需要注意减一后使用。然而，在部分编译器（如 MSVC ）中这个过程被优化了。这意味着如果你打印这些值，你得到的是原始的偏移量而非加一后的结果。 另外一个需要注意的点是这种指针本身也支持多态。指向基类 data member 的指针可以与指向派生类 data member 互相转换，但这因为继承机制的介入需要加入 subobject 的偏移量而变得相当复杂并产生运行时的额外开销。 使用这种指针的效率表现和在不同情况下使用对象成员的效率是一致的。在虚拟继承以外的场景，打开优化后并不会有明显的效率变化，而一旦引入虚拟继承，虽然不优化的情况下间接层数对效率只有小幅度的影响，却对优化的情况下有重大的影响。原因和直接使用对象成员的情况下是一样的。","categories":[{"name":"programming","slug":"programming","permalink":"https://blog.apassbydreg.work/categories/programming/"},{"name":"reading notes","slug":"programming/reading-notes","permalink":"https://blog.apassbydreg.work/categories/programming/reading-notes/"}],"tags":[{"name":"OOP","slug":"OOP","permalink":"https://blog.apassbydreg.work/tags/OOP/"},{"name":"C++","slug":"C","permalink":"https://blog.apassbydreg.work/tags/C/"},{"name":"深度探索C++对象模型","slug":"深度探索C-对象模型","permalink":"https://blog.apassbydreg.work/tags/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"}]},{"title":"PBRT 第三章笔记（基础篇） | Notes for PBRT Chapter 03 - Shapes (basis)","slug":"PBRT-ch03","date":"2021-10-25T06:18:49.000Z","updated":"2021-11-04T14:23:43.575Z","comments":true,"path":"2021/10/PBRT-ch03/","link":"","permalink":"https://blog.apassbydreg.work/2021/10/PBRT-ch03/","excerpt":"","text":"3.1 Basic Shape Interface Shape 基类的完整定义如下： 123456789101112131415161718192021222324252627282930313233343536373839class Shape &#123; public: // Shape Interface Shape(const Transform *ObjectToWorld, const Transform *WorldToObject, bool reverseOrientation); virtual ~Shape(); virtual Bounds3f ObjectBound() const = 0; virtual Bounds3f WorldBound() const; virtual bool Intersect(const Ray &amp;ray, Float *tHit, SurfaceInteraction *isect, bool testAlphaTexture = true) const = 0; virtual bool IntersectP(const Ray &amp;ray, bool testAlphaTexture = true) const &#123; return Intersect(ray, nullptr, nullptr, testAlphaTexture); &#125; virtual Float Area() const = 0; // Sample a point on the surface of the shape and return the PDF with // respect to area on the surface. virtual Interaction Sample(const Point2f &amp;u, Float *pdf) const = 0; virtual Float Pdf(const Interaction &amp;) const &#123; return 1 / Area(); &#125; // Sample a point on the shape given a reference point |ref| and // return the PDF with respect to solid angle from |ref|. virtual Interaction Sample(const Interaction &amp;ref, const Point2f &amp;u, Float *pdf) const; virtual Float Pdf(const Interaction &amp;ref, const Vector3f &amp;wi) const; // Returns the solid angle subtended by the shape w.r.t. the reference // point p, given in world space. Some shapes compute this value in // closed-form, while the default implementation uses Monte Carlo // integration; the nSamples parameter determines how many samples are // used in this case. virtual Float SolidAngle(const Point3f &amp;p, int nSamples = 512) const; // Shape Public Data const Transform *ObjectToWorld, *WorldToObject; const bool reverseOrientation; const bool transformSwapsHandedness;&#125;; 所有物体均被定义在物体坐标系下，为了将物体位置在物体坐标系和世界坐标系之间相互转换，此类中储存了两个相反的变换 ObjectToWorld, WorldToObject 布尔值 reverseOrientation 用于判断在处理时是否需要将物体表面的法线方向取反，而 transformSwapsHandedness 则储存了变换 ObjectToWorld 中用于确认手性是否改变的函数 SwapsHandedness() 的返回值，这样就不需要每次进行光线求交时反复调用该函数了。 3.1.1 包围盒 PBRT 使用坐标对齐的边缘包围盒加速渲染的过程。一个物体需要提供它在物体坐标系的包围盒以及在世界坐标系的包围盒的接口。其中在世界坐标系的包围盒接口默认由对物体坐标系的包围盒做变换得到。然而，这是一种极其不高效的做法（如下图所示） 3.1.2 光线 - 包围盒相交 包围盒类提供了光线相交的函数 Bounds3::IntersectP(const Ray&amp;, Float*, Float*) 以得到光线和它自身相交发生的两个时间。它使用了一种快速且有效的方法： 将光线投影到对每个坐标轴，分别计算光线与各个位置相交的时间范围 对所有时间范围取交集，检查是否非空 由于需要计算光线各个方向的倒数并通过各个分量的正负检查是否需要交换 tnear / tfar ，PBRT 也提供了一个输入预计算参数版本的函数。 3.1.3 相交测试 Shape 类的派生类需要实现两种相交测试的函数：返回交点位置和表面信息的 Intersect() 和仅返回是否相交的 IntersectP() 由于部分模型提供了 Alpha 裁剪用的材质，这两者均需要传入一个表示是否启用这一功能的参数 testAlphaTexture 。 虽然 PBRT 提供了一种简单地通过调用 Intersect 并忽略其它结果的 IntersectP 的实现，但大部分派生类都会提供更加高效的方法。 3.1.4 表面积 当一个形状被用于面光源时，需要计算其表面积。Shape 基类提供了这一接口。 1virtual Float Area() const = 0; 3.1.5 单面 / 双面材质（Sidedness） 在大部分渲染系统中均支持 one-sided 的性质，物体在一侧观看时可见，而从另一侧观看时不可见。虽然这一性质在某些情况下提高部分隐藏面删除算法的效率，但在光线追踪的渲染器中并不会有多大的性能影响。这是因为光线追踪的流程中光线相交判断先于法线方向判断，而且这种做法可能导致物理上的不正确。 PBRT 并不支持这一特性。 3.2 Spheres 球体是二次曲面（用二次多项式表示曲面）的一种特殊情况。这类曲面比较容易实现光线相交的算法。数学上，球面被定义为 x2+y2+z2=r2x^2 + y^2 + z^2 = r^2x2+y2+z2=r2 ，使用极坐标表示为： {x=rsin⁡θcos⁡ϕy=rsin⁡θsin⁡ϕz=rcos⁡θ\\begin{cases} x = r\\sin\\theta\\cos\\phi\\\\ y = r\\sin\\theta\\sin\\phi\\\\ z = r\\cos\\theta \\end{cases}⎩⎪⎨⎪⎧​x=rsinθcosϕy=rsinθsinϕz=rcosθ​ 其中，可以使用 ϕ,θ\\phi, \\thetaϕ,θ 构建一个到 uv∈[0,1]2uv \\in [0, 1]^2uv∈[0,1]2 的映射，结果如下： Sphere 类的定义如下： 123456789101112131415161718192021222324252627282930class Sphere : public Shape &#123; public: // Sphere Public Methods Sphere(const Transform *ObjectToWorld, const Transform *WorldToObject, bool reverseOrientation, Float radius, Float zMin, Float zMax, Float phiMax) : Shape(ObjectToWorld, WorldToObject, reverseOrientation), radius(radius), zMin(Clamp(std::min(zMin, zMax), -radius, radius)), zMax(Clamp(std::max(zMin, zMax), -radius, radius)), thetaMin(std::acos(Clamp(std::min(zMin, zMax) / radius, -1, 1))), thetaMax(std::acos(Clamp(std::max(zMin, zMax) / radius, -1, 1))), phiMax(Radians(Clamp(phiMax, 0, 360))) &#123;&#125; Bounds3f ObjectBound() const; bool Intersect(const Ray &amp;ray, Float *tHit, SurfaceInteraction *isect, bool testAlphaTexture) const; bool IntersectP(const Ray &amp;ray, bool testAlphaTexture) const; Float Area() const; Interaction Sample(const Point2f &amp;u, Float *pdf) const; Interaction Sample(const Interaction &amp;ref, const Point2f &amp;u, Float *pdf) const; Float Pdf(const Interaction &amp;ref, const Vector3f &amp;wi) const; Float SolidAngle(const Point3f &amp;p, int nSamples) const; private: // Sphere Private Data const Float radius; const Float zMin, zMax; const Float thetaMin, thetaMax, phiMax;&#125;; 其中的 zMin, zMax, thetaMin, thetaMax 提供了上下的裁剪，phiMax 提供了切面的裁剪 3.2.1 物体坐标下的包围盒 这部分的实现较为直观，这里直接放代码： 1234Bounds3f Sphere::ObjectBound() const &#123; return Bounds3f(Point3f(-radius, -radius, zMin), Point3f( radius, radius, zMax));&#125; 这种方法并非最优解，比如当 ϕmax⁡\\phi_{\\max}ϕmax​ 的值小于 3π/23\\pi / 23π/2 时或当 zMin, zMax 裁切到同一半球上时都可以提供更紧的包围盒。 3.2.2 相交判定 求交的流程如下： 将光线转换到物体坐标系下，得到方程 (ox+tdx)2+(oy+tdy)2+(oz+tdz)2=r2(o_x + td_x)^2 + (o_y + td_y)^2 + (o_z + td_z)^2 = r^2(ox​+tdx​)2+(oy​+tdy​)2+(oz​+tdz​)2=r2 整理为标准二次函数 at2+bt+c=0at^2 + bt + c = 0at2+bt+c=0 并使用公式求解 ttt 获取最近的交点并验证是否超过光线的 tMax 从 ttt 得到交点位置，求解 ϕ,θ\\phi, \\thetaϕ,θ 得到 uv 使用 thetaMin, thetaMax, phiMax 验证裁剪 计算误差范围（PBRT 误差管理使用） 设置 insec 和 tHit 结果 3.2.3 法线的偏导 这部分描述了法线关于 uv 的偏导计算方法，容我以后再看 3.2.4 SurfaceInteraction 初始化 由于在光线的方向向量并不需要单位化，因此在变换后使用这个方向向量计算出的 ttt 并不会因为应用了变换而改变。可以直接传入之前用二次方差求根公式计算出来的 ttt 设置 tHit 。 Sphere::IntersectP 函数则与需要返回详细信息的 Sphere::Intersect 相似，唯一的区别在于其不需要设置返回信息。 3.2.5 表面积 剪切后的表面积如下（计算过程略）： 123Float Sphere::Area() const &#123; return phiMax * radius * (zMax - zMin);&#125; 3.3 Cylinders 12345678910111213141516171819202122class Cylinder : public Shape &#123; public: // Cylinder Public Methods Cylinder(const Transform *ObjectToWorld, const Transform *WorldToObject, bool reverseOrientation, Float radius, Float zMin, Float zMax, Float phiMax) : Shape(ObjectToWorld, WorldToObject, reverseOrientation), radius(radius), zMin(std::min(zMin, zMax)), zMax(std::max(zMin, zMax)), phiMax(Radians(Clamp(phiMax, 0, 360))) &#123;&#125; Bounds3f ObjectBound() const; bool Intersect(const Ray &amp;ray, Float *tHit, SurfaceInteraction *isect, bool testAlphaTexture) const; bool IntersectP(const Ray &amp;ray, bool testAlphaTexture) const; Float Area() const; Interaction Sample(const Point2f &amp;u, Float *pdf) const; protected: // Cylinder Private Data const Float radius, zMin, zMax, phiMax;&#125;; 需要注意的是，这里的柱面并不包含上下底面。 柱面的方程是 x2+y2=r2,z∈(zmin⁡,zmax⁡)x^2+y^2=r^2, z\\in(z_{\\min},z_{\\max})x2+y2=r2,z∈(zmin​,zmax​) ，其与球面的处理流程是一致的 3.4 Disks 12345678910111213141516171819202122class Disk : public Shape &#123; public: // Disk Public Methods Disk(const Transform *ObjectToWorld, const Transform *WorldToObject, bool reverseOrientation, Float height, Float radius, Float innerRadius, Float phiMax) : Shape(ObjectToWorld, WorldToObject, reverseOrientation), height(height), radius(radius), innerRadius(innerRadius), phiMax(Radians(Clamp(phiMax, 0, 360))) &#123;&#125; Bounds3f ObjectBound() const; bool Intersect(const Ray &amp;ray, Float *tHit, SurfaceInteraction *isect, bool testAlphaTexture) const; bool IntersectP(const Ray &amp;ray, bool testAlphaTexture) const; Float Area() const; Interaction Sample(const Point2f &amp;u, Float *pdf) const; private: // Disk Private Data const Float height, radius, innerRadius, phiMax;&#125;; 这里的盘面也可以是一个同心圆环，其 uv 就定义在展开的圆环上 光线与盘面相交的算法非常简单，并不需要求解二次方程：由于圆盘的 z 位置是确定的，只需要求光线与该平面的交点，再计算交点是否在盘内即可。特别的，如果该光线与盘面平行（无论在平面内还是在平面外），则视为没有相交。 3.5 Other Quadrics PBRT 支持的其它二次曲面的计算方法和球面、柱面是一致的 3.5.1 锥面 锥面的函数定义为： (hxr)2+(hyr)2−(z−h)2=0\\left(\\frac{h x}{r}\\right)^{2}+\\left(\\frac{h y}{r}\\right)^{2}-(z-h)^{2}=0 (rhx​)2+(rhy​)2−(z−h)2=0 由其表面 uv 定义的参数方程为： ϕ=uϕmax⁡x=r(1−v)cos⁡ϕy=r(1−v)sin⁡ϕz=vh\\begin{aligned} &amp;\\phi=u \\phi_{\\max } \\\\ &amp;x=r(1-v) \\cos \\phi \\\\ &amp;y=r(1-v) \\sin \\phi \\\\ &amp;z=v h \\end{aligned}​ϕ=uϕmax​x=r(1−v)cosϕy=r(1−v)sinϕz=vh​ 3.5.2 抛物面 抛物面的函数定义为： hx2r2+hy2r2−z=0\\frac{h x^2}{r^2}+\\frac{h y^2}{r^2}-z=0 r2hx2​+r2hy2​−z=0 由其表面 uv 定义的参数方程为： ϕ=uϕmax⁡z=v(zmax⁡−zmin⁡)r=rmax⁡zzmax⁡x=rcos⁡ϕy=rsin⁡ϕ\\begin{aligned} &amp;\\phi=u \\phi_{\\max } \\\\ &amp;z=v(z_{\\max}-z_{\\min})\\\\ &amp;r=r_{\\max}\\sqrt{z \\over z_{\\max}}\\\\ &amp;x=r \\cos \\phi \\\\ &amp;y=r \\sin \\phi \\\\ \\end{aligned}​ϕ=uϕmax​z=v(zmax​−zmin​)r=rmax​zmax​z​​x=rcosϕy=rsinϕ​ 3.5.2 双曲面 双曲面的函数定义为： a(x2+y2)−bz2=−1a(x^2+y^2)-bz^2=-1 a(x2+y2)−bz2=−1 其中的参数 a,ba,ba,b 是通过传入曲面上的两个关键点决定的。由其表面 uv 定义的参数方程为： ϕ=uϕmax⁡xr=(1−v)x1+vx2yr=(1−v)y1+vy2x=xrcos⁡ϕ−yrsin⁡ϕy=xrsin⁡ϕ+yrcos⁡ϕz=(1−v)z1+vz2\\begin{aligned} \\phi &amp;=u \\phi_{\\max } \\\\ x_{r} &amp;=(1-v) x_{1}+v x_{2} \\\\ y_{r} &amp;=(1-v) y_{1}+v y_{2} \\\\ x &amp;=x_{r} \\cos \\phi-y_{r} \\sin \\phi \\\\ y &amp;=x_{r} \\sin \\phi+y_{r} \\cos \\phi \\\\ z &amp;=(1-v) z_{1}+v z_{2} \\end{aligned}ϕxr​yr​xyz​=uϕmax​=(1−v)x1​+vx2​=(1−v)y1​+vy2​=xr​cosϕ−yr​sinϕ=xr​sinϕ+yr​cosϕ=(1−v)z1​+vz2​​ 3.6 Triangle Meshes 三角形是 CG 领域中最常用的物体表示方法之一。 为了节省用于储存三角形的内存大小，PBRT 使用顶点列表 + 顶点编号的形式储存三角形物体，而非顺序地储存所有三角形的三个顶点。TriangleMesh 类（结构体）储存了一个三角形网格物体所具有的信息。 12345678910111213141516171819struct TriangleMesh &#123; // TriangleMesh Public Methods TriangleMesh(const Transform &amp;ObjectToWorld, int nTriangles, const int *vertexIndices, int nVertices, const Point3f *P, const Vector3f *S, const Normal3f *N, const Point2f *uv, const std::shared_ptr&lt;Texture&lt;Float&gt;&gt; &amp;alphaMask, const std::shared_ptr&lt;Texture&lt;Float&gt;&gt; &amp;shadowAlphaMask, const int *faceIndices); // TriangleMesh Data const int nTriangles, nVertices; std::vector&lt;int&gt; vertexIndices; std::unique_ptr&lt;Point3f[]&gt; p; std::unique_ptr&lt;Normal3f[]&gt; n; std::unique_ptr&lt;Vector3f[]&gt; s; std::unique_ptr&lt;Point2f[]&gt; uv; std::shared_ptr&lt;Texture&lt;Float&gt;&gt; alphaMask, shadowAlphaMask; std::vector&lt;int&gt; faceIndices;&#125;; 需要注意的是 TriangleMesh 对象中储存的三角形位置是在世界坐标系下的位置，因为使用世界坐标的场景多于模型坐标，这样避免了重复进行 ObjectToWorld 坐标转换。 3.6.1 Triangle PBRT 中，实际上实现了 Shape 接口的三角形物体类型是 Triangle ： 1234567891011121314151617181920212223242526272829class Triangle : public Shape &#123; public: // Triangle Public Methods Triangle(const Transform *ObjectToWorld, const Transform *WorldToObject, bool reverseOrientation, const std::shared_ptr&lt;TriangleMesh&gt; &amp;mesh, int triNumber); Bounds3f ObjectBound() const; Bounds3f WorldBound() const; bool Intersect(const Ray &amp;ray, Float *tHit, SurfaceInteraction *isect, bool testAlphaTexture = true) const; bool IntersectP(const Ray &amp;ray, bool testAlphaTexture = true) const; Float Area() const; using Shape::Sample; // Bring in the other Sample() overload. Interaction Sample(const Point2f &amp;u, Float *pdf) const; // Returns the solid angle subtended by the triangle w.r.t. the given // reference point p. Float SolidAngle(const Point3f &amp;p, int nSamples = 0) const; private: // Triangle Private Methods void GetUVs(Point2f uv[3]) const; // Triangle Private Data std::shared_ptr&lt;TriangleMesh&gt; mesh; const int *v; int faceIndex;&#125;; 每个 Triangle 类表示一个三角形，成员指针 v 指向了这个三角形对应的三个顶点的数组的起始元素。 模型坐标的包围盒与世界坐标的包围盒均可通过简单地合并三个由顶点初始化而成的包围盒得到。 3.6.2 光线-三角形求交 PBRT 的三角形求交算法分为以下几步： 找到一个仿射变换使得光线在变换后从原点开始沿 +z+z+z 方向传播 经过平移变换到原点 重新排列三个坐标的位置，使得绝对值最大的方向落在 zzz 轴上（这是为了避免直接变换可能产生的除零错误） 计算一个剪切变换让方向对准 zzz 轴 将这个变换同样应用于三角形的顶点上 在 xOyxOyxOy 平面上测试点 (0,0)(0, 0)(0,0) 是否在三角形内 考虑叉乘的特性，给定两点 p0,p1p_0, p_1p0​,p1​ 确定一条有向的直线，对于任意的第三点 ppp ，通过构造向量 p0p1→,p0p→\\overrightarrow{p_0 p_1}, \\overrightarrow{p_0 p}p0​p1​​,p0​p​ 并计算他们的叉乘，可以判断 p 点在直线的左侧、右侧还是直线上。 判断一个点是否在三角形内，只要顺时针遍历三角形的三条边并判断该点是否都在三条边的同一侧即可（特别地，当三个叉乘值均为零则说明三角形与 zzz 轴平行，算作不相交） 考虑叉乘的几何特性，上一步骤中得到的叉乘结果同样可以看作内部的小三角形的面积的一半。用这一特点可以计算三角形的重心坐标 bi=ei/∑kekb_i = e_i / \\sum^k e_kbi​=ei​/∑kek​ ，重心坐标可以用于给法线、uv 等顶点特性插值，满足 b0+b1+b2=1, b0p0+b1p1+b2p2=pb_0 + b_1 + b_2 = 1,\\ b_0p_0 + b_1p_1 + b_2p_2 = pb0​+b1​+b2​=1, b0​p0​+b1​p1​+b2​p2​=p 使用上述的重心坐标计算出三角形与 zzz 轴相交的位置，并将其与光线的 tMax 比较以判定是否超出光线范围或者在光线方向的另一侧。为了匹配三角形顶点选择顺序带来的符号变化，实际的比较方法如下： ∑ieizi&lt;tmax⁡∑ieiif∑iei&gt;0∑ieizi&gt;tmax⁡∑ieiotherwise\\begin{aligned} &amp; \\sum_ie_iz_i &lt; t_{\\max}\\sum_ie_i &amp; if \\sum_ie_i &gt; 0\\\\ &amp; \\sum_ie_iz_i &gt; t_{\\max}\\sum_ie_i &amp; otherwise \\end{aligned}​i∑​ei​zi​&lt;tmax​i∑​ei​i∑​ei​zi​&gt;tmax​i∑​ei​​ifi∑​ei​&gt;0otherwise​ 对于位置关于 uv 的偏导，我们使用一次展开表示面上的某一点： pi=po+ui∂p∂u+vi∂p∂vp_i = p_o + u_i\\frac{\\partial p}{\\partial u} + v_i\\frac{\\partial p}{\\partial v} pi​=po​+ui​∂u∂p​+vi​∂v∂p​ 对于交点 po=pp_o = ppo​=p 而言，假设三角形的三个顶点均满足上述关系，则有： (u0−u2v0−v2u1−u2v1−v2)(∂p/∂u∂p/∂v)=(p0−p2p1−p2)(∂p/∂u∂p/∂v)=(u0−u2v0−v2u1−u2v1−v2)−1(p0−p2p1−p2)\\begin{aligned}&amp;\\left(\\begin{array}{ll}u_{0}-u_{2} &amp; v_{0}-v_{2} \\\\u_{1}-u_{2} &amp; v_{1}-v_{2}\\end{array}\\right)\\left(\\begin{array}{l}\\partial \\mathrm{p} / \\partial u \\\\\\partial \\mathrm{p} / \\partial v\\end{array}\\right)=\\left(\\begin{array}{l}\\mathrm{p}_{0}-\\mathrm{p}_{2} \\\\\\mathrm{p}_{1}-\\mathrm{p}_{2}\\end{array}\\right) \\\\&amp;\\left(\\begin{array}{l}\\partial \\mathrm{p} / \\partial u \\\\\\partial \\mathrm{p} / \\partial v\\end{array}\\right)=\\left(\\begin{array}{ll}u_{0}-u_{2} &amp; v_{0}-v_{2} \\\\u_{1}-u_{2} &amp; v_{1}-v_{2}\\end{array}\\right)^{-1}\\left(\\begin{array}{l}\\mathrm{p}_{0}-\\mathrm{p}_{2} \\\\\\mathrm{p}_{1}-\\mathrm{p}_{2}\\end{array}\\right)\\end{aligned} ​(u0​−u2​u1​−u2​​v0​−v2​v1​−v2​​)(∂p/∂u∂p/∂v​)=(p0​−p2​p1​−p2​​)(∂p/∂u∂p/∂v​)=(u0​−u2​u1​−u2​​v0​−v2​v1​−v2​​)−1(p0​−p2​p1​−p2​​)​ 最后，在设置返回信息和报告相交情况前，需要根据传入的 testAlphaTexture 开关和模型是否具有 alphaMask 的情况验证是否将该三角形剔除。 虽然 SurfaceInteraction 的构造函数会初始化法线，但在本类中会以如下方式使用自己的方法生成法线： 如果有插值得到的法线，优先使用它 否则使用之前计算的三角形的两条边的正则化叉积 3.6.3 Shading Geometry Triangle 类会尝试使用插值初始化用于着色的几何体，完整过程如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// Compute shading normal _ns_ for triangleNormal3f ns;if (mesh-&gt;n) &#123; ns = (b0 * mesh-&gt;n[v[0]] + b1 * mesh-&gt;n[v[1]] + b2 * mesh-&gt;n[v[2]]); if (ns.LengthSquared() &gt; 0) ns = Normalize(ns); else ns = isect-&gt;n;&#125; else ns = isect-&gt;n;// Compute shading tangent _ss_ for triangleVector3f ss;if (mesh-&gt;s) &#123; ss = (b0 * mesh-&gt;s[v[0]] + b1 * mesh-&gt;s[v[1]] + b2 * mesh-&gt;s[v[2]]); if (ss.LengthSquared() &gt; 0) ss = Normalize(ss); else ss = Normalize(isect-&gt;dpdu);&#125; else ss = Normalize(isect-&gt;dpdu);// Compute shading bitangent _ts_ for triangle and adjust _ss_Vector3f ts = Cross(ss, ns);if (ts.LengthSquared() &gt; 0.f) &#123; ts = Normalize(ts); ss = Cross(ts, ns);&#125; else CoordinateSystem((Vector3f)ns, &amp;ss, &amp;ts);// Compute $\\dndu$ and $\\dndv$ for triangle shading geometryNormal3f dndu, dndv;if (mesh-&gt;n) &#123; // Compute deltas for triangle partial derivatives of normal Vector2f duv02 = uv[0] - uv[2]; Vector2f duv12 = uv[1] - uv[2]; Normal3f dn1 = mesh-&gt;n[v[0]] - mesh-&gt;n[v[2]]; Normal3f dn2 = mesh-&gt;n[v[1]] - mesh-&gt;n[v[2]]; Float determinant = duv02[0] * duv12[1] - duv02[1] * duv12[0]; bool degenerateUV = std::abs(determinant) &lt; 1e-8; if (degenerateUV) &#123; Vector3f dn = Cross(Vector3f(mesh-&gt;n[v[2]] - mesh-&gt;n[v[0]]), Vector3f(mesh-&gt;n[v[1]] - mesh-&gt;n[v[0]])); if (dn.LengthSquared() == 0) dndu = dndv = Normal3f(0, 0, 0); else &#123; Vector3f dnu, dnv; CoordinateSystem(dn, &amp;dnu, &amp;dnv); dndu = Normal3f(dnu); dndv = Normal3f(dnv); &#125; &#125; else &#123; Float invDet = 1 / determinant; dndu = (duv12[1] * dn1 - duv02[1] * dn2) * invDet; dndv = (-duv12[0] * dn1 + duv02[0] * dn2) * invDet; &#125;&#125; else dndu = dndv = Normal3f(0, 0, 0);if (reverseOrientation) ts = -ts;isect-&gt;SetShadingGeometry(ss, ts, dndu, dndv, true); 3.6.4 表面积 使用叉乘模长的一半求面积 3.7 Curves ⚠️ 这部分描述了曲线类型的形状，容我以后再看。 3.8 Subdivision Surfaces ⚠️ 这部分描述了细分表面类型的形状，容我以后再看。 3.9 Managing Rounding Error ⚠️ 这部分描述了 PBRT 是解决浮点错误的方法，容我以后再看。","categories":[{"name":"programming","slug":"programming","permalink":"https://blog.apassbydreg.work/categories/programming/"},{"name":"reading notes","slug":"programming/reading-notes","permalink":"https://blog.apassbydreg.work/categories/programming/reading-notes/"}],"tags":[{"name":"CG","slug":"CG","permalink":"https://blog.apassbydreg.work/tags/CG/"},{"name":"render","slug":"render","permalink":"https://blog.apassbydreg.work/tags/render/"},{"name":"PBRT","slug":"PBRT","permalink":"https://blog.apassbydreg.work/tags/PBRT/"}]},{"title":"《深度探索C++对象模型》第一章笔记 | Notes for Inside Cpp Object Model Chapter 01","slug":"InsideCppObjectModel-ch01","date":"2021-10-22T05:11:58.000Z","updated":"2021-11-04T14:21:47.856Z","comments":true,"path":"2021/10/InsideCppObjectModel-ch01/","link":"","permalink":"https://blog.apassbydreg.work/2021/10/InsideCppObjectModel-ch01/","excerpt":"","text":"1.1 C++ 对象模式 non-static data members 被存放在每个 class object 中 static members 和 non-static function members 被存放在所有 class object 外 每个 class 产出一个指向 virtual functions 的虚函数表（vtbl），并为每个 class object 添加一个指向相关的虚函数表的指针（vptr） class 相关的 type_info 信息也在 vtbl 中，通常存放于第一个 slot 每个 class object 包含一个指向 base classes 表的指针（bptr） 1.2 关键词差异 一般来说不去碰 struct ，除非是纯数据结构或涉及传入已编译的 C 函数的情况 1.3 对象的差异 1.3.1 编程模式 程序模型（procedural model）：C 风格编程，使用单独的数据结构和函数集 抽象数据类型模型（ADT model）：通过提供公共的表达式接口实现抽象的功能，如重载的运算符等，数据的类型可以在编译器获得 面向对象模型（OO model）：涉及多态等内容，通常通过引用和指针处理，有时需要支持运行时类型判断 1.3.2 指针的类型 在每个执行点，指针所指的 object 类型决定了函数调用的实体，这种类型信息并不维护于指针中，而是维护于 vptr 与所指的 vtbl 的链接中 1.3.3 指针操作与对象操作的区别 在面向对象模式中，当对指针或引用进行操作时，实际上改变的是它们对指向的内存的解释方式，而操作对象则会引起与类型相关的内存操作 因此，在 OO 模式下将一个 derived 类对象赋值给一个 base 类对象时会引起裁切，vptr 将会指向基类，而派生类相关的信息均会消除 从另一种角度说，在 OO 模式的指导下编译器会根据类型自动指定 vptr ，而不随程序员的类赋值操作改变（除非重载了赋值函数或采用 C 风格的直接内存操作）","categories":[{"name":"programming","slug":"programming","permalink":"https://blog.apassbydreg.work/categories/programming/"},{"name":"reading notes","slug":"programming/reading-notes","permalink":"https://blog.apassbydreg.work/categories/programming/reading-notes/"}],"tags":[{"name":"OOP","slug":"OOP","permalink":"https://blog.apassbydreg.work/tags/OOP/"},{"name":"C++","slug":"C","permalink":"https://blog.apassbydreg.work/tags/C/"},{"name":"深度探索C++对象模型","slug":"深度探索C-对象模型","permalink":"https://blog.apassbydreg.work/tags/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"}]},{"title":"《深度探索C++对象模型》第二章笔记 | Notes for Inside Cpp Object Model Chapter 02","slug":"InsideCppObjectModel-ch02","date":"2021-10-22T05:11:58.000Z","updated":"2021-11-04T14:21:47.857Z","comments":true,"path":"2021/10/InsideCppObjectModel-ch02/","link":"","permalink":"https://blog.apassbydreg.work/2021/10/InsideCppObjectModel-ch02/","excerpt":"","text":"2.1 Default Constructor C++ 标准称，对于一个没有任何由用户指定的构造函数的类，会有一个 default constructor 在编译器需要时被隐式地声明出来，这个 constructor 常常是没有任何作用的，例外是以下四种情况： 当这个类拥有带有 default constructor 的 member class object 时 当这个类的父类带有 default constructor 时 当这个类声明或继承了一个虚函数时（自动生成 vtbl 和 vptr 并嵌入类中） 当这个类派生自一个具有 virtual base class 的继承链时（类似虚指针的处理方式） 2.2 Copy Constructor 在以下三种情况下，会以一个 object 的内容作为另一个 class object 的初值： 使用一个 object 显式的给一个类变量初始化 函数的传入值是一个类 函数的返回值是一个类 2.2.1 Default Memberwise Initialization 当一个类不存在显式的 copy constructor 时，当 class object 以相同类型的另一个 object 作为初始值时，内部会使用 default memberwise initialization 初始化 其内部的 data member 会从原始 object 中拷贝除了 member class object 外的所有内容，并使用递归的方法处理 member class object 2.2.2 Bitwise Copy Semantics 一个类是否具有 bitwise copy semantics 决定了一个由编译器生成的 copy constructor 是否是有效用的。 在以下情况下，一个类不具备 bitwise copy semantics： 它内含一个存在 copy constructor 的 member class object 它继承于一个存在 copy constructor 的基类 它声明了一个或多个 virtual functions 它继承自一个含有 virtual base class 的继承链 2.2.3 vptr 的重新设定 当一个类被相同类型的 object 初始化时，vptr 的初始化可以直接拷贝，而当其由一个派生类或父类的 object 初始化时，则需要将 vptr 重定向会本类对应的 vtbl 2.2.4 Virtual Base Class Subobject 的处理 当一个类以其派生类的 object 初始化时会引起虚继承的问题，其 virtual base class 的位置需要重新定位，因此不能直接使用 bitwise copy 的操作 2.3 程序转化语义学 2.3.1 明确的初始化操作 这一部分的程序转换会将定义和初始化操作（调用 copy constructor）将被分离 2.3.2 参数的初始化 将一个 class object 作为参数传入函数时，相当于一个初始化操作，一般而言会通过以下两步实现： 构建一个临时变量，调用 copy constructor 初始化它 改写函数声明，将临时变量的引用传入函数 2.3.3 返回值的初始化 这一步在一开始是通过一个双阶段转化形成的： 将返回对象的 reference 加入函数的传入值 在返回前使用函数的返回值调用该 reference 的 copy constructor 这一点上有两种优化方式 程序员优化：程序员使用一个 constructor 调用作为返回值，编译器会直接将这个 constructor 调用应用于传入的返回值引用上 编译器优化（NRV named retrun value）：对返回的具名变量实施编译器层面的优化，将该函数中的该变量直接替换成返回值的引用 2.4 成员初始化列表（member initialization list） 在以下情况下，必须使用成员初始化列表： 初始化一个 reference member 初始化一个 const member 调用 base class 或 member class 的含参 constructor 时 编译器会一一操作 initialization list，以适当的次序（一般是变量的声明次序）在 constructor 的显式用户代码前插入初始化代码","categories":[{"name":"programming","slug":"programming","permalink":"https://blog.apassbydreg.work/categories/programming/"},{"name":"reading notes","slug":"programming/reading-notes","permalink":"https://blog.apassbydreg.work/categories/programming/reading-notes/"}],"tags":[{"name":"OOP","slug":"OOP","permalink":"https://blog.apassbydreg.work/tags/OOP/"},{"name":"C++","slug":"C","permalink":"https://blog.apassbydreg.work/tags/C/"},{"name":"深度探索C++对象模型","slug":"深度探索C-对象模型","permalink":"https://blog.apassbydreg.work/tags/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"}]},{"title":"PBRT 第二章笔记（基础篇） | Notes for PBRT Chapter 02 - Geometry and Transforms (basis)","slug":"PBRT-ch02","date":"2021-10-21T18:07:09.000Z","updated":"2021-11-04T14:23:55.308Z","comments":true,"path":"2021/10/PBRT-ch02/","link":"","permalink":"https://blog.apassbydreg.work/2021/10/PBRT-ch02/","excerpt":"","text":"2.1 Coordinate Systems PBRT 使用常规的三维坐标系 2.1.1 坐标系的手性 将手的大拇指、食指和中指比作一个三维直角坐标系，并以大拇指作为 x 轴，食指作为 y 轴，中指作为 z 轴即可确定坐标系的手性 PBRT 使用的坐标系类型为左手系。 2.2 Vectors PBRT 拥有两种基础的向量模板类，虽然可以利用含维度参数的单一模板来定义向量，但为了可以使用常用的 v.x, v.y 取值方式， PBRT 选择为不同维度的向量使用不同的模板 12template &lt;typename T&gt; class Vector2 &#123; ... &#125;;template &lt;typename T&gt; class Vector3 &#123; ... &#125;; 一些常用的向量类型定义如下： 1234typedef Vector2&lt;Float&gt; Vector2f;typedef Vector2&lt;int&gt; Vector2i;typedef Vector3&lt;Float&gt; Vector3f;typedef Vector3&lt;int&gt; Vector3i; 向量模板类包括了常用的操作： 加减乘除 点乘、叉乘（注意叉乘结果与坐标系类型无关） 正则化 获取最小、最大值和最小、最大值的位置 从一个向量构建局部坐标系 2.3 Points 与向量相似，PBRT 提供了两种基础的点模板类和若干 123456template &lt;typename T&gt; class Point2 &#123; ... &#125;;template &lt;typename T&gt; class Point3 &#123; ... &#125;;typedef Point2&lt;Float&gt; Point2f;typedef Point2&lt;int&gt; Point2i;typedef Point3&lt;Float&gt; Point3f;typedef Point3&lt;int&gt; Point3i; PBRT 将点和向量严格区分，并为点类提供了以下函数： 与向量的互相转化（但需要 explicit cast ） 加减某向量得到新的点 通过减法得到向量 数乘和点之间的相加（用于加权等数学操作） 求两向量的距离和距离的平方 对两个向量进行线性插值 component-wise 最大最小值和取整 对元素进行重排列（Permute() 函数） 2.4 Normals 由于法线是被定义在平面上的，其表现可能与普通的向量有所不同，因此 PBRT 使用了独立的法线模板类 12template &lt;typename T&gt; class Normal3 &#123; ... &#125;；typedef Normal3&lt;Float&gt; Normal3f; 一部分法线的操作和向量相同，并且提供了法线、向量混合类型的支持，包括了： Dot(), AbsDot() 数学运算 与向量互相转换的构造函数 法线也有一些特殊的函数： 计算在给定向量方向半球内的法线的 Faceforward() 2.5 Rays 1234567891011class Ray &#123;public: // Ray Public Methods ... // Ray Public Data Point3f o; Vector3f d; mutable Float tMax; Float time; const Medium *medium;&#125;; 光线主要由一个起始点 o 和一个方向向量 d 构成，并且含有一个表示最大长度的可变变量 tMax 除此之外，光线本身还被附加了和场景动画关联的时间 time 和与当前所在介质关联的介质指针 medium 光线类同时给出了包括计算光线位置、打印光线等功能的函数 2.5.1 光线微分（Ray Differentials） 为了赋予光线更多的信息，PBRT 基于 Ray 类和两条额外的辅助光线实现了光线的微分 123456789class RayDifferential : public Ray &#123;public: // RayDifferential Public Methods ... // RayDifferential Public Data bool hasDifferentials; Point3f rxOrigin, ryOrigin; Vector3f rxDirection, ryDirection;&#125;; 由于 RayDifferential 类继承自 Ray 类，大部分接口可以直接使用该类，并且只在需要微分信息的地方调用它 2.6 Bounding Boxes PBRT 使用 Axis Aligned Bounding Box (AABB) 加速运行，为此设计了储存包围盒的类型： 123456template &lt;typename T&gt; class Bounds2 &#123; ... &#125;;template &lt;typename T&gt; class Bounds3 &#123; ... &#125;;typedef Bounds2&lt;Float&gt; Bounds2f;typedef Bounds2&lt;int&gt; Bounds2i;typedef Bounds3&lt;Float&gt; Bounds3f;typedef Bounds3&lt;int&gt; Bounds3i; 一个包围盒可以由对角线上的两个点 pMix, pMax 表示如图 包围盒可以初始化为整个空间、一个点或根据给定的两点确定包围盒，它同样重载了中括号函数以方便访问八个角点的位置 其它工具函数包括： 合并或相交两个包围盒 判断点是否在包围盒内（含边界或仅含下边界） 使用一个固定的 margin 拓展包围盒 获取从极小点指向极大点的对角线向量 获取表面积与体积 获取最长边的序号 在盒内的单位坐标中进行线性插值得到点坐标，或给定点求盒内坐标 获取包围盒的包围球的中心和半径 2.7 Transformations 在 PBRT 中的变换是一种点到点、向量到向量的映射，PBRT 主要使用的变换需要满足以下条件： 线性 T(sv)=sT(v),T(v1+v2)=T(v1)+T(v2)T(sv) = sT(v), T(v_1+v_2) = T(v_1)+T(v_2)T(sv)=sT(v),T(v1​+v2​)=T(v1​)+T(v2​) 连续性 可逆性 PBRT 使用了 4×44 \\times 44×4 的矩阵表示线性变换 2.7.1 齐次坐标 PBRT 中的三维齐次坐标使用一个包括参考点、三轴方向的四元组 (vx,vy,vz,p0)(v_x,v_y,v_z,p_0)(vx​,vy​,vz​,p0​) 表示一个参考系，在参考系中的向量和点均被表示为一个四维向量，表示方式为： 向量：v=[sx,sy,sz,0]v = [s_x, s_y, s_z, 0]v=[sx​,sy​,sz​,0] 点：p=[sx,sy,sz,w]p = [s_x, s_y, s_z, w]p=[sx​,sy​,sz​,w] 将点从齐次坐标转换为常规三维坐标只需用前三个分量除以第四个分量 (x,y,z,w)→(xw,yw,zw)(x,y,z,w) \\to ({x \\over w}, {y \\over w}, {z \\over w}) (x,y,z,w)→(wx​,wy​,wz​) 在此表示方式下，一个齐次坐标系可以表示为一个 4×44 \\times 44×4 的矩阵，将坐标系中的向量或点转换到原始坐标系均可以通过将此向量和该矩阵相乘得到 使用矩阵的良好性质定义的变换类如下： 12345678910class Transform &#123;public: // Transform Public Methods ...private: // Transform Private Data Matrix4x4 m, mInv; friend class AnimatedTransform; friend struct Quaternion;&#125;; 为了避免在多个 Shape 中储存同样的 Transform 实例，物体的变换由一个指向需要的 Transform 的指针表示，而所有的 Transform 实例均储存在在 TransformCache 中 2.7.2 基本操作 构造函数 初始化为单位矩阵（等价变换） 用数组和矩阵初始化 构造逆变换（通过交换两个矩阵） 构造转置变换 2.7.3 平移变换 平移变换矩阵如下所示： (100Δx010Δy001Δz0001)\\left( \\begin{matrix} 1 &amp; 0 &amp; 0 &amp; \\Delta x\\\\ 0 &amp; 1 &amp; 0 &amp; \\Delta y\\\\ 0 &amp; 0 &amp; 1 &amp; \\Delta z\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{matrix} \\right)⎝⎜⎜⎛​1000​0100​0010​ΔxΔyΔz1​⎠⎟⎟⎞​ 2.7.4 伸缩变化 伸缩变换矩阵如下所示： (x0000y0000z00001)\\left( \\begin{matrix} x &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; y &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; z &amp; 0\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{matrix} \\right)⎝⎜⎜⎛​x000​0y00​00z0​0001​⎠⎟⎟⎞​ 2.7.5 基于坐标轴的旋转 Rx(θ)=(10000cos⁡θ−sin⁡θ00sin⁡θcos⁡θ00001)R_x(\\theta) = \\left( \\begin{matrix} 1 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; \\cos\\theta &amp; -\\sin\\theta &amp; 0\\\\ 0 &amp; \\sin\\theta &amp; \\cos\\theta &amp; 0\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{matrix} \\right)Rx​(θ)=⎝⎜⎜⎛​1000​0cosθsinθ0​0−sinθcosθ0​0001​⎠⎟⎟⎞​ Ry(θ)=(cos⁡θ0sin⁡θ00100−sin⁡θ0cos⁡θ00001)R_y(\\theta) = \\left( \\begin{matrix} \\cos\\theta &amp; 0 &amp; \\sin\\theta &amp; 0\\\\ 0 &amp; 1 &amp; 0 &amp; 0\\\\ -\\sin\\theta &amp; 0 &amp; \\cos\\theta &amp; 0\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{matrix} \\right)Ry​(θ)=⎝⎜⎜⎛​cosθ0−sinθ0​0100​sinθ0cosθ0​0001​⎠⎟⎟⎞​ Rz(θ)=(cos⁡θ−sin⁡θ00sin⁡θcos⁡θ0000100001)R_z(\\theta) = \\left( \\begin{matrix} \\cos\\theta &amp; -\\sin\\theta &amp; 0 &amp; 0\\\\ \\sin\\theta &amp; \\cos\\theta &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 1 &amp; 0\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{matrix} \\right)Rz​(θ)=⎝⎜⎜⎛​cosθsinθ00​−sinθcosθ00​0010​0001​⎠⎟⎟⎞​ 2.7.6 基于任意旋转轴的旋转 由给定向量和旋转轴可以构成一个局部坐标系，在局部坐标系下旋转并利用变换的合成方法结合即可，PBRT 中的代码如下 1234567891011121314151617181920212223Transform Rotate(Float theta, const Vector3f &amp;axis) &#123; Vector3f a = Normalize(axis); Float sinTheta = std::sin(Radians(theta)); Float cosTheta = std::cos(Radians(theta)); Matrix4x4 m; // Compute rotation of first basis vector m.m[0][0] = a.x * a.x + (1 - a.x * a.x) * cosTheta; m.m[0][1] = a.x * a.y * (1 - cosTheta) - a.z * sinTheta; m.m[0][2] = a.x * a.z * (1 - cosTheta) + a.y * sinTheta; m.m[0][3] = 0; // Compute rotations of second and third basis vectors m.m[1][0] = a.x * a.y * (1 - cosTheta) + a.z * sinTheta; m.m[1][1] = a.y * a.y + (1 - a.y * a.y) * cosTheta; m.m[1][2] = a.y * a.z * (1 - cosTheta) - a.x * sinTheta; m.m[1][3] = 0; m.m[2][0] = a.x * a.z * (1 - cosTheta) - a.y * sinTheta; m.m[2][1] = a.y * a.z * (1 - cosTheta) + a.x * sinTheta; m.m[2][2] = a.z * a.z + (1 - a.z * a.z) * cosTheta; m.m[2][3] = 0; return Transform(m, Transpose(m));&#125; 2.7.7 Look-At 变换 这是一个常用的摄像机相关变换，给定摄像机的位置、观察方向和摄像机的上侧向量即可得到一个从世界坐标到以相机为中心的坐标系变换矩阵。 由图中以及变换矩阵的定义可知： 矩阵的第 1 - 3 列分别是摄像机坐标系的三个方向 矩阵的第四列是摄像机中心坐标 2.8 Applying Transformations 2.8.1 - 2.8.2 点和向量的变换 这两种情况在上一部分中已经有过描述，直接进行矩阵 - 向量乘法即可 2.8.3 法线的变换 由于变换均作用于物体，即切线上，不能直接变换法线。假设作用于法线的变换矩阵为 SSS ，根据法线和切线 ttt 在变换 MMM 下的关系，有： \\begin{align} 0 &amp; = (n&#039;)^Tt&#039;\\\\ &amp; = (Sn)^T(Mt)\\\\ &amp; = n^T(S^TM)t\\\\ &amp; = n^Tt \\end{align} 因此对法线的变化相当于变换矩阵的逆的转置 S=(M−1)TS = (M^{-1})^TS=(M−1)T 2.8.4 光线的变换 相当于同时变换光线的起点和方向，而其它保持不变 2.8.5 包围盒的变换 在 PBRT 中，包围盒的变换相当于将包围盒的八个顶点处的极小包围盒合并起来： 123456789101112Bounds3f Transform::operator()(const Bounds3f &amp;b) const &#123; const Transform &amp;M = *this; Bounds3f ret(M(Point3f(b.pMin.x, b.pMin.y, b.pMin.z))); ret = Union(ret, M(Point3f(b.pMax.x, b.pMin.y, b.pMin.z))); ret = Union(ret, M(Point3f(b.pMin.x, b.pMax.y, b.pMin.z))); ret = Union(ret, M(Point3f(b.pMin.x, b.pMin.y, b.pMax.z))); ret = Union(ret, M(Point3f(b.pMin.x, b.pMax.y, b.pMax.z))); ret = Union(ret, M(Point3f(b.pMax.x, b.pMax.y, b.pMin.z))); ret = Union(ret, M(Point3f(b.pMax.x, b.pMin.y, b.pMax.z))); ret = Union(ret, M(Point3f(b.pMax.x, b.pMax.y, b.pMax.z))); return ret;&#125; EXERSICE： 通过将包围盒视为一个中心和一个偏移量的组合： B=[min⁡(cx±rxcy±rycz±rz)max⁡(cx±rxcy±rycz±rz)]B = \\left[ \\begin{matrix} \\min\\left( \\begin{matrix} c_x \\pm r_x\\\\ c_y \\pm r_y\\\\ c_z \\pm r_z\\\\ \\end{matrix} \\right) &amp; \\max\\left( \\begin{matrix} c_x \\pm r_x\\\\ c_y \\pm r_y\\\\ c_z \\pm r_z\\\\ \\end{matrix} \\right) \\end{matrix} \\right]B=⎣⎡​min⎝⎛​cx​±rx​cy​±ry​cz​±rz​​⎠⎞​​max⎝⎛​cx​±rx​cy​±ry​cz​±rz​​⎠⎞​​⎦⎤​ B′=[min⁡(M(cx±rxcy±rycz±rz1))max⁡(M(cx±rxcy±rycz±rz1))]B&#x27; = \\left[ \\begin{matrix} \\min\\left(M\\left( \\begin{matrix} c_x \\pm r_x\\\\ c_y \\pm r_y\\\\ c_z \\pm r_z\\\\ 1 \\end{matrix} \\right)\\right) &amp; \\max\\left(M\\left( \\begin{matrix} c_x \\pm r_x\\\\ c_y \\pm r_y\\\\ c_z \\pm r_z\\\\ 1 \\end{matrix} \\right)\\right) \\end{matrix} \\right]B′=⎣⎢⎢⎡​min⎝⎜⎜⎛​M⎝⎜⎜⎛​cx​±rx​cy​±ry​cz​±rz​1​⎠⎟⎟⎞​⎠⎟⎟⎞​​max⎝⎜⎜⎛​M⎝⎜⎜⎛​cx​±rx​cy​±ry​cz​±rz​1​⎠⎟⎟⎞​⎠⎟⎟⎞​​⎦⎥⎥⎤​ 其中可以通过矩阵分解与移动取最值的次序可得： min⁡(M(c1±r1c2±r2c3±r31))=min⁡((∑i=13Mcoli(ci±ri))+Mcol4)=(∑i=13min⁡(Mcoli(ci±ri)))+Mcol4\\min\\left(M\\left( \\begin{matrix} c_1 \\pm r_1\\\\ c_2 \\pm r_2\\\\ c_3 \\pm r_3\\\\ 1 \\end{matrix} \\right)\\right)\\\\ =\\min\\left( \\left(\\sum_{i=1}^3M_{coli}(c_i \\pm r_i)\\right) + M_{col4} \\right)\\\\ =\\left(\\sum_{i=1}^3\\min(M_{coli}(c_i \\pm r_i))\\right) + M_{col4}min⎝⎜⎜⎛​M⎝⎜⎜⎛​c1​±r1​c2​±r2​c3​±r3​1​⎠⎟⎟⎞​⎠⎟⎟⎞​=min((i=1∑3​Mcoli​(ci​±ri​))+Mcol4​)=(i=1∑3​min(Mcoli​(ci​±ri​)))+Mcol4​ 通过这种方法可以将计算的复杂度大大降低。 Arvo, J. 1990. Transforming axis-aligned bounding boxes. In A. S. Glassner (Ed.), Graphics Gems I, 548–50. San Diego: Academic Press. 2.8.6 变换的合成 变换的合成和矩阵的合成无异，遵从矩阵乘法的相关规律 1234Transform Transform::operator*(const Transform &amp;t2) const &#123; return Transform(Matrix4x4::Mul(m, t2.m), Matrix4x4::Mul(t2.mInv, mInv));&#125; 2.8.7 变换与坐标系的手性 部分变换会改变坐标系的手性（比如将单位变换中某一维度取反），这种特性可以通过对变换矩阵的非齐次部分（即新坐标系在老坐标系下的三个基）的行列式的符号得到。 当行列式值为负时，表示手性发生了转换 2.9 Animating Transformations ⚠️ 这部分包括了变换动画、四元数、变化的包围盒等内容，容我以后再看 2.10 Interactions SurfaceInteraction 类表示了物体表面上的一点处的局部信息，如光线-物体的相交，而 MediumInteraction 类则用于表示光线在空间参与介质中某点处的散射情况，它们均从一个更一般的 Interaction 类中派生出来。 1234567891011struct Interaction &#123; // Interaction Public Methods ... // Interaction Public Data Point3f p; Float time; Vector3f pError; Vector3f wo; Normal3f n; MediumInterface mediumInterface;&#125;; 其成员变量的含义如下： 一个作用的发生需要空间中的一个位置 p 和时间 t ，pError 则给出了一个保守的有关该作用发生位置的错误边界以解决浮点误差问题（见 3.9 部分） 在光线上发生的作用则使用 wo 表示光线来源的方向 在表面的作用使用 n 表示法线 在介质中的作用使用 mediumInterface 表示介质 2.10.1 表面作用（Surface Interaction） 物体表面某点处的几何信息使用 SurfaceInteraction 类表示，这层抽象让大部分系统在处理表面时可以不关注不同几何体类型的实现。这一类型的定义如下： 1234567891011121314151617181920class SurfaceInteraction : public Interaction &#123;public: // SurfaceInteraction Public Methods ... // SurfaceInteraction Public Data Point2f uv; Vector3f dpdu, dpdv; Normal3f dndu, dndv; const Shape *shape = nullptr; struct &#123; Normal3f n; Vector3f dpdu, dpdv; Normal3f dndu, dndv; &#125; shading; const Primitive *primitive = nullptr; BSDF *bsdf = nullptr; BSSRDF *bssrdf = nullptr; mutable Vector3f dpdx, dpdy; mutable Float dudx = 0, dvdx = 0, dudy = 0, dvdy = 0;&#125;; 除了交点和交点法线外，这一类型中还储存了贴图位置 uv 、交点和法线关于 uv 的偏导数。 由于一个表面的几何信息可能由 bump-mapping 或顶点插值等方法生成，PBRT 在 SurfaceInteraction 类中储存了第二套表面信息，并用一个结构体给出。这里的信息可能在后续过程中被修改或设置，如下面这个函数： 123456789101112131415161718192021void SurfaceInteraction::SetShadingGeometry( const Vector3f &amp;dpdus, const Vector3f &amp;dpdvs, const Normal3f &amp;dndus, const Normal3f &amp;dndvs, bool orientationIsAuthoritative) &#123; // Compute shading.n for SurfaceInteraction shading.n = Normalize((Normal3f)Cross(dpdus, dpdvs)); if (shape &amp;&amp; (shape-&gt;reverseOrientation ^ shape-&gt;transformSwapsHandedness)) shading.n = -shading.n; if (orientationIsAuthoritative) n = Faceforward(n, shading.n); else shading.n = Faceforward(shading.n, n); // Initialize shading partial derivative values shading.dpdu = dpdus; shading.dpdv = dpdvs; shading.dndu = dndus; shading.dndv = dndvs;&#125; 之所以对于法线的方向进行了一系列的调整，是因为在 PBRT 中物体法线的方向表示了物体的正向 / 外侧，而会改变坐标系手性的变换在作用于物体上会将其外侧的方向一起改变，因此需要通过传入的一个布尔值标识判断最终的法线方向取决于原始信息还是通过传入值计算的着色用法线。","categories":[{"name":"programming","slug":"programming","permalink":"https://blog.apassbydreg.work/categories/programming/"},{"name":"reading notes","slug":"programming/reading-notes","permalink":"https://blog.apassbydreg.work/categories/programming/reading-notes/"}],"tags":[{"name":"CG","slug":"CG","permalink":"https://blog.apassbydreg.work/tags/CG/"},{"name":"render","slug":"render","permalink":"https://blog.apassbydreg.work/tags/render/"},{"name":"PBRT","slug":"PBRT","permalink":"https://blog.apassbydreg.work/tags/PBRT/"}]},{"title":"PBRT 第一章笔记 | Notes for PBRT Chapter 01 - Introduction","slug":"PBRT-ch01","date":"2021-10-21T17:42:44.000Z","updated":"2021-11-04T14:21:47.856Z","comments":true,"path":"2021/10/PBRT-ch01/","link":"","permalink":"https://blog.apassbydreg.work/2021/10/PBRT-ch01/","excerpt":"","text":"1.1 Literate Programming 这部分与网页版的 PBRT 展示方式有关，此处跳过 1.2 Photorealistic Rendering and the Ray-Tracing Algorithm 真实感渲染的最终目的是得到足够接近真实世界的照片的渲染结果。大部分真实感渲染的系统均基于光线追踪的算法。光线追踪算法模拟了在场景中与物体交互、弹射的光线的路径，并以此计算摄像头最终接收到的颜色， 1.2.1 摄像机 摄像机的主要功能是根据像素在图像上的位置，生成对该位置有贡献的着色光线。 1.2.2 光线 - 物体相交 每当摄像机生成了光线后，渲染器的首要工作是确定该光线是否有击中任何物体，并找出第一个相交的物体和相交的位置。在找到相交的表面后，渲染器将提取交点处的法线、uv、微分等信息以供着色。 1.2.3 光照分布 在获得了着色位置的表面信息后，需要得到场景中的光照分布以计算该处的辐照度。由于在 PBRT 的假设中光照是线性的，对于多个光源可以简单地叠加其影响。 1.2.4 可见性 可见性补充了光照分布中阴影的缺失。光线追踪渲染器可以简单的使用光线相交技术确定在着色表面是否可被光源影响。 1.2.5 表面散射 在得到了光线的入射、出射方向和表面信息后，PBRT 会计算在此情况下光线在表面作用后出射的结果。PBRT 使用 BRDF / BTDF 表示能量的传递过程。 1.2.6 间接光照传输 Turner Whitted 最早的有关光线追踪的论文中就强调了其递归的性质，这使得它可以对间接光照进行建模，这给出了著名的光线传输方程： Lo(p,ωo)=Le(p,ωo)+∫S2f(p,ωo,ωi)Li(p,ωi)∣cos⁡θi∣dωiL_{\\mathrm{o}}\\left(\\mathrm{p}, \\omega_{\\mathrm{o}}\\right)=L_{\\mathrm{e}}\\left(\\mathrm{p}, \\omega_{\\mathrm{o}}\\right)+\\int_{\\mathrm{S}^{2}} f\\left(\\mathrm{p}, \\omega_{\\mathrm{o}}, \\omega_{\\mathrm{i}}\\right) L_{\\mathrm{i}}\\left(\\mathrm{p}, \\omega_{\\mathrm{i}}\\right)\\left|\\cos \\theta_{\\mathrm{i}}\\right| \\mathrm{d} \\omega_{\\mathrm{i}} Lo​(p,ωo​)=Le​(p,ωo​)+∫S2​f(p,ωo​,ωi​)Li​(p,ωi​)∣cosθi​∣dωi​ 1.2.7 光线传输 前文所描述的内容均基于光线在真空中传播的假设，然而事实上光线经常需要经过参与介质。参与介质会产生消光或增强的效果。渲染器需要对这些现象进行建模和模拟， 1.3 PBRT: System Overview PBRT 使用标准的面向对象编程技术编写。总共有 10 种关键的基类： 1.3.1 运行阶段 PBRT 的运行可以被分为两段：首先它会解析场景描述文件，这个描述文件会产生一个 Scene 实例和一个 Integrator 实例，前者包含了场景的所有信息，后者包含了渲染这个场景的算法。第二个也是主要耗时的阶段是渲染阶段。PBRT 会调用 Integrator::Render() 方法渲染整个场景。 1.3.2 场景表示 123456789101112131415class Scene &#123; public: // Scene Public Methods ... // Scene Public Data std::vector&lt;std::shared_ptr&lt;Light&gt;&gt; lights; // Store infinite light sources separately for cases where we only want // to loop over them. std::vector&lt;std::shared_ptr&lt;Light&gt;&gt; infiniteLights; private: // Scene Private Data std::shared_ptr&lt;Primitive&gt; aggregate; Bounds3f worldBound;&#125;; 每个光源被表示为一个 Light 对象，其中储存了光源的形状和其能量的分布。Scene 类使用智能指针储存这些对象。（特别的，无穷远处的光源被单独储存以备他用） 场景中的每个几何体被表示为一个 Primitive 对象，其中保存了其性质 Shape 和材质 Material ，Scene 对象中保存的是一种特殊的几何体 aggregate ，它保存了所有的几何体，并实现了与普通 Primitive 一致的接口。 1.3.3 Integrator 接口和 SamplerIntegrator 图片的渲染由继承了 Integrator 接口的实例完成，其中定义了渲染用的 void Render(const Scene &amp;scene) 函数： 123456class Integrator &#123; public: // Integrator Interface virtual ~Integrator(); virtual void Render(const Scene &amp;scene) = 0;&#125;; Integrator 的一个子类是 SamplerIntegrator ，它的渲染过程来自于一连串从 Sampler 获取的采样，每个采样均计算了图像上的某一点收到的光量。 12345678910111213141516class SamplerIntegrator : public Integrator &#123; public: SamplerIntegrator( ... ) : ... &#123;&#125; virtual void Preprocess( ... ) &#123;&#125; void Render(const Scene &amp;scene); virtual Spectrum Li( ... ) const = 0; Spectrum SpecularReflect( ... ) const; Spectrum SpecularTransmit( ... ) const; protected: std::shared_ptr&lt;const Camera&gt; camera; private: std::shared_ptr&lt;Sampler&gt; sampler; const Bounds2i pixelBounds;&#125;; 其中的 sampler 成员负责生成用于积分的采样，而 camera 成员则保存了相机相关的信息，其中包含了保存渲染结果的 Film 对象 1.3.4 主渲染循环 12345678910111213141516void SamplerIntegrator::Render(const Scene &amp;scene) &#123; Preprocess(scene, *sampler); // &lt;&lt;Render image tiles in parallel&gt;&gt; // &lt;&lt;Compute number of tiles, nTiles, to use for parallel rendering&gt;&gt; ParallelFor2D([&amp;](Point2i tile) &#123; // &lt;&lt;Render section of image corresponding to tile&gt;&gt; // &lt;&lt;Allocate MemoryArena for tile&gt;&gt; // &lt;&lt;Get sampler instance for tile&gt;&gt; // &lt;&lt;Compute sample bounds for tile&gt;&gt; // &lt;&lt;Get FilmTile for tile&gt;&gt; // &lt;&lt;Loop over pixels in tile to render them&gt;&gt; // &lt;&lt;Merge image tile into Film&gt;&gt; &#125;, nTiles); // &lt;&lt;Save final image after rendering&gt;&gt; camera-&gt;film-&gt;WriteImage();&#125; 1.3.5 Whitted Ray Tracing 的积分器 这是一种基础的光线追踪算法使用的积分器，其 Li 函数的运行流程如下 1.4 Parallelization of PBRT 本章节描述了 PBRT 中并行化的必要性、并行化的风险以及并行化中需要注意的问题。其中线程不安全的内容包括： 大部分的基础类型：如 Point3f, Vector3f, Transform 等使用频次过高的类型，对这些类型实现线程安全会导致极大的性能损失 工具类：如 MemoryArena, RNG, Sampler 等类型一般在每个线程中单独生成并使用，不做跨线程通信 预处理函数：由于 PBRT 的 Parsing 阶段一般是串行执行的，这类在初始化时调用的预处理函数一般也不是线程安全的 1.5 How to Proceed through This Book 教你怎么用这本书的一节，此处略 1.6 Using and Understanding the Code 教你怎么用这本书的代码的一节，此处略 1.7 A Brief History of Physically Based Rendering 本章的翻译链接： GitHub - kanition/pbrtbook: pbrt 中文整合翻译 基于物理的渲染：从理论到实现 Physically Based Rendering: From Theory To Implementation","categories":[{"name":"programming","slug":"programming","permalink":"https://blog.apassbydreg.work/categories/programming/"},{"name":"reading notes","slug":"programming/reading-notes","permalink":"https://blog.apassbydreg.work/categories/programming/reading-notes/"}],"tags":[{"name":"CG","slug":"CG","permalink":"https://blog.apassbydreg.work/tags/CG/"},{"name":"render","slug":"render","permalink":"https://blog.apassbydreg.work/tags/render/"},{"name":"PBRT","slug":"PBRT","permalink":"https://blog.apassbydreg.work/tags/PBRT/"}]},{"title":"基于 Optix 的渲染器框架 | Optix Based Renderer Framework","slug":"OptixBasedRendererFramework","date":"2021-10-20T05:49:29.000Z","updated":"2022-02-26T02:41:34.668Z","comments":true,"path":"2021/10/OptixBasedRendererFramework/","link":"","permalink":"https://blog.apassbydreg.work/2021/10/OptixBasedRendererFramework/","excerpt":"","text":"简介 本项目是一个基于 Optix 7.3 的 GPU 光线追踪渲染框架，在保障了一定的可拓展性的同时，利用 NVIDIA 光线追踪技术提高了渲染的效率。 新版本已发布，详见新版本介绍页面 渲染样例 summary { cursor: pointer; transition: all ease 0.2s; } summary:hover { font-weight: bold; background-color: rgba(0, 0, 0, 0.05); } > Simple Mirror > Cornell Box > GGX Grid 相关链接 代码仓库：https://gitee.com/martin_z_he/optix-based-renderer 介绍文档：https://gitee.com/martin_z_he/optix-based-renderer/raw/master/doc/presentations/presentation-20210830.pdf 附录 框架结构总览 框架渲染流程","categories":[{"name":"programming","slug":"programming","permalink":"https://blog.apassbydreg.work/categories/programming/"},{"name":"projects","slug":"programming/projects","permalink":"https://blog.apassbydreg.work/categories/programming/projects/"}],"tags":[{"name":"CG","slug":"CG","permalink":"https://blog.apassbydreg.work/tags/CG/"},{"name":"render","slug":"render","permalink":"https://blog.apassbydreg.work/tags/render/"},{"name":"OBR","slug":"OBR","permalink":"https://blog.apassbydreg.work/tags/OBR/"}]},{"title":"转发树可视化展示 | Repost Tree Visualization","slug":"RepostTreeVisualization","date":"2021-10-20T05:39:11.000Z","updated":"2021-11-04T14:21:47.856Z","comments":true,"path":"2021/10/RepostTreeVisualization/","link":"","permalink":"https://blog.apassbydreg.work/2021/10/RepostTreeVisualization/","excerpt":"","text":"简介 北京航空航天大学『数据可视化分析技术』课程第二次小作业作品。展示了一个推文 / 博文的转发途径 演示链接：https://apassbydreg.github.io/RepostTreeVisualization/ 参考论文：R-Map: A Map Metaphor for Visualizing Information Reposting Process in Social Media S. Chen, S. Li, S. Chen and X. Yuan, 『R-Map: A Map Metaphor for Visualizing Information Reposting Process in Social Media,』 in IEEE Transactions on Visualization and Computer Graphics, vol. 26, no. 1, pp. 1204-1214, Jan. 2020, doi: 10.1109/TVCG.2019.2934263. 图标释义 本可视化主要分为两部分，左侧是关键节点部分，右侧是每个关键节点对应的时间线，下方是节点信息的展示区域。图标的具体释义如下： 深蓝色圆圈：根节点，即转发树上的原始博文 浅蓝色圆圈：关键节点，是所有节点中子树从大到小排列前 K 位的节点 绿色方块：颜色从浅到深对应了该时间点处节点的平均深度从小到大 交互逻辑 界面默认使用模拟的样例数据进行展示，你也可以选择你自己的数据进行可视化。需要注意的是选择的数据需要符合样例数据的格式（你可以点击右侧按钮查看样例数据）。 你也可以通过点击标题中的蓝色部分下载当前可视化的数据。 你可以通过 Add / Remove 按钮进行关键节点数量的增减操作 你可以通过点击任意一个节点或时间块以在下方查看该部分的详细信息 实现方法 本实现采用 Vue.js 作为基础设施，实现了一个响应式的页面，让数据可以自动地 另外利用了 Material Design Bootstrap 辅助开发，大大简化了代码的复杂度 数据部分使用了少量基于深度优先搜索的简单树算法","categories":[{"name":"programming","slug":"programming","permalink":"https://blog.apassbydreg.work/categories/programming/"},{"name":"projects","slug":"programming/projects","permalink":"https://blog.apassbydreg.work/categories/programming/projects/"}],"tags":[{"name":"visualization","slug":"visualization","permalink":"https://blog.apassbydreg.work/tags/visualization/"},{"name":"web","slug":"web","permalink":"https://blog.apassbydreg.work/tags/web/"}]}],"categories":[{"name":"programming","slug":"programming","permalink":"https://blog.apassbydreg.work/categories/programming/"},{"name":"presentation notes","slug":"programming/presentation-notes","permalink":"https://blog.apassbydreg.work/categories/programming/presentation-notes/"},{"name":"reading notes","slug":"programming/reading-notes","permalink":"https://blog.apassbydreg.work/categories/programming/reading-notes/"},{"name":"projects","slug":"programming/projects","permalink":"https://blog.apassbydreg.work/categories/programming/projects/"},{"name":"gamedev","slug":"programming/gamedev","permalink":"https://blog.apassbydreg.work/categories/programming/gamedev/"}],"tags":[{"name":"GTC","slug":"GTC","permalink":"https://blog.apassbydreg.work/tags/GTC/"},{"name":"CUDA","slug":"CUDA","permalink":"https://blog.apassbydreg.work/tags/CUDA/"},{"name":"GPU Programming","slug":"GPU-Programming","permalink":"https://blog.apassbydreg.work/tags/GPU-Programming/"},{"name":"OOP","slug":"OOP","permalink":"https://blog.apassbydreg.work/tags/OOP/"},{"name":"Game Programming Patterns","slug":"Game-Programming-Patterns","permalink":"https://blog.apassbydreg.work/tags/Game-Programming-Patterns/"},{"name":"CG","slug":"CG","permalink":"https://blog.apassbydreg.work/tags/CG/"},{"name":"render","slug":"render","permalink":"https://blog.apassbydreg.work/tags/render/"},{"name":"GDC talks","slug":"GDC-talks","permalink":"https://blog.apassbydreg.work/tags/GDC-talks/"},{"name":"GPU Gems 3","slug":"GPU-Gems-3","permalink":"https://blog.apassbydreg.work/tags/GPU-Gems-3/"},{"name":"PBRT","slug":"PBRT","permalink":"https://blog.apassbydreg.work/tags/PBRT/"},{"name":"visualization","slug":"visualization","permalink":"https://blog.apassbydreg.work/tags/visualization/"},{"name":"web","slug":"web","permalink":"https://blog.apassbydreg.work/tags/web/"},{"name":"OBR","slug":"OBR","permalink":"https://blog.apassbydreg.work/tags/OBR/"},{"name":"RTR","slug":"RTR","permalink":"https://blog.apassbydreg.work/tags/RTR/"},{"name":"C++","slug":"C","permalink":"https://blog.apassbydreg.work/tags/C/"},{"name":"深度探索C++对象模型","slug":"深度探索C-对象模型","permalink":"https://blog.apassbydreg.work/tags/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"},{"name":"Unity","slug":"Unity","permalink":"https://blog.apassbydreg.work/tags/Unity/"},{"name":"GameLogic","slug":"GameLogic","permalink":"https://blog.apassbydreg.work/tags/GameLogic/"},{"name":"FX","slug":"FX","permalink":"https://blog.apassbydreg.work/tags/FX/"}]}